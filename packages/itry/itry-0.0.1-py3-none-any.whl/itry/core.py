# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['G', 'T', 'P', 'TypeLike', 'GuardFunc', 'repattern', 'nan', 'strtemplate', 'number', 'pathlike', 'ichain', 'iprod',
           'ziplong', 'dict_keys', 'dict_values', 'dict_items', 'moduletype', 'wrappertype', 'builtinfunctype',
           'nonetype', 'npdatasource', 'npbool', 'npmatrix', 'nparray', 'npnan', 'npNaN', 'npNAN', 'pdna', 'pdindex',
           'pdseries', 'pdcatindex', 'pddataframe', 'sparray', 'spmatrix', 'ptnan', 'ptdtype', 'ptdevice', 'ptmodule',
           'ptdataset', 'ptdataloader', 'pttensorbase', 'pttensor', 'ptinttensor', 'ptbooltensor', 'ptfloattensor',
           'ptdatasets', 'pttransforms', 'ptfunctional', 'pldatamodule', 'vidcap', 'image', 'anndata', 'mpl', 'plt',
           'artist', 'colormap', 'lscolormap', 'mplpatch', 'mplaxbase', 'mplaxes', 'sns', 'skestimator', 'PHATE',
           'gtbase', 'gtdata', 'bgraph', 'dgraph', 'lgraph', 'kgraph', 'tgraph', 'mgraph', 'klgraph', 'mlgraph',
           'tlgraph', 'tnew', 'imod', 'itry']

# %% ../nbs/00_core.ipynb 4
from importlib import import_module

# %% ../nbs/00_core.ipynb 5
from types import ModuleType, MethodWrapperType, BuiltinFunctionType, NoneType
from typing import (Type, Union, Tuple, Callable, ForwardRef, Optional, TypeVar, ParamSpec, TypeGuard, TypeAlias)

# %% ../nbs/00_core.ipynb 7
def tnew(
    n: str = '', 
    b: Union[Tuple[type, ...], type] = tuple(), 
    d: dict = dict(), 
    *, 
    c: Optional[Type[type]] = None, 
    **kwargs
) -> type:
    '''
    Create a new type using type.__new__.

    Parameters
    ----------
    n : str
        The name of the type.

    b : Union[Tuple[type, ...], type]

        A tuple containing base classes of the new type, or a single base class.
    d : dict
        A dictionary containing attributes and methods of the new type.

    c : Optional[Type[type]]
        A metaclass for the new type, defaults to None.

    **kwargs
        Additional keyword arguments to be included in the type's dictionary.

    Returns
    -------
    type
        The newly created type.

    Notes
    -----
    Calls `tnew` is equvialent to either

    type(name, bases, dict) : 
        if no class `c` is provided, or

    type.__new__(c, name, bases, dict) : 
        if a class `c` is provided.
    '''
    d.update(kwargs)
    if not isinstance(b, tuple): b = tuple((b, ))
    return type(n, tuple(b), d) if c is None else type.__new__(c, n, tuple(b), d)


# %% ../nbs/00_core.ipynb 8
def imod(
    name: str, 
    attr: Optional[str] = None,
    bases: Union[Tuple[type, ...], type] = tuple(), 
    namespace: dict = dict(),
    default: Optional[type] = None,
    **kwargs
) -> Optional[type]:
    '''
    Import a specific attribute from a module or return a default value if import fails.

    Parameters
    ----------
    name : str
        The name of the module to import from.
    attr : Optional[str]
        The name of the attribute to import from the module, defaults to None.
    bases : Union[Tuple[type, ...], type]
        Base classes for creating a new type if import fails and default is None.
    namespace : dict
        A namespace dictionary for creating a new type.
    default : Optional[type]
        A default value to return if import fails.
    **kwargs
        Additional keyword arguments passed to tnew.

    Returns
    -------
    Optional[type]
        The imported attribute, or the default value, or a new type created using tnew.
    '''
    cls = kwargs.pop('cls', None)
    if not isinstance(bases, tuple): bases = (bases, )
    
    try: 
        mod = import_module(name)
        return getattr(mod, attr) if attr is not None else mod
    except (ImportError, AttributeError):
        if default is not None: return default
        try: return namespace.get(attr, tnew(attr, bases, namespace, c=cls, **kwargs))
        except TypeError: return default

# %% ../nbs/00_core.ipynb 9
def itry(
    name: str, 
    *attrs: str, 
    bases: Union[Tuple[type, ...], type] = tuple(), 
    namespace: dict = dict(), 
    **kwargs
) -> Tuple[Optional[type], ...]:
    '''
    Try to import multiple attributes from a module, returning a tuple of results.

    Parameters
    ----------
    name : str
        The name of the module to import from.

    attrs : str
        Variable number of attribute names to import from the module.

    bases : Union[Tuple[type, ...], type]
        Base classes for creating new types if import fails.

    namespace : dict
        A namespace dictionary for creating new types.

    **kwargs
        Additional keyword arguments passed to imod.

    Returns
    -------
    Tuple[Optional[type], ...]
        A tuple of the imported attributes or default values.
    '''
    return tuple(imod(name, attr, bases, namespace, **kwargs) for attr in attrs)  

# %% ../nbs/00_core.ipynb 11
G = TypeVar('G')
T = TypeVar('T')
P = ParamSpec('P')

TypeLike:  TypeAlias = Union[Type, TypeAlias, Type[T]]
GuardFunc: TypeAlias = Callable[P, TypeGuard[TypeLike]]

# %% ../nbs/00_core.ipynb 14
repattern = imod('re', 'Pattern')
nan = imod('math', 'nan')
strtemplate = imod('string', 'Template')
number = imod('numbers', 'Number')
pathlike = imod('pathlib', 'Path')
(ichain, iprod, ziplong) = itry('itertools', 'chain', 'product', 'zip_longest')
dict_keys, dict_values, dict_items = itry('_collections_abc', 'dict_keys', 'dict_values', 'dict_items')

# %% ../nbs/00_core.ipynb 15
moduletype, wrappertype, builtinfunctype, nonetype = \
    itry('types', 'ModuleType', 'MethodWrapperType', 'BuiltinFunctionType', 'NoneType')

# %% ../nbs/00_core.ipynb 17
npdatasource = imod('numpy', 'DataSource', default=pathlike)
npbool = imod('numpy', 'bool_', default=bool)
npmatrix, nparray = itry('numpy', 'matrix', 'ndarray', default=list)
npnan, npNaN, npNAN = itry('numpy', 'nan', 'NaN', 'NAN', default=nan)

# %% ../nbs/00_core.ipynb 19
pdna = imod('pandas', 'NA', default=nan)
pdindex, pdseries, pdcatindex, pddataframe = \
    itry('pandas', 'Index', 'Series', 'CategoricalIndex', 'DataFrame', default=list)

# %% ../nbs/00_core.ipynb 21
sparray = imod('scipy.sparse._arrays', '_sparray')
sparray = imod('scipy.sparse', 'sparray', default=(sparray or list))
spmatrix = imod('scipy.sparse', 'spmatrix', default=list)

# %% ../nbs/00_core.ipynb 23
ptnan = imod('torch', 'nan', default=nan)
ptdtype, ptdevice = itry('torch', 'dtype', 'device')
ptmodule = imod('torch.nn', 'Module')
ptdataset, ptdataloader = itry('torch.utils.data', 'Dataset', 'DataLoader')

pttensorbase = imod('torch._C', '_TensorBase')
pttensor = imod('torch', 'Tensor', bases=(pttensorbase, ))
ptinttensor, ptbooltensor, ptfloattensor = \
    itry('torch', 'IntTensor', 'BoolTensor', 'FloatTensor', bases=(pttensor, ))


# %% ../nbs/00_core.ipynb 25
ptdatasets = imod('torchvision.datasets')
pttransforms = imod('torchvision.transforms')
ptfunctional = imod('torchvision.transforms.functional')

# %% ../nbs/00_core.ipynb 27
pldatamodule, = itry('pytorch_lightning', 'LightningDataModule', default=list)

# %% ../nbs/00_core.ipynb 29
vidcap, = itry('cv2', 'VideoCapture')

# %% ../nbs/00_core.ipynb 31
image, = itry('PIL.Image', 'Image')

# %% ../nbs/00_core.ipynb 33
anndata, = itry('anndata', 'AnnData')

# %% ../nbs/00_core.ipynb 35
mpl = imod('matplotlib')
plt = imod('matplotlib', 'pyplot', bases=(ModuleType, ))
artist, = itry('matplotlib.artist', 'Artist')

colormap, = itry('matplotlib.colors', 'Colormap')
lscolormap, = itry('matplotlib.colors', 'LinearSegmentedColormap', bases=(colormap, ))

mplpatch, = itry('matplotlib.patches', 'Patch', bases=(artist, ))
mplaxbase, = itry('matplotlib.axes._axes', '_AxesBase', bases=(artist, ))
mplaxes, = itry('matplotlib.axes._axes', 'Axes', bases=(mplaxbase, ))

# %% ../nbs/00_core.ipynb 37
sns = imod('seaborn')

# %% ../nbs/00_core.ipynb 39
skestimator, = itry('sklearn.base', 'BaseEstimator')

# %% ../nbs/00_core.ipynb 41
PHATE, = itry('phate', 'PHATE', bases=(skestimator, ))

# %% ../nbs/00_core.ipynb 43
gtbase, = itry('graphtools.base', 'Base')
gtdata, = itry('graphtools.base', 'Data', bases=(gtbase, ))

bgraph, = itry('graphtools.base', 'BaseGraph', bases=(gtbase, ))
dgraph, = itry('graphtools.base', 'Data', bases=(gtdata, bgraph))


lgraph, kgraph, tgraph, mgraph = \
    itry('graphtools.graphs', 'LandmarkGraph', 'kNNGraph', 'TraditionalGraph', 'MNNGraph', bases=(dgraph, ))


klgraph, = itry('graphtools.graphs', 'kNNLandmarkGraph', bases=(kgraph, lgraph, ))
mlgraph, = itry('graphtools.graphs', 'MNNLandmarkGraph', bases=(mgraph, lgraph, ))
tlgraph, = itry('graphtools.graphs', 'TraditionalLandmarkGraph', bases=(tgraph, lgraph, ))
