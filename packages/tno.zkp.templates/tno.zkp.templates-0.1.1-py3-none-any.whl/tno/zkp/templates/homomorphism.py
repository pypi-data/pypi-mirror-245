"""
Homomorphism abstract classes which must be implemented to be able to create a sigma protocol.
"""
from __future__ import annotations

import sys
from typing import Protocol, TypeVar, runtime_checkable

if sys.version_info < (3, 11):
    from typing_extensions import Self
else:
    from typing import Self


class SupportsMultiplicationAndAddition(Protocol):
    """
    Protocol which states that a multiplication function must be provided.
    """

    def __mul__(self, other: object) -> Self:
        """
        Multiply the object with another object and return the result
        :param other: Object to multiply with
        :return: The result of the multiplication
        """

    def __add__(self, other: object) -> Self:
        """
        Add  the object with another object and return the result
        :param other: Object to do addition with
        :return: The result of the addition
        """


HomomorphismOutputT = TypeVar(
    "HomomorphismOutputT", bound=SupportsMultiplicationAndAddition
)
ChallengeT = TypeVar("ChallengeT", covariant=True)
InputElementT = TypeVar("InputElementT")
AdditionalInputT = TypeVar("AdditionalInputT")


@runtime_checkable
class HomomorphismInput(Protocol[InputElementT]):
    """
    Input for a homomorphism. The input should be additively homomorphic and be able to
    multiply with the challenge generated by the homomorphism.
    """

    @property
    def input_vector(self) -> list[InputElementT]:
        """
        The input vector to which a homomorphism is applied

        :return: vector of input elements
        """
        raise NotImplementedError()

    def __add__(self, other: object) -> Self:
        raise NotImplementedError()

    def __mul__(self, other: object) -> Self:
        raise NotImplementedError()

    def __len__(self) -> int:
        return len(self.input_vector)


@runtime_checkable
class CompressibleHomomorphismInput(
    HomomorphismInput[InputElementT], Protocol[InputElementT]
):
    """
    Homomorphism input which can also be compressed. For the compression the input must be able to
    be split into two halves.
    """

    def split_in_half(self) -> tuple[Self, Self]:
        """
        Split the homomorphism input into two equal parts. Such that each part can evaluate an input
        vector of half the length.

        :return: Tuple consisting of left and right homomorphism
        """
        raise NotImplementedError()


class Homomorphism(Protocol[InputElementT, HomomorphismOutputT, ChallengeT]):
    r"""
    The homomorphism class is a class consisting of abstract methods. The class must be able to take
    in a vector of length $n$ and evaluate to an output. The size of $n$ is determined by a local
    property called `expected_input_size`.

    The homomorphism class is also known as the function $\psi$ in literature.

     The homomorphism assumes you can multiply the `InputElement` and `HomomorphismOutput` by the
     `Challenge` and that `InputElement` objects can be added together.
    """

    @property
    def input_size(self) -> int:
        """
        The length of the vector that can be processed by the homomorphism.

        :return: integer indicating the length of the excepted vector input
        """
        raise NotImplementedError()

    def evaluate(
        self, homomorphism_input: HomomorphismInput[InputElementT]
    ) -> HomomorphismOutputT:
        """
        Apply the homomorphism to the input.

        :param homomorphism_input: The input vector and any additional information necessary
        :return: The output of the homomorphism applied to the input
        """
        raise NotImplementedError()

    def random_input(self) -> HomomorphismInput[InputElementT]:
        """
        Generate a vector of length $n$ consisting of random input elements.

        :return: List of $n$ random input elements
        """
        raise NotImplementedError()

    def output_to_bytes(self, output: HomomorphismOutputT) -> bytes:
        """
        Transform the homomorphism output to a representation in bytes.

        :param output: The output to transform
        :return: bytes representing the homomorphism output
        """
        raise NotImplementedError()

    def challenge_from_bytes(self, hash_bytes: bytes) -> ChallengeT:
        """
        Create a challenge from the bytes that are received. The bytes must create a consistent way
        of generating the challenge.

        :param hash_bytes: the bytes to generate the challenge from
        :return: a Challenge object derived from the bytes
        """
        raise NotImplementedError()


@runtime_checkable
class CompressibleHomomorphism(
    Homomorphism[InputElementT, HomomorphismOutputT, ChallengeT],
    Protocol[InputElementT, HomomorphismOutputT, ChallengeT],
):
    """
    An abstract class which extends the `Homomorphism`-class with functions. The additional
    functions enable the compression mechanism to compress the sigma protocol.
    """

    def split_in_half(self) -> tuple[Self, Self]:
        """
        Split the homomorphism into two new homomorphisms where the input size is of length $n/2$.
        The homomorphisms are split into a left and right half and map from the same groups.

        :return: Tuple of two homomorphisms with input size of $n/2$, with the left half being the
         first element and the right half being the second element of the tuple.
        """
        raise NotImplementedError()

    def __mul__(self, other: object) -> Self:
        """
        Multiply the homomorphism by the challenge.

        :param other: the challenge to multiply by.
        :return: A new homomorphism mapping from the same groups.
        """
        raise NotImplementedError()

    def __add__(self, other: object) -> Self:
        r"""
        Add two homomorphisms mapping from the same groups $\mathbb{G}^n$ and $\mathbb{H}$ to
        generate a new homomorphism.

        :param other: the homomorphism to add
        :return: The new homomorphism also mapping from $\mathbb{G}^n$ to $\mathbb{H}$.
        """
        raise NotImplementedError()
