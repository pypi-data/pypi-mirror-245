-- MAGIC %md
-- MAGIC This file was programmatically generated by the DAG GENERATOR at https://git.corp.adobe.com/ccea/dag-dq-generator <br>
-- MAGIC **`PLEASE DO NOT MODIFY THE FILE`**

-- COMMAND ----------
-- Databricks notebook source
-- Set runtime parameters
SET spark.sql.sources.partitionOverwriteMode=dynamic

-- COMMAND ----------
WITH        
{%- if period_type == 'DAILY' %} date_dim AS (

    SELECT DISTINCT
        date_date
        , fiscal_yr_and_wk_desc
        , TO_DATE(fiscal_wk_ending_date)      AS fiscal_wk_ending_date
        , DATE_SUB(fiscal_wk_ending_date, 6)  AS  fiscal_wk_starting_date
        , fiscal_yr_and_qtr_desc
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr_and_qtr_desc ORDER BY date_date)      AS fiscal_qtr_starting_date
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr_and_qtr_desc ORDER BY date_date DESC) AS fiscal_qtr_ending_date
        , fiscal_yr
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr ORDER BY date_date)       AS fiscal_yr_starting_date
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr ORDER BY date_date DESC)  AS fiscal_yr_ending_date
    FROM ids_coredata.dim_date

),
{%- elif period_type == 'FISCAL_WK' %} date_dim AS (

    SELECT DISTINCT
        fiscal_yr_and_wk_desc
        , TO_DATE(fiscal_wk_ending_date)      AS fiscal_wk_ending_date
        , DATE_SUB(fiscal_wk_ending_date, 6)  AS  fiscal_wk_starting_date
        , fiscal_yr_and_qtr_desc
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr_and_qtr_desc ORDER BY date_date)      AS fiscal_qtr_starting_date
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr_and_qtr_desc ORDER BY date_date DESC) AS fiscal_qtr_ending_date
        , fiscal_yr
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr ORDER BY date_date)       AS fiscal_yr_starting_date
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr ORDER BY date_date DESC)  AS fiscal_yr_ending_date
    FROM ids_coredata.dim_date

),
{%- elif period_type == 'FISCAL_QTR' %} date_dim AS (

    SELECT DISTINCT
          NULL AS fiscal_yr_and_wk_desc
        , NULL  AS fiscal_wk_ending_date
        , NULL  AS  fiscal_wk_starting_date
        , fiscal_yr_and_qtr_desc
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr_and_qtr_desc ORDER BY date_date) AS fiscal_qtr_starting_date
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr_and_qtr_desc ORDER BY date_date DESC)  AS fiscal_qtr_ending_date
        , fiscal_yr
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr ORDER BY date_date) AS fiscal_yr_starting_date
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr ORDER BY date_date DESC)  AS fiscal_yr_ending_date
    FROM ids_coredata.dim_date

),
{%- elif period_type == 'FISCAL_YR' %} date_dim AS (

    SELECT DISTINCT
          NULL AS fiscal_yr_and_wk_desc
        , NULL  AS fiscal_wk_ending_date
        , NULL  AS  fiscal_wk_starting_date
        , NULL fiscal_yr_and_qtr_desc
        , NULL AS fiscal_qtr_starting_date
        , NULL  AS fiscal_qtr_ending_date
        , fiscal_yr
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr ORDER BY date_date) AS fiscal_yr_starting_date
        , FIRST_VALUE(date_date) OVER (PARTITION BY fiscal_yr ORDER BY date_date DESC)  AS fiscal_yr_ending_date
    FROM ids_coredata.dim_date

),
{%- endif %}
{%- if partition and lookback_days and period_type != 'DAILY' %} date_range AS (

    SELECT 
          MIN(fiscal_yr)                  AS start_fiscal_yr
        , MIN(fiscal_yr_and_half_yr_desc) AS start_fiscal_yr_and_half_yr_desc
        , MIN(fiscal_yr_and_per_desc)     AS start_fiscal_yr_and_per_desc
        , MIN(fiscal_yr_and_qtr_desc)     AS start_fiscal_yr_and_qtr_desc
        , MIN(fiscal_yr_and_wk_desc)      AS start_fiscal_yr_and_wk_desc
    FROM ids_coredata.dim_date
    WHERE date_date = DATE_SUB('${execution_date}', {{lookback_days}})

),
{%- endif %} source_data AS (

    SELECT {{', '.join(key_dimensions + key_measures)}} {%- if partition %}, {{partition.col_name}} {%- endif %}
	FROM {{source_table}}
	{% if partition or extra_filters -%}
    WHERE  
        {%- if partition %} 
            {%- if lookback_days -%}
             {%- if period_type == 'DAILY' %} {{partition.col_name}} BETWEEN DATE_SUB({{partition.col_value}}, {{lookback_days}}) AND {{partition.col_value}}
             {%- elif period_type == 'FISCAL_WK' %} {{partition.col_name}} BETWEEN (SELECT start_fiscal_yr_and_wk_desc FROM date_range) AND {{partition.col_value}}
             {%- elif period_type == 'FISCAL_QTR' %} {{partition.col_name}} BETWEEN (SELECT start_fiscal_yr_and_qtr_desc FROM date_range) AND {{partition.col_value}}
             {%- elif period_type == 'FISCAL_YR' %} {{partition.col_name}} BETWEEN (SELECT start_fiscal_yr FROM date_range) AND {{partition.col_value}}
            {%- endif -%}
            {%- else %} {{partition.col_name}} = {{partition.col_value}} 
            {%- endif -%}
        {%- endif %}
        {%- if partition and extra_filters %} AND {%- endif -%}
        {%- if extra_filters %} {{extra_filters}} {%- endif -%}
    {%- endif %}

), table_metrics AS (

              SELECT 1 ID, 'num_count'          AS metric_name
    -- Key dimension metrics
    {% for kd in key_dimensions -%}
    UNION ALL SELECT 1 ID, 'num_dist_{{kd.split('.')[-1]}}'    AS metric_name
    UNION ALL SELECT 1 ID, 'count_null_{{kd.split('.')[-1]}}'  AS metric_name
    {% endfor %}
    -- Key measures metrics
    {% for km in key_measures -%}
    UNION ALL SELECT 1 ID, 'sum_{{km.split('.')[-1]}}'  AS metric_name
    UNION ALL SELECT 1 ID, 'avg_{{km.split('.')[-1]}}'  AS metric_name
    UNION ALL SELECT 1 ID, 'max_{{km.split('.')[-1]}}'  AS metric_name
    UNION ALL SELECT 1 ID, 'min_{{km.split('.')[-1]}}'  AS metric_name
    UNION ALL SELECT 1 ID, 'std_{{km.split('.')[-1]}}'  AS metric_name
    {% endfor %}
), dim_metrics AS (

              SELECT 1 ID, 'num_count'   AS metric_name
    {% for km in key_measures -%}
    UNION ALL SELECT 1 ID, 'sum_{{km.split('.')[-1]}}'  AS metric_name
    UNION ALL SELECT 1 ID, 'avg_{{km.split('.')[-1]}}'  AS metric_name
    UNION ALL SELECT 1 ID, 'max_{{km.split('.')[-1]}}'  AS metric_name
    UNION ALL SELECT 1 ID, 'min_{{km.split('.')[-1]}}'  AS metric_name
    UNION ALL SELECT 1 ID, 'std_{{km.split('.')[-1]}}'  AS metric_name
    {% endfor %}
), table_stats AS (

    SELECT 
        1           AS ID
        , COUNT(*)                                             AS num_count
        -- All the key dimensions
        {% for kd in key_dimensions -%}
        , COUNT(DISTINCT({{kd.split('.')[-1]}}))                             AS num_dist_{{kd.split('.')[-1]}}
        , SUM(CASE WHEN {{kd.split('.')[-1]}} IS NULL THEN 1 ELSE 0 END)     AS count_null_{{kd.split('.')[-1]}}
        {% endfor %}
        -- All the key measures
        {% for km in key_measures -%}
        , SUM({{km.split('.')[-1]}}) AS sum_{{km.split('.')[-1]}}
        , AVG({{km.split('.')[-1]}}) AS avg_{{km.split('.')[-1]}}
        , MAX({{km.split('.')[-1]}}) AS max_{{km.split('.')[-1]}}
        , MIN({{km.split('.')[-1]}}) AS min_{{km.split('.')[-1]}}
        , STDDEV({{km.split('.')[-1]}}) AS std_{{km.split('.')[-1]}}
        {% endfor %}
        {% if partition %}, {{partition.col_name}} {%- endif %}
    FROM source_data
    {% if partition %}GROUP BY {{partition.col_name}} {%- endif %}

), _clean_source_data AS (

    SELECT 
          CASE WHEN {{key_dimensions[0]}} IS NULL THEN '__na__' ELSE STRING({{key_dimensions[0]}}) END AS {{key_dimensions[0].split('.')[-1]}}
        {% for kd in key_dimensions[1:] -%}
        , CASE WHEN {{kd.split('.')[-1]}} IS NULL THEN '__na__' ELSE STRING({{kd.split('.')[-1]}}) END AS {{kd.split('.')[-1]}}
        {% endfor %}
        {%- for km in key_measures -%}
        , {{km.split('.')[-1]}}
        {% endfor %}
        {%- if partition %}, {{partition.col_name}} {%- endif %}
    FROM source_data

), dimensional_stats AS (

    SELECT 
        1                           AS ID
        , MAP_CONCAT( -- in reality, due to cleanup above, will dimensions will never be null
            CASE WHEN {{key_dimensions[0]}} IS NOT NULL THEN MAP('{{key_dimensions[0].split('.')[-1]}}', {{key_dimensions[0]}}) ELSE MAP() END
            {% for kd in key_dimensions[1:] -%}
            , CASE WHEN {{kd.split('.')[-1]}} IS NOT NULL THEN MAP('{{kd.split('.')[-1]}}', {{kd.split('.')[-1]}}) ELSE MAP() END
            {% endfor %}
        ) AS dim_val
        , COUNT(*) num_count
        
        -- All the key measures
        {% for km in key_measures -%}
        , SUM({{km.split('.')[-1]}}) AS sum_{{km.split('.')[-1]}}
        , AVG({{km.split('.')[-1]}}) AS avg_{{km.split('.')[-1]}}
        , MAX({{km.split('.')[-1]}}) AS max_{{km.split('.')[-1]}}
        , MIN({{km.split('.')[-1]}}) AS min_{{km.split('.')[-1]}}
        , STDDEV({{km.split('.')[-1]}}) AS std_{{km.split('.')[-1]}}
        {% endfor %}
        {% if partition %}, {{partition.col_name}} {%- endif %}
    FROM _clean_source_data
    --GROUP BY CUBE({{', '.join(key_dimensions)}}){% if partition %}, {{partition.col_name}} {%- endif %}
    GROUP BY GROUPING SETS({{', '.join(group_set)}}){% if partition %}, {{partition.col_name}} {%- endif %}

)
{%- if key_dimensions -%}
, all_stats AS (

    SELECT * 
    FROM dimensional_stats
    WHERE SIZE(dim_val) > 0

)
{%- endif -%}
, _updates AS (

    SELECT
        '{{source_table}}'          AS metric_source_table,
        metric_name                         AS metric_name,
        CASE WHEN metric_name = 'num_count'                   THEN num_count

            -- All the key dimensions
            {%- for kd in key_dimensions %}
            WHEN metric_name = 'num_dist_{{kd.split('.')[-1]}}'     THEN num_dist_{{kd.split('.')[-1]}}
            WHEN metric_name = 'count_null_{{kd.split('.')[-1]}}'   THEN count_null_{{kd.split('.')[-1]}}
            {%- endfor %}
            -- All the key measures
            {%- for km in key_measures %}
            WHEN metric_name = 'sum_{{km.split('.')[-1]}}'          THEN sum_{{km.split('.')[-1]}}
            WHEN metric_name = 'avg_{{km.split('.')[-1]}}'          THEN avg_{{km.split('.')[-1]}}
            WHEN metric_name = 'max_{{km.split('.')[-1]}}'          THEN max_{{km.split('.')[-1]}}
            WHEN metric_name = 'min_{{km.split('.')[-1]}}'          THEN min_{{km.split('.')[-1]}}
            WHEN metric_name = 'std_{{km.split('.')[-1]}}'          THEN std_{{km.split('.')[-1]}}
            {%- endfor %}

        END                                 AS metric_value,
        NULL                                AS metric_dimensions,
        '{{period_type}}'                   AS metric_calc_period_type,
        CURRENT_TIMESTAMP                   AS metric_calc_dttm,
        {% if partition -%} 
            {{partition.col_name}}
        {%- elif period_type == 'DAILY' -%}
            {{"'${execution_date}'"}} 
        {%- elif period_type == 'FISCAL_WK' -%}
            {{"'${fiscal_yr_and_wk_desc}'"}} 
        {%- elif period_type == 'FISCAL_QTR' -%}
            {{"'${fiscal_yr_and_qtr_desc}'"}} 
        {%- elif period_type == 'FISCAL_YR' -%}
            {{"'${fiscal_yr}'"}} 
        {%- else -%} CURRENT_DATE
        {%- endif %}  AS metric_calc_period
    FROM table_stats
    CROSS JOIN table_metrics ON table_stats.ID = table_metrics.ID

    UNION ALL

    SELECT
        '{{source_table}}'          AS metric_source_table,
        metric_name                 AS metric_name,
        CASE WHEN metric_name = 'num_count'       THEN num_count
            {%- for km in key_measures %}
            WHEN metric_name = 'sum_{{km.split('.')[-1]}}'          THEN sum_{{km.split('.')[-1]}}
            WHEN metric_name = 'avg_{{km.split('.')[-1]}}'          THEN avg_{{km.split('.')[-1]}}
            WHEN metric_name = 'max_{{km.split('.')[-1]}}'          THEN max_{{km.split('.')[-1]}}
            WHEN metric_name = 'min_{{km.split('.')[-1]}}'          THEN min_{{km.split('.')[-1]}}
            WHEN metric_name = 'std_{{km.split('.')[-1]}}'          THEN std_{{km.split('.')[-1]}}
            {%- endfor %}
        END                                 AS metric_value,
        dim_val                             AS metric_dimensions,
        '{{period_type}}'                   AS metric_calc_period_type,
        CURRENT_TIMESTAMP                   AS metric_calc_dttm,
        {% if partition -%} 
        {{partition.col_name}} 
        {%- elif period_type == 'DAILY' -%}
        {{"'${execution_date}'"}} 
        {%- elif period_type == 'FISCAL_WK' -%}
        {{"'${fiscal_yr_and_wk_desc}'"}} 
        {%- elif period_type == 'FISCAL_QTR' -%}
        {{"'${fiscal_yr_and_qtr_desc}'"}} 
        {%- elif period_type == 'FISCAL_YR' -%}
        {{"'${fiscal_yr}'"}} 
        {%- else -%} CURRENT_DATE
        {%- endif %}  AS metric_calc_period
    FROM all_stats
    CROSS JOIN dim_metrics ON all_stats.ID = dim_metrics.ID

), updates AS (

    SELECT
      u.metric_source_table
    , u.metric_name
    , u.metric_value
    , u.metric_dimensions
    , d.fiscal_yr_and_wk_desc 
    , d.fiscal_wk_starting_date
    , d.fiscal_wk_ending_date
    , d.fiscal_yr_and_qtr_desc
    , d.fiscal_qtr_starting_date
    , d.fiscal_qtr_ending_date
    , d.fiscal_yr
    , d.fiscal_yr_starting_date
    , d.fiscal_yr_ending_date
    , CURRENT_TIMESTAMP AS insert_dttm
    {% if partition and period_type == 'FISCAL_WK' -%}, d.fiscal_wk_ending_date  
    {%- elif partition and period_type == 'FISCAL_QTR' -%}, d.fiscal_qtr_ending_date  
    {%- elif partition and period_type == 'FISCAL_YR' -%}, d.fiscal_yr_ending_date  
    {%- else -%}, u.metric_calc_period 
    {%- endif %} AS metric_calc_period
    , u.metric_calc_period_type
    FROM _updates u
    LEFT JOIN date_dim d ON 
    {%- if partition and period_type == 'DAILY' %}  u.metric_calc_period = d.date_date {%- endif %}
    {%- if partition and period_type == 'FISCAL_WK' %}  u.metric_calc_period = d.fiscal_yr_and_wk_desc {%- endif %}
    {%- if partition and period_type == 'FISCAL_QTR' %} u.metric_calc_period = d.fiscal_yr_and_qtr_desc {%- endif %}
    {%- if partition and period_type == 'FISCAL_YR' %}  u.metric_calc_period = d.fiscal_yr {%- endif %}
    
)

INSERT OVERWRITE TABLE {{metric_table}}
SELECT
  metric_name,
  metric_value,
  metric_dimensions,
  metric_calc_period_type,
  fiscal_yr_and_wk_desc,
  fiscal_wk_starting_date,
  fiscal_wk_ending_date,
  fiscal_yr_and_qtr_desc,
  fiscal_qtr_starting_date,
  fiscal_qtr_ending_date,
  fiscal_yr,
  fiscal_yr_starting_date,
  fiscal_yr_ending_date,
  insert_dttm,
  metric_source_table,
  metric_calc_period
FROM updates

-- COMMAND ----------
OPTIMIZE {{metric_table}} 
WHERE metric_source_table = '{{source_table}}' {%- if partition and lookback_days and period_type == 'DAILY' %} AND metric_calc_period >= DATE_SUB('${execution_date}', {{lookback_days}}) {%- endif %}
ZORDER BY (metric_name) 

-- COMMAND ----------
VACUUM {{metric_table}}

{%- if anomaly_detection %}

-- COMMAND ----------

-- MAGIC %python
-- MAGIC import json
-- MAGIC
-- MAGIC _run_params = dbutils.notebook.entry_point.getCurrentBindings()
-- MAGIC
-- MAGIC _run_params['metric_source_table'] = '{{source_table}}'
-- MAGIC _run_params['period_type']         = '{{period_type}}'
-- MAGIC _run_params['top_n_measure_ops']   = "{{anomaly_detection.top_n_measure_ops|default("['sum']")}}"
-- MAGIC _run_params['top_n_measures']      = "{{anomaly_detection.top_n_measures|default("[]")}}"
-- MAGIC _run_params['top_n_dimensions']    = "{{anomaly_detection.top_n_dimensions|default("['__na__']")}}"
-- MAGIC _run_params['include_null_counts'] = "{{anomaly_detection.include_null_counts|default("False")}}"
-- MAGIC _run_params['include_dist_counts'] = "{{anomaly_detection.include_dist_counts|default("False")}}"
-- MAGIC #_run_params['end_period']         = "{{anomaly_detection.end_period|default("")}}"
-- MAGIC _run_params['ml_lookback_days']    = "{{anomaly_detection.ml_lookback_days|default("700")}}"
-- MAGIC _run_params['num_forcast_periods'] = "{{anomaly_detection.num_forcast_periods|default("7")}}"
-- MAGIC _run_params['dqs_dir']            =  "{{anomaly_detection.dqs_dir|default("/dbfs/dmeci/data_quality_framework/")}}"
-- MAGIC _run_params['num_images_per_page'] = "{{anomaly_detection.num_images_per_page|default("2")}}"
-- MAGIC _run_params['num_top_contributors']= "{{anomaly_detection.num_top_contributors|default("3")}}"
-- MAGIC _run_params['num_date_alerts_per_key_measure']  = "{{anomaly_detection.num_date_alerts_per_key_measure|default("2")}}"
-- MAGIC _run_params['num_latest_dates_to_exclude']      = "{{anomaly_detection.num_latest_dates_to_exclude|default("2")}}"
-- MAGIC _run_params['num_days_ignore_anoms_older_than'] = "{{anomaly_detection.num_days_ignore_anoms_older_than|default("21")}}"
-- MAGIC _run_params['measures_num_latest_dates_to_exclude'] = "{{anomaly_detection.measures_num_latest_dates_to_exclude|default("[]")}}"
-- MAGIC _run_params['prophet_params']      = "{{anomaly_detection.prophet_params|default("{'daily_seasonality': False, 'yearly_seasonality': True, 'weekly_seasonality': True, 'seasonality_mode': 'multiplicative', 'interval_width': 0.999, 'changepoint_range': 0.75,}")}}"
-- MAGIC #_run_params['slack_bot_token']    = "{{anomaly_detection.slack_bot_token|default("")}}"
-- MAGIC #_run_params['slack_channel_id']  = "{{anomaly_detection.slack_channel_id|default("")}}"

-- COMMAND ----------

-- MAGIC %python
-- MAGIC try:
-- MAGIC     dbutils.notebook.run("{{anomaly_detection.ad_detector_path|default("/ccea/data_quality/dq-anomaly-detector")}}", timeout_seconds={{anomaly_detection.ad_detector_timeout|default(0)}}, arguments=_run_params)
-- MAGIC except Exception as e:
-- MAGIC     print(e)

{%- endif %}