from asyncio import run as aiorun
from datetime import datetime
import os
import subprocess
import zipfile
import yaml
from typing import List, Optional

from rich import print
from rich.progress import Progress, SpinnerColumn, TextColumn
import typer

from launch import constants, utils
from launch.auth import cache
from launch.deployments import deployments_helper, remote_utils
from launch.utils import get_server_address, get_project_id

app = typer.Typer(rich_markup_mode="rich")

MODULE_HELP_TEXT = "whether or not to run the python entry point as a module. e.g. python -m flow"  # noqa: E501
WORKING_DIR_HELP_TEXT = "The working directory for your flow. Defaults to your current directory. This can be used if you need to include your working directory files with your executable."  # noqa: E501
REQUIREMENTS_HELP_TEXT = (
    "The requirements.txt file containing requirements for your flow."  # noqa: E501
)
STREAM_DEPLOYMENT_LOGS_HELP_TEXT = (
    "Whether or not to stream the deployment logs after submission."  # noqa: E501
)
STREAM_TO_EXTENSION_HELP_TEXT = (
    "Whether or not to stream the deployment logs to the extension."  # noqa: E501
)
BUILD_FILE_HELP = "The build.flow file generated by `buildflow build`, if not provided we will attempt to build one from your current directory."  # noqa
PROJECT_FILE_HEP = "The project id to submit to. If not set will default to your buildflow project in buildflow.yaml."  # noqa
ENVIRONMENT_HELP_TEXT = "The environment to use for your deployment."  # noqa


def _print_deployment_info(progress: Progress, deployment_id: str):
    progress.console.print("To check the status of a deployment: ")
    progress.console.print(f"    [bold][cyan]launch deployments ping {deployment_id}")
    progress.console.print()
    progress.console.print("To fetch the logs of a deployment: ")
    progress.console.print(f"    [bold][cyan]launch deployments logs {deployment_id}")
    progress.console.print()
    progress.console.print("To drain deployment run:")
    progress.console.print(f"    [bold][cyan]launch deployments drain {deployment_id}")
    progress.console.print()
    progress.console.print("To stop deployment run:")
    progress.console.print(f"    [bold][cyan]launch deployments stop {deployment_id}")
    progress.console.print()


@app.command(
    short_help="Submit a new deployment to a LaunchFlow Cloud project.",
    help=constants.SUBMIT_HELP_TEMPLATE.format(command="deployments submit"),
)
def submit(
    build_file: str = typer.Argument("", help=BUILD_FILE_HELP),
    project_id: Optional[str] = typer.Option(None, help=PROJECT_FILE_HEP),
    environment: Optional[str] = typer.Option(
        None, "--environment", "-e", help=ENVIRONMENT_HELP_TEXT
    ),
    dkey: Optional[str] = typer.Option(
        None, help="The deployment key to use when deploying to an environment."
    ),
    num_cpus: Optional[int] = typer.Option(None, help="The number of CPUs to use."),
    machine_type: Optional[str] = typer.Option(None, help="The machine type to use."),
    max_workers: Optional[int] = typer.Option(None, help="The max number of workers."),
    blocking: Optional[bool] = typer.Option(
        True,
        help="Whether or not the command should block until the deployment is running.",
    ),  # noqa
    launchflow_server_address: str = constants.LAUNCHFLOW_SERVER_ADDRESS_OPTION,
):  # noqa
    launchflow_server_address = get_server_address(launchflow_server_address)
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
    ) as progress:
        project_id = get_project_id(project_id)
        if not project_id:
            typer.echo(
                "No project id provided and no default project set. "
                "Please set a default project or provide a project id."
            )
            raise typer.Exit(1)
        if environment and not dkey:
            typer.echo(
                "No deployment key provided. Please provide a deployment key with "
                "--dkey when you are deploying to and environment."
            )
            raise typer.Exit(1)
        if not build_file:
            build_task = progress.add_task("[cyan]Building application...", total=1)
            try:
                subprocess.check_output(["buildflow", "build"])
            except subprocess.CalledProcessError as e:
                print("Build failed with exit code: ", e.returncode)
                raise typer.Exit(1)
            progress.advance(build_task)
            progress.remove_task(build_task)
            progress.console.print("[green]✓[/green] Build complete")
            build_file = "./.buildflow/build/build.flow"
        if not os.path.exists(build_file):
            typer.echo(f"Build file {build_file} does not exist.")
            raise typer.Exit(1)

        with zipfile.ZipFile(build_file, "r") as zip_ref:
            flowstate_str = zip_ref.open("flowstate.yaml")
            flowstate = yaml.safe_load(flowstate_str)
            python_version = flowstate["python_version"]
            ray_version = flowstate["ray_version"]

        if dkey:
            bearer_token = dkey
        else:
            bearer_token = cache.get_access_token(launchflow_server_address)
        submit_task = progress.add_task("[cyan]Launching deployment...", total=None)
        try:
            deployment_id = remote_utils.send_deploy_request(
                server_address=launchflow_server_address,
                build_file=build_file,
                project_id=project_id,
                environment=environment,
                bearer_token=bearer_token,
                num_cpus=num_cpus,
                machine_type=machine_type,
                max_workers=max_workers,
                python_version=python_version,
                ray_version=ray_version,
            )
        except Exception as e:
            progress.advance(submit_task)
            progress.remove_task(submit_task)
            progress.console.print(f"[red]✗[/red] Deployment failed: {e}")
            raise typer.Exit(1)
        progress.advance(submit_task)
        progress.remove_task(submit_task)
        progress.console.print("[green]✓[/green] Deployment launched")
        if blocking:
            remote_utils.poll_deployment_info(
                deployment_id=deployment_id,
                server_address=launchflow_server_address,
                progress=progress,
                bearer_token=bearer_token,
            )
        progress.console.print()
        _print_deployment_info(progress, deployment_id)


@app.command(
    help="Update an existing deployment not an environment from your local code"
)
def update(
    deployment_to_update: str = typer.Argument(
        ..., help="The source deployment to update"
    ),
    build_file: str = typer.Argument("", help=BUILD_FILE_HELP),
    num_cpus: Optional[int] = typer.Option(None, help="The number of CPUs to use."),
    machine_type: Optional[str] = typer.Option(None, help="The machine type to use."),
    max_workers: Optional[int] = typer.Option(None, help="The max number of workers."),
    blocking: Optional[bool] = typer.Option(
        True,
        help="Whether or not the command should block until the deployment is running.",
    ),  # noqa
    launchflow_server_address: str = constants.LAUNCHFLOW_SERVER_ADDRESS_OPTION,
):
    launchflow_server_address = get_server_address(launchflow_server_address)
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
    ) as progress:
        if not build_file:
            build_task = progress.add_task("[cyan]Building application...", total=1)
            try:
                subprocess.check_output(["buildflow", "build"])
            except subprocess.CalledProcessError as e:
                print("Build failed with exit code: ", e.returncode)
                raise typer.Exit(1)
            progress.advance(build_task)
            progress.remove_task(build_task)
            progress.console.print("[green]✓[/green] Build complete")
            build_file = "./.buildflow/build/build.flow"
        if not os.path.exists(build_file):
            raise ValueError(f"Build file {build_file} does not exist.")

        with zipfile.ZipFile(build_file, "r") as zip_ref:
            flowstate_str = zip_ref.open("flowstate.yaml")
            flowstate = yaml.safe_load(flowstate_str)
            python_version = flowstate["python_version"]
            ray_version = flowstate["ray_version"]

        bearer_token = cache.get_access_token(launchflow_server_address)

        submit_task = progress.add_task(
            "[cyan]Sending update deployment...", total=None
        )
        try:
            deployment_id = remote_utils.send_update_deployment_request(
                server_address=launchflow_server_address,
                build_file=build_file,
                bearer_token=bearer_token,
                num_cpus=num_cpus,
                machine_type=machine_type,
                max_workers=max_workers,
                python_version=python_version,
                ray_version=ray_version,
                deployment_to_update=deployment_to_update,
            )
        except Exception as e:
            progress.advance(submit_task)
            progress.remove_task(submit_task)
            progress.console.print(f"[red]✗[/red] Sending update failed: {e}")
            raise typer.Exit(1)
        progress.advance(submit_task)
        progress.remove_task(submit_task)
        progress.console.print("[green]✓[/green] Update deployment launched")
        progress.console.print()
        if blocking:
            remote_utils.poll_deployment_info(
                deployment_id=deployment_id,
                server_address=launchflow_server_address,
                progress=progress,
                bearer_token=bearer_token,
            )
        progress.console.print()
        _print_deployment_info(progress, deployment_id)


@app.command(
    help="Update an environment from your local code. "
    "If a deployment isn't running in the environment one will be launched."
)
def update_environment(
    build_file: str = typer.Argument("", help=BUILD_FILE_HELP),
    project_id: Optional[str] = typer.Option(None, help=PROJECT_FILE_HEP),
    environment: Optional[str] = typer.Option(
        None, "--environment", "-e", help=ENVIRONMENT_HELP_TEXT
    ),
    dkey: Optional[str] = typer.Option(
        None, help="The deployment key to use when deploying to an environment."
    ),
    blocking: Optional[bool] = typer.Option(
        True,
        help="Whether or not the command should block until the deployment is running.",
    ),  # noqa
    launchflow_server_address: str = constants.LAUNCHFLOW_SERVER_ADDRESS_OPTION,
):
    launchflow_server_address = get_server_address(launchflow_server_address)
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
    ) as progress:
        project_id = get_project_id(project_id)
        if not project_id:
            typer.echo(
                "No project id provided and no default project set. "
                "Please set a default project or provide a project id."
            )
            raise typer.Exit(1)
        if not build_file:
            build_task = progress.add_task("[cyan]Building application...", total=1)
            try:
                subprocess.check_output(["buildflow", "build"])
            except subprocess.CalledProcessError as e:
                print("Build failed with exit code: ", e.returncode)
                raise typer.Exit(1)
            progress.advance(build_task)
            progress.remove_task(build_task)
            progress.console.print("[green]✓[/green] Build complete")
            build_file = "./.buildflow/build/build.flow"
        if not os.path.exists(build_file):
            raise ValueError(f"Build file {build_file} does not exist.")

        with zipfile.ZipFile(build_file, "r") as zip_ref:
            flowstate_str = zip_ref.open("flowstate.yaml")
            flowstate = yaml.safe_load(flowstate_str)
            python_version = flowstate["python_version"]
            ray_version = flowstate["ray_version"]

        submit_task = progress.add_task(
            "[cyan]Sending update deployment...", total=None
        )
        try:
            deployment_id = remote_utils.send_update_environment_request(
                server_address=launchflow_server_address,
                project_id=project_id,
                environment=environment,
                build_file=build_file,
                bearer_token=dkey,
                python_version=python_version,
                ray_version=ray_version,
            )
        except Exception as e:
            progress.advance(submit_task)
            progress.remove_task(submit_task)
            progress.console.print(f"[red]✗[/red] Sending update failed: {e}")
            raise typer.Exit(1)
        progress.advance(submit_task)
        progress.remove_task(submit_task)
        progress.console.print("[green]✓[/green] Update deployment launched")
        progress.console.print()

        if blocking:
            remote_utils.poll_deployment_info(
                deployment_id=deployment_id,
                server_address=launchflow_server_address,
                progress=progress,
                bearer_token=dkey,
            )
        progress.console.print()
        _print_deployment_info(progress, deployment_id)


@app.command(
    help="Promote the running code from one environment to another. "
    "If an deployment is already running in the environment it will be updated."
)
def promote_environment(
    project_id: Optional[str] = typer.Option(None, help=PROJECT_FILE_HEP),
    from_environment: Optional[str] = typer.Option(
        ...,
        "--from",
        "--from-environment",
        "-f",
        help="The environment to promote from.",
    ),
    to_environment: Optional[str] = typer.Option(
        ...,
        "--to",
        "--to-environment",
        "-t",
        help="The environment to promote to.",
    ),
    dkey: Optional[str] = typer.Option(
        ...,
        help="The deployment key to use when deploying to an environment. "
        "This should be the key for the environment you are promoting to.",
    ),
    blocking: Optional[bool] = typer.Option(
        True,
        help="Whether or not the command should block until the deployment is running.",
    ),  # noqa
    launchflow_server_address: str = constants.LAUNCHFLOW_SERVER_ADDRESS_OPTION,
):
    launchflow_server_address = get_server_address(launchflow_server_address)
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
    ) as progress:
        project_id = get_project_id(project_id)
        if not project_id:
            typer.echo(
                "No project id provided and no default project set. "
                "Please set a default project or provide a project id."
            )
            raise typer.Exit(1)
        submit_task = progress.add_task(
            "[cyan]Sending update deployment...", total=None
        )
        try:
            deployment_id = remote_utils.send_promote_environment_request(
                server_address=launchflow_server_address,
                project_id=project_id,
                from_environment=from_environment,
                to_environment=to_environment,
                bearer_token=dkey,
            )
        except Exception as e:
            progress.advance(submit_task)
            progress.remove_task(submit_task)
            progress.console.print(f"[red]✗[/red] Sending promote failed: {e}")
            raise typer.Exit(1)
        progress.advance(submit_task)
        progress.remove_task(submit_task)
        progress.console.print(
            f"[green]✓[/green] Deployment in {to_environment} launched"
        )
        progress.console.print()
        if blocking:
            remote_utils.poll_deployment_info(
                deployment_id=deployment_id,
                server_address=launchflow_server_address,
                progress=progress,
                bearer_token=dkey,
            )
        progress.console.print()
        _print_deployment_info(progress, deployment_id)


@app.command(help="Ping info for a list of deployments.")
def ping(
    deployment_ids: List[str] = typer.Argument(
        ..., help="The deployment ids to fetch info for."
    ),
    launchflow_server_address: str = constants.LAUNCHFLOW_SERVER_ADDRESS_OPTION,
    bearer_token: str = constants.BEARER_TOKEN_OPTION,
):
    launchflow_server_address = get_server_address(launchflow_server_address)
    remote_utils.ping_deployment_info(
        deployment_ids, launchflow_server_address, bearer_token
    )


@app.command(help="Stop a running deployment.")
def stop(
    deployment_id: str = typer.Argument(..., help="The deployment id to stop."),
    launchflow_server_address: str = constants.LAUNCHFLOW_SERVER_ADDRESS_OPTION,
    bearer_token: str = constants.BEARER_TOKEN_OPTION,
):
    launchflow_server_address = get_server_address(launchflow_server_address)
    remote_utils.stop_deployment_cli(
        deployment_id, launchflow_server_address, bearer_token
    )


@app.command(help="Drain a running deployment.")
def drain(
    deployment_id: str = typer.Argument(..., help="The deployment id to drain."),
    launchflow_server_address: str = constants.LAUNCHFLOW_SERVER_ADDRESS_OPTION,
    bearer_token: str = constants.BEARER_TOKEN_OPTION,
):
    launchflow_server_address = get_server_address(launchflow_server_address)
    remote_utils.drain_deployment_cli(
        deployment_id, launchflow_server_address, bearer_token
    )


@app.command(help="Attach to a deployment.", hidden=True)
def attach(
    deployment_id: str = typer.Argument(..., help="The deployment id to attach to."),
    launchflow_server_address: str = constants.LAUNCHFLOW_SERVER_ADDRESS_OPTION,
):
    launchflow_server_address = get_server_address(launchflow_server_address)
    aiorun(remote_utils.run_console_ui(deployment_id, launchflow_server_address))


@app.command(help="List deployments for an account.")
def list(
    account_id: Optional[str] = constants.ACCOUNT_OPTION,
    projects: List[str] = typer.Option([], help="The project to list deployments for."),
    active: bool = typer.Option(
        False,
        "--active",
        "-a",
        help="If --active is set only active deployments will be returned.",
    ),
    launchflow_server_address: str = constants.LAUNCHFLOW_SERVER_ADDRESS_OPTION,
):
    launchflow_server_address = get_server_address(launchflow_server_address)
    account_id = utils.get_account_id(account_id)
    access_token = cache.get_access_token(launchflow_server_address)
    response = deployments_helper.list_deployments(
        account_id=account_id,
        active=active,
        access_token=access_token,
        launchflow_server_address=launchflow_server_address,
        projects=projects,
    )

    utils.print_response("Deployments", response)


@app.command(help="Get logs for a deployment.")
def logs(
    deployment_id: str = typer.Argument(..., help="The deployment id to get logs for."),
    start_timestamp: Optional[datetime] = typer.Option(
        default=None, help="Look up logs from after this timestamp."
    ),
    end_timestamp: Optional[datetime] = typer.Option(
        default=None, help="Look up logs from before this timestamp."
    ),
    page_token: Optional[str] = typer.Option(
        None,
        help="The page token to use to continue reading logs. This will be printed out if we were unable to return all logs.",  # noqa: E501
    ),
    bearer_token: str = constants.BEARER_TOKEN_OPTION,
    launchflow_server_address: str = constants.LAUNCHFLOW_SERVER_ADDRESS_OPTION,
):
    launchflow_server_address = get_server_address(launchflow_server_address)
    remote_utils.get_logs(
        deployment_id,
        launchflow_server_address,
        start_timestamp,
        end_timestamp,
        page_token,
        bearer_token,
    )


if __name__ == "__main__":
    app()
