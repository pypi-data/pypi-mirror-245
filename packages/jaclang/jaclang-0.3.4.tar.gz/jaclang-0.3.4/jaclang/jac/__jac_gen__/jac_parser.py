# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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ugRdhvqhK9BV6Bp0HboBVUn5HT9UWbxMj+gZ4jVbicl7JabrlcmJ6Eef1YkoNf/o045Tw+5ueoq6NxPdkXdqfUdMREnMl3BILJBwSiyUWCThklgsUSGxRKJSokqiWqJGokiiTKJWIkeiTqJewi1hlCiQaJDwSMyTyJSYKzFKIl/iSYlhEk9JZEk8LZEnMVnCLDFC4hmJZyUaJZokvBKTJGZIjJVolmiRmC3hk5giMVPiOYkJEksllkm0SiyXeF7iBYlciRclZkmUSrwk8bJEm0S7xDSJ4RLZEn6JFRLjJMZLvCLxqkSHRLnEVImREq9JTJR4XeINCZOERSJDolNipcQciUKJMRJvCvgd/0cW33fQv7mD/s0d9G/uoH9zB/2bO+jf3EH/5g76N3fQv7mD/s0d9G/uoH9zB/2bO+jf3EH/5g76N3fQv0kqBzJB2VA91A3lQdshI2SGCqAGaAe0E/JAu6Dd0B5oL7QPWgPthw5AbdB6qB3Kgg5CGuSHDkEd0GGoHGqColAMOgIFoKPQMagZaoGOQyegk1AndAo6DS2DzkBnoXNQENoAbYQaoRDkg8LQFqgV2gqthezQamgdtArqgjZBm6EeqBc6D/VBF6CL0CXoMtQPXYGuQteg69ANKb/jnz+RW1A++3eefGrXYT6+0+TTuNNE3RY0KnDv0k6109QUeFTvPPkXWS5FUS5FUS5FUS5FUS5FUS5FUS5FUS5FUS5FUS5FUS5FUS5FUS5FUS5FUS5FUS5FUS5FUS5FUSBFUSBFUSBFUSBFUSBFUSBFUSBFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURJFURIlNQ/KhOZCo6BZ0DQoBxoOjYPGQysgMzQZGgFNgqZCY6EZ0EhoIjQbmgLNhCxQBjQBmgMVQmOk/I4ff5KfKPBRbgxSn0YwQv17j1pl+lN4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10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10FF10Ep10Ep10EN10EN10Hx1kHx1kHx1kHV1kEl2EHt10G110Fh1zFS0f0D4jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmyN+c8RvjvjNEb854jdH/OaI3xzxmxuJ3/+L+E1TKaSpFNJUCmkqhTSVQppKIU2lkKZSSFMppKkU0lQKaSqFNJVCmkohTaWQplJIUymkqRTSVAppKoU0lUKaSiFNpZCmUkhTKaSpFNJUCmkqhTSVQppKIU2lkKZSSFMppKkU0lQKaSqFNJVCmkohTaWQplJIUymkqRTSVAppKoU0lUKaSiFNpZCmUkhTKaSpFNJUCmkqhTSVQppKIU2lkKZSSFMppKkU0lQKaSqFNJVCmkohTaWQplJIUymkqRTSVAppKoU0lUKaSiFNpZCmUkhTKaSpFNJUCmkqhTSVQppKIU2lkKZSSFMppKkU0lQKaSqFNJVCmkohTaWQplJIUymkqRTSVAppKoU0lUKaSiFNpZCmUkiPVAr/d2L0zdy7uCrwRW5H/LnhF23cvPT9uS/xC92P+EvMFn/IYv0PWayPqIB60Dq0EZ2HOtFmtBu1oi2oBd2IulERrUHr0Qa0Ca1A2ahq4ZcT8VaCrRy+W0cG0T+sf0nhb9S3qjUl++8rdDdu4Rp+1f07wy866/vY1tQ/9ev1V4X6qz+vD45/P/zi79V/fL87/GKo/uJI/WJgS/hJDTCvDzArDTArDTArDTArDTArDTB3DzBHDTBHDTBbDzBjDTBjDTBjDTBjDTBjDTAHDzB/DTB/DTB/DTA/DzCbDbDCGWBuG2BuG2BuG2BuG2BuG2BuG2BuG2C9M8B6Z4B5b4B5b4A1zQCz4ACz4ACz4ACz4ACz4ACz4ACz4ACz4ACz4Ii+ii5HV6Bz0ZWoB01CV6ElaDnaiDrR1egatAdtRntRDrWiiWgC2oKqaB+aiWaha1Ev2o+60Sq0EE1B16EM2oSuRzegJJqPmtAB1IeWoQUojbJR1cKvJA6M3Fe8IlHf3fz/MI+dYB47wTx2gvnhBDPCCWa1ExRSJ5jjTlBInWDuOEE9dYLa5wRl1QnmlRPMjSeork4wH51g3jxBXTSiCWgLuhdNR/ehFpRFRXQ/egBtRQ+iAfQQehg9gm5Gj6LH0B50C9qLxqPH0ROoimpoPxpEq1AJPYmeQk+jfnQCPYPKaCd6Fj2HnkcH0AvoRbQLvYReRq+gI+gouhVtR7ejCjqG7kK70XF0CK1GB9FhdBO6Dd2B7kSvotfQ6+gN9CZ6C72N3rk/0ZRoqv/Hp99FJ9F76H30AfoQrUTN6Gw0DS1BOdSKJqKZaBbah6aiuWgymoMWohloEZqCMmgpmocWo/nIn9hstAwtQOmoauEfJeLsOLPxJZejrWglakZno2loEmpDS9BytBF1ohTai8ajHGpFE9EEVEUz0XTUgmahfWgqmosmo/1oFSqhOWghmoEWoSmojDJoJ1qBlqIkmocWo/moCR1As1EfWoYWoDTKRlULv8rQP7exlOxCedSNiqiA1qAetA6tRxvQRnQe2oQ60Qq0GbWiLSiLWtBudGNUtfD/JuKzsh/hW/cIjcMjNA6P0Dg8QuPwCI3DI3zrHqFxeITG4RG+WY/QOIzoCLoIjUcXo+moBf0OmoumosmoiLahNegStB2V0A40By1CM9B6tAGV0U60Ai1FFTQPLUaXotnoMrQL7UZfRZej30VXoHPRlagHTUJXoSVoOdqIOtHV6Bq0B21Ge1EOtaKJaALagqpoH5qJZqFrUS/aj7rRKrQQTUHXoQzahK5HN6Akmo+a0AHUh5ahBSiNslHVwj+Oc073O2HKGUE+ojtiTUQh4pyIcyN6ItZGrItYH7EhYmPEeRGbIjojVkRsjmiNOD9iS8QFES0R2YhiQLXwTxrf2LH6u96MDyY++e4WasxKNWalGrNSjVmpxqxUY1aqMSvVmJVqzEo1ZqUas1KNeajGPFRjHqoxD9WYh2rMPDVmnhozT42Zp8bMU2PmqTHz1Jh5asw8NWaeGjNPjZmnxsxTY+apMfPUmHlqzDw1Zp4aM0+NmafGzFNj5qkx89SYeWrMPDVmnhozT42Zp8bMU2OuqTHX1Jhrasw1NeaaGnNNjbmmxlxTY66pMdfUmGtqzDU15poac02NuabGXFNjrqkx19SYa2rMNTXmmhpzTY25psZcU2OuqTHX1Jhrasw1NeaaGnNNjbmmxlxTY66pMdfUmGtqzDU15poac02NuabGXFNjrqkx19SYa2rMNTXmmtrIXPNP41xTuKs5TDYfK4+60RrUgyahdagNbUDL0d3oHrQCdaIU2oQ2oySagLage9F0dB9qQVlURPejB9BW9CAaQA+hh9Ej6Gb0KHoM7UG3oL1oPHocPYGqqIb2o0G0CpXQk+gp9DTqRyfQM6iMdqJn0XPoeXQAvYBeRLvQS+hl9Ao6go6iW9F2dDuqoGPoLrQbHUeH0Gp0EB1GN6Hb0B3oTrQRvYneQx+it9C76FX0GnoDvY3eQSfR++h19EFUtfBriU99G8UzboH+PI82rN86n65/zffsfRVH747/Qg9BHL31evQ2+R/BZyH+KL3f4re4JXz0rvHv/rGJn+uW8X/WGMv14fj36/+C+qX2/fUXvz384uqWRgY1FX6l8aX/vPGlfzD8u9eGP/8fhj8+PvzxD4c//uzHw7Qw/PE/DX9s+XhY9o9807uPxlE4/Gd1Lxj+eHr444Ywnv9o+ONPDH/8+vDHuSODtPtnwjdkbPQOD5jui4c//vHwx66Pv6nPDX/8z8Mfxw9//JPhjyuGP/6X4Y9/aWQUdW8cOS67/1b9H/IvEl/46TJjD6s4831Qv5dPq/junlJxxjH2HTyl4js7WMYOiTMOhdER/9mPovjm8Tyae9/8xNjv5RMmRh8oUX+WRqL+z/4WT5b4vj9R4ts+SOJzpMX3+EES//LTZ7ix4+I7mup+ZGa4+kGX/HKq6/8xm+p+PRH27nb/Sjh5aqBa+I14kt39djjHHkE+ojtiTUQh4pyIcyN6ItZGrItYH7EhYmPEeRGbIjojVkRsjmiNOD9iS8QFES0R2YhiQLXwrxI8/6Sxpr4cbUUrUTM6G01Dk1AbWoKWo42oE6XQXjQe5VArmogmoCqaiaajFjQL7UNT0Vw0Ge1Hq1AJzUEL0Qy0CE1BZZRBO9EKtBQl0Ty0GM1HTegAmo360DK0AKVRNqpa+BpDv42h38bQb2PotzH02xj6bQz9NoZ+G0O/jaHfxtBvY+i3MfTbGPptDP02hn4bQ7+Nod/G0G9j6Lcx9NsY+m0M/TaGfhtDv42h38bQb2PotzH02xj6bQz9NoZ+G0O/jaHfxtBvY+i3MfTbGPptDP02hn4bQ7+Nod/G0G9j6Lcx9NsY+m0M/TaGfhtDv42h38bQb2PotzH02xj6bSND/zcTX+SxgReyjPwW51ujTwmsr0Hf6v9uzr/+7fCLHSwSx1avn/nYwLGV4JlnZt/RYwPrz9b89f7PPjH7Fneaja36Ps/jA1cPv1j8A3yO4OjzA0eXbqPPETw1/PGW/vsK59RvfLqx/rf/dk8W/AE/8fPQ8IuD8YmC9YXtUP8XPA8cW6qPLd6/mycL/sWdCH6d6evZxmHehfKoG61BPWgSWofa0Aa0HN2N7kErUCdKoU1oM0qiCWgLuhdNR/ehFpRFRXQ/egBtRQ+iAfQQehg9gm5Gj6LH0B50C9qLxqPH0ROoimpoPxpEq1AJPYmeQk+jfnQCPYPKaCd6Fj2HnkcH0AvoRbQLvYReRq+gI+gouhVtR7ejCjqG7kK70XF0CK1GB9FhdBO6Dd2B7kSvotfQ6+gN9CZ6C72N3kHvopPoPfQ++gB9iFaiZnQ2moaWoBxqRRPRTDQL7UNT0Vw0Gc1BC9EMtAhNQRm0FM1Di9F81IRmo2VoAUpHVQu/lYh7pIfYjTbEbrQhdqMNsRttiN1oQ+xGG2I32hC70YbYjTbEbrQhdqMNsRttiN1oQ+xGG2I32hC70YbYjTbEbrQhdqMNsRttiN1oQ+xGG2I32hC70YbYjTbEbrQhdqMNsRttiN1oQ+xGG2I32hC70YbYjTbEbrQhdqMNsRttiN1oQ+xGG2I32hC70YbYjTbEbrQhdqMNsRttiN1oQ+xGG2I32hC70YbYjTbEbrQhdqMNsRttiN1oQ+xGG2I32hC70YbYjTbEbrQhdqMNsRttiN1oQ+xGG2I32hC70YbYjTbEbrQhdqMNsRttiN1oQ+xGG2I32hC70YbYjTbEbrQhdqMNsRttiN1oQ+xGG2I32hC70YbYjTbEbrQhdqMNsRttiN1oQ+xGG2I32hC70YbYjTbEbrShkd1o/zoRm/R/FH7CDVQLv934grEz7tErth9fgR07VR+9clu/5PtGYyg0df+T4Y+/NfxxZv+Zl36rhX+TGLkfvPvf1G8H/6iu0UR7tB7Oewq/0/ijz3iOynf0LJdv//CVM8/mPvtxLKNncWPn/mPnq/VTzNf7PzmtqxZ+N3HGZfn6+4w3rsZvqf9m9evzt7TUv/TfNr509D3D/kP9h3E4oFo41fiCsVPTCcMvfpGyY/R8ul4NPM/5/tjp5b3DL04n+kfO0rlq9s+GP7Fj+OOvDX9iY/0T9wy/2FV/UT+Rv3H44z8f/nigv34O1NT9p/2fnICOnjVXC78Xx9PwSWmcUFcSuiM6FFUt/LvGL398+Ldd2F8/ZWoq/N36P3T0HOH3iaAR3YK2ovFoAJVQP3oR7UIn0EvoZpRHFXQIHUFH0Wq0BR1Eh9Gt6Ca0Hd2Gbkd3oLvQnegY2o2OR1WHP8QqYl3jS7pQHnWjIiqgNagHrUPr0Qa0EZ2HNqFOtAJtRq1oC8qiFrQb3RhVLfz70Qz9ej0v/6Dxba2/T/y1H7erhdaPD/TCmnrk/IvhF/n6i385/GJJ/cWvD7/4uUQ4UpZyhC0d+WP+Awd1a0v8ezVULfxh40tGO44/a/wuD6Ct6EE0gB5GN6PH0B50CxqPHkdPoCqqoSIaRKtQCT2Jnkb96AR6Dj2PDqAX0ItoF3oJvYxeQXl0CB1BR9FqtAUdRLeiw+gmtB3dhm5Hd6AKuhMdQ3eh3eh4VLXwHxvD++Hho+VfNDe+h02FI82Nb19T4ZmWxqhpKrzY0vixNBVeqT8P7K/Xa/GfSDSOg6bCUy2NH25T4a6WxihuKhxtaRwGTYU3WxojpKnwbmMR8J8af9T2Yf92S//Ik+b+v0T/yDtaflT/zJ8Pv/jjRDgyLqOxuWzkzPZ04i9k8VR/Zt5f+65XUZ+snv4o8XmvPNUvAb1Q/0z9EtQb/BN/XN9Q7ttdcfoxecOqjy80/bC/sdx3dHXpe/u+VX9R71c1NlXsGQmfP66vS3YP/887WuoLkz9pHMSjX/M2lyfepsJ+mzL47ZHf7T+zXNzNcnE389Zulou7WRLuZkk4okloHWpDG9BydDe6B61AnSiFNqHNKIkmoC3oXjQd3YdaUBYV0f3oAbQVPYgG0EPoYfQIuhk9ih5De9AtaC8ajx5HT6AqqqH9aBCtQiX0JHoKPY360Qn0DCqjnehZ9Bx6Hh1AL6AX0S70EnoZvYKOoKPoVrQd3Y4q6Bi6C+1Gx9EhtBodRIfRTeg2dAe6E72KXkOvozfQm+gt9DZ6B72LTqL30PvoA/Qh2hhVLfyXRhiPNU/1c8vfrL+ol0ZDiUYaNhVOJRr/pKbCv/rUdqpeQf1O/RO/P/yJrzS+T03dq/tHeqXbG/+Opu4H+0fecvSpxneuqfsX+sOi4sPhT6zrD0ur1cOf+Jf9nzRVvzn8P5L1/1GvrF5pfLuHF6b1T5w5B58c/pJfanxnmwpbP+69uv+k8W1pKkxPNH4Cw1NwovHtbiq8xzz65vCLryUa39GmwlVx3qyvmv7Bx71a4VdbGj+CpsKcRk32p6MT5NcaE+SffTxBNnVf0ci/4Zm/cS7w565+x+bq+mLh/PrveMbifWzJN7bAG1u5jK01x5Z8o1P+2OJzbO4fW3zUVzm/8em75M9Y4Y+tVMfWB6Prq+rwKcz38kadH95V+1/cjTs/6NX6Z20L+yFfpf/gV+f1t0nO1r/ih+iuoP86mj+/2lzPn//GCnsmK+yZrLBnssKeyQp7RAV0DjoX9aC1aB1ajzagjeg8tAl1ohVoM2pF56Mt6ALUgrKoiLailagZnY2moTZ0IUqhi9B4dDGajuaiqWgy2oYuQdtRCe1Ac9AiNAOV0U60FFXQPLQYXYpmo8vQLrQbXY6uQFeiSegqtAQtR1eja9AetBfl0EQ0AVXRPjQTzULXol60H61CC9EUdB3KoOvRDSiJ5qMmdAD1oWVoAUqjG6Oqhf9OqB5vjqE6ojzqRmtQD5qE1qE2tAEtR3eje9AK1IlSaBPajJJoAtqC7kXT0X2oBWVREd2PHkBb0YNoAD2EHkaPoJvRo+gxtAfdgvai8ehx9ASqohrajwbRKlRCT6Kn0NOoH51Az6Ay2omeRc+h59EB9AJ6Ee1CL6GX0SvoCDqKbkXb0e2ogo6hu9BudBwdQqvRQXQY3YRuQ3egO9FG9CZ6D32I3kLvolfRa+gN9DZ6B51E76PX0QdR1cI3COMyYVwmjMuEcZkwLhPGZcK4TBiXCeMyYVwmjMuEcZkwLhPGZcK4TBiXCeMyYVwmjMuEcZkwLhPGZcK4TBiXCeMyYVwmjMuEcZkwLhPGZcK4TBiXCeMyYVwmjMuEcZkwLhPGZcK4TBiXCeMyYVwmjMuEcZkwLhPGZcK4TBiXCeMyYVwmjMuEcZkwLhPGZcK4TBiXCeMyYVwmjMuEcZkwLhPGZcK4TBiXCeMyYVwmjMuEcZkwLhPGZcK4TBiXCeMyYVwmjMuEcZkwLhPGZcK4TBiXCeMyYVwmjMuEcZkwLhPGZYKzTHCWibwyMVomtstEc5mILROxZWK7TOCWCf8y8VsmcMtMDOWR+P0fxO9PtMTDfkQrUTM6G01Dk1AbWoKWo42oE6XQXjQe5VArmogmoCqaiaajFjQL7UNT0Vw0Ge1Hq1AJzUEL0Qy0CE1BZZRBO9EKtBQl0Ty0GM1HTegAmo360DK0AKVRNqpaaGo+UI+CpsLsRrmfaK6P/dGg/8NEnA5H9ADaimroQTSASuhp1I8eRifQzegxtAfdgp5D49Hj6AX0ItqFXkIvo1dQHh1CFXQE7UZH0Wq0BR1Eh9Gt6Ca0Hd2Gbkd3oLvQnegYOh5VLTQ3Bt+9wwfBhOH/+WfDg7J1tM/+75+6+2vsmsMX2SH/yXWeluYY9EmCPknQJwn6JEGfJOiTBH2SoE8S9EmCPknQJwn6JEGfJOiTBH2SoE8S9EmCPknQJwn6JEGfJOiTBH2SoE8S9EmCPknQJwn6JEGfJOiTBH2SoE8S9EmCPknQJwn6JEGfJOiTBH2SoE8S9EmCPknQJwn6JEGfJOiTBH2SoE8S9EmCPknQJwn6JEGfHAn6ZGOwPzM8+K9pDqHexDlOE+c4TZzjNHGO08Q5ThPnOE2c4zRxjtPEOU4T5zhNnOM0cY7TxDlOE+c4TZzjNHGO08Q5ThPnOE2c4zRxJtjEGU8TZzxNnPE0ccbTxBlPE2c8TZzxNHHG08Q5ThPnOE2c1TRxVtPEWU0TZzVNnNU0cVbTxFlNE2c1TZzVjCiPDqEj6Chajbagg+hWdBjdhLaj29Dt6A5UQXeiY+gutBsdj6oWfqJxXI1+ycnGl1wWVS2Maz7jrqqF9WOwfjPVysYWi/HMRN2NybEL5VE3KqICWoN60Dq0Hm1AG9F5aBPqRCvQZtSKtqAsakG70Y1R1UKqOd7a8Q1WrN9gxfoN1qjfYI36DVae32Ct+Q3Wmt9grfkN1prf4KLWN1hrfoO15oieQFVUQ0U0iFahEnoSPY360Qn0HHoeHUAvoBfRLvQSehm9gvLoEDqCdqOjaDXagg6iW9FhdBPajm5Dt6M7UAXdhe5Ex9DxqGrhK6TGpaTGpXzrLiU1LiUZLiUZRjQJrUNtaANaju5G96AVqBOl0Ca0GSXRBLQF3Yumo/tQC8qiIrofPYC2ogfRAHoIPYweQTejR9FjaA+6Be1F49Hj6AlURTW0Hw2iVaiEnkRPoadRPzqBnkFltBM9i55Dz6MD6AX0ItqFXkIvo1fQEXQU3Yq2o9tRBR1Dd6Hd6Dg6hFajg+gwugndhu5Ad6JX0WvodfQGehO9hd5G76B30Un0HnoffYA+RBujqoUJzfG+08OcyhweWQeeVf+Swvz6vXZPJPpHbpe7L9E/ckPd7SN3tjYVFo+uEf/28GcKC+tf/U5jH1xr88c30P7NelM38eNF5cif8EsExC8RAr/EAfRLI3/dSRR9p/gFp0iNU+TZKVLjFHl2iiP8FH/sKY6cUxw5pzimT3EcneIfdopZ7RRHwClG8imOsVMcY6cY5aeYLU4x5k8x5k9xbJ7iCDjFkXqK4+EUx+0pjo5THKmnOFZOcUyf4ig+xVF8auSHOpkf6mkmqdNMUqf5oZ5mkjrND/U0P9TTRPNpfsSnmcBO80M9zY/xNFPWaQbfaQbfaYL6NIPvNFPWaSap04T4acL4NJF+moF5moF5mqF4monvNJF+moF5msF3msF3mkF0mmFzmoFymuF9msFwmmFzmqFxmqFxmsPiNEP/NEP/NEP/NEP/NIP9NMP7NAP6NEP49MjAnPLp5VOC8ilB+ZSgfEpQPiUonxKUTwnKpwTlU4LyKUH5lCCxE5RPCcqnBOVTgvIpQfmUoHxKUD4lKJ8SlE8JyqcE5VOC8ilB+ZSgfEpQPiUonxKUTwnKpwTlU4LyKUH5lKB8SlA+JSifEpRPCcqnBOVTgvIpQfmUoHxKUD4lKJ8SlE8JyqcE5VOC8ilB+ZSgfEpQPiUonxKUTwnKpwTlU4LyKUH5lKB8SlA+JSifEiMrip9s/s7vVPmV4Re/wB3n35f3lvnyVpVvfavKN99Q/uUtKZ91w/hf/J0oU1njf400+trIETmNTubexpd0ojVoHWpBWbQCjTY0DzEZjWgjqkRVC1/lL/hTjdm6C+VRN1qDCugcdC7qQWvROrQebUAb0XloE+pEK9Bm1IrOR1vQBagFZVERbUUrUTM6G01DbehClEIXofHoYjQdzUVT0WS0DV2CtqMS2oHmoEVoBiqjnWgpqqB5aDG6FM1Gl6FdaDe6HF2BrkST0FVoCVqOrkbXoD1oL8qhiWgCqqJ9aCaaha5FvWg/WoUWoinoOpRB16MbUBLNR03oAOpDy9AClEY3RlUL07+LddiP6R3DB4c//nb/j9xy7Mf2zuH685f+U///VMu1tuZPf8Zg/dGCnc394WGD9WcMjvv8zxhMc5V5HC3GOFqMcbQY42gxxtFijKPFGEeLMY4WYxwtxjhajHG0GONoMcbRYoxj4TiOFmMcLcY4WoxxtBjjaDHG0WKMo8UYR4sxjhZjHC3GOFqMcbQY42gxxtFijOgZVEY70XPoeXQAvYBeRLvQS+hl9ArKo0PoCNqNjqLVaAs6iG5Fh9FNaDu6Dd2O7kAVdBe6Ex1Dx6Oqhf/ly7n0m+fSL+fQH4459Mds7qw/7KPy7SbRGfWrjvV3p3q1cYPATOqDHdQHO6gPdlAf7KA+2EEpsIMTpB2UAjs4+d1BKbCD06UR3Y3uQStQJ0qhTWgzSqIJaAu6F01H96EWlEVFdD96AG1FD6IB9BB6GD2CbkaPosfQHnQL2ovGo8fRE6iKamg/GkSrUAk9iZ5CT6N+dAI9g8poJ3oWPYeeRwfQC+hFtAu9hF5Gr6Aj6Ci6FW1Ht6MKOobuQrvRcXQIrUYH0WF0E7oN3YHuRK+i19Dr6A30JnoLvY3eQe+ik+g99D76AH2INkZVC7MI459ujmH806wyR9SDJqF1qA0tR/egTpRCm9EEtAVNRy2oiLrRGrQB3Y1WoE0oie5F96Esuh89gLaiB9EAegg9jB5BN6NH0WNoD7oF7UXj0ePoCVRFNbQfDaJVqISeRE+hp1E/OoGeQWW0Ez2LnkPPowPoBfQi2oVeQi+jV9ARdBTdiraj21EFHUN3od3oODqEVqOD6DC6Cd2G7kB3olfRa+gN9CZ6G72DTqL30PvoQ/Q6egu9iz6IqhZmN8c3ZPs7rH7/DiuyEa1EzehsNA2tQ23oQnQeSqGL0Hh0MZqOWtBcNBVNRkW0Da1Bl6DtqIR2oDloEZqB1qMNqIx2ohVoKaqgeWgxuhTNRpehXWg3+iq6HF2BzkVXoh40CV2FlqDlaCPqRFeja9AetBntRTnUiiaiCWgLqqJ9aCaaha5FvWg/6kar0EI0BV2HMmgTuh7dgJJoPmpCB1AfWoYWoDTKRlULf2nsxrb6puWRvcq5xg1tmbgy7f56/dd2ReQjuiPWRBQizok4N6InYm3Euoj1ERsiNkacF7EpojNiRcTmiNaI8yO2RFwQ0RKRjShGbI1YGdEccXbEtIi2iAsjUhEXRYyPuDhiesTciKkRkyO2RVwSsT2iFLEjYk7EoogZEeWInRFLIyoR8yIWR1waMTvisohdEbsjLo+4IuLKiEkRV0UsiVgecXXENRF7IvZG5CImRkyIqEbsi5gZMSvi2ojeiP0RqyIWRkyJuC4iE3F9xA0RyYj5EU0RByL6IpZFLIhIR9wYUC3M4Wz8J5vDT/1jbUUrUTM6G01Dk1AbWoKWo42oE6XQXjQe5VArmogmoCqaiaajFjQL7UNT0Vw0Ge1Hq1AJzUEL0Qy0CE1BZZRBO9EKtBQl0Ty0GM1HTegAmo360DK0AKVRNqpa+MvNX77RQv93+UYLY23SWbRJZ5EcZ9EmnUWbdBZt0lm0SWfRJp1Ff3QW/dFZ9Edn0R+dRTqcRWN0Fo3RWRzzZ9EYncUReRaN0YiKaBUqoSfRU+hpdAI9g8poJ3oWPYeeRwfQC+hFtAu9hF5Gr0RVC3+lfjFuwfBQerd+Le6vcgvgz9LU/yznWz87sl7Psn+5l26pl45oRFuiqoW5THCbG39CF8qjblREBbQG9aB1aD3agDai89Am1IlWoM2oFW1BWdSCdqMbo6qFn2p8I+v3eObrUVB/D5WHGxdb22mUevme9tIo9dIo9dIo9dIo9dIo9fI97aVR6qVR6uW72Euj1Euj1Euj1Euj1Euj1Mt3qpdGqZdGqZdGqZcR1Euj1MsI6qVR6qVR6qVR6qVR6qVR6qVR6qVR6mUc9jIOe2mUemmUehlrvTRKvTRKvTRKvTRKvTRKvTRKvTRKvTRKvYzKXhqlXhqlXhqlXhqlXhqlXo7WXhqlXhqlXhqlXhqlXo7dXo7PXhqlXhqlXhKul2O3l0apl0apl+O6l0apl0apl2O+l0apl0apl0apl0apl0apl0apl0apl9TspVHqpVHqpVHqpVHqpVHqJf16aZR6aZR6aZR6aZR6aZR6aZR6aZR6aZR6aZR6aZR6ydDekWT8a0wxP9Mcp5gR5VEPmoTWoTa0HN2DOlEKbUYT0BY0HbWgIupGa9AGdDdagTahJLoX3Yey6H70ANqKHkQD6CH0MHoE3YweRY+hPegWtBeNR4+jJ1AV1dB+NIhWoRJ6Ej2Fnkb96AR6BpXRTvQseg49jw6gF9CLaBd6Cb2MXkFH0FF0K9qObkcVdAzdhXaj4+gQWo0OosPoJnQbugPdiV5Fr6E30JvobfQOOoneQ++jD9Hr6C30Lvogqlr465xR/DxnFD/PfPvzI3k9j7wukdcl8rpE1pXIuhJZXiLLS2R5iSwvkZElkr1EYpbI+RL5WSL1S6R+iWwtMQeUSNoSM0KJGaFECpeYH0pkconZokRCl5g7SuR1ibwukdcl8rpEXpfI6xJ5XSKvS+R1ibwukdcl8rpEXpfI6xJ5XSKvS+R1ibwukdcl8rpEXpfI6xJ5XSKvS+R1ibwukdcl8rpEXpfI6xJ5XSKvS+R1ibwukdcl8rpEXpfI6xJ5XSKvS+R1ibwukdcl8rpEXpfI6xJ5XSKvS+R1ibwukdcl8rpEXpfI6xJ5XSKvS+R1ibwukdcl8rpEXpfIzxLpXSK9S2RriSwvkeUlcrdEspdI9hLJXiKhS+R8aSSv5xO/XcRvF/HbRfx2Eb9dxG8X8dtF/HYRv13Ebxfx20X8dhG/XcRvF/HbRfx2Eb9dxG8X8dtF/HYRv13Ebxfx20X8dhG/XcRvF/HbRfx2Eb9dxG8X8dtF/HYRv13Ebxfx20X8dhG/XcRvF/HbRfx2Eb9dxG8X8dtF/HYRv13Ebxfx20X8dhG/XcRvF/HbRfx2Eb9dxG8X8dtF/HYRv13Ebxfx20X8dhG/XcRvF/HbRfx2Eb9dxG8X8dtF/HYRv13Ebxfx20X8dhG/XcRvF/HbRfx2Eb9dxG8X8dtF/HYRv13Ebxfx20X8dhG/XcRvF/HbRfx2Eb9dxG8X8dtF/HYRv13Ebxfx20X8dhG/XcRvF/HbRfx2jcTv3yB+7yPI7iNi7yNG7yNm7iNm7iMc7+MQfXDkj13AH1sh9SukfoXUr/BXqpD6FVK/wl+3QupXSP0KqV8h9SukfoV/WIVvVoXUr5D6FVK/QupXSP0KqV8h9SukfoXUr/DjqPDjqJD6FVK/QupXSP0KqV8h9SukfoXUr5D6FVK/QupXSP0KqV8h9SukfoUhVSH1K6R+hdSvkPoVUr9C6ldI/QqpXyH1K6R+hdSvkPoVUr9C6ldI/QqpXyH1K6R+hdSvkPoVUr9C6ldI/QqpXyH1K6R+hdSvkPoVUr9C6ldI/QqpXyH1K6R+hdSvkPoVUr9C6ldI/QqpXyH1K6R+hdSvkPoVUr9C6ldI/QqpXyH1K6R+hdSvkPoVUr9C6ldI/QqpXyH1K6R+ZSR+FxK/c7kMOpdLdnMp9OdyoWoul0FHdA46F/WgtWgdWo82oI3oPLQJdaIVaDNqReejLegC1IKyqIi2opWoGZ2NpqE2dCFKoYvQeHQxmo7moqloMtqGLkHbUQntQHPQIjQDldFOtBRV0Dy0GF2KZqPL0C60G12OrkBXoknoKrQELUdXo2vQHrQX5dBENAFV0T40E81C16JetB+tQgvRFHQdyqDr0Q0oieajJnQA9aFlaAFKoxujqoUcG8Z/P2TqCPIR3RFrIgoR50ScG9ETsTZiXcT6iA0RGyPOi9gU0RmxImJzRGvE+RFbIi6IaInIRhQjtkasjGiOODtiWkRbxIURqYiLIsZHXBwxPWJuxNSIyRHbIi6J2B5RitgRMSdiUcSMiHLEzoilEZWIeRGLIy6NmB1xWcSuiN0Rl0dcEXFlxKSIqyKWRCyPuDrimog9EXsjchETIyZEVCP2RcyMmBVxbURvxP6IVRELI6ZEXBeRibg+4oaIZMT8iKaIAxF9EcsiFkSkI24MqBY6vqdPuvmsJ9x8kSfb/DA+0ebvDb8oNPd/vkfbjD3RZuwBNqNPtBl9kM1nP7/mm5/EO/o4mtHH03w/HkvzOR5H831/DM0P4ZPbFjWOjNFh9Jnv+zn8Rw2/erv+qX83/OJPEnF8jn3TxwZq/XvyHxOf9r2oFn6ak7o8nVqeTi1Pp5anU8vTqeXp1PJ0ank6tTydWp5OLU+nlqdTy9Op5enU8nRqeTq1PJ1ank4tT6eWp1PL06nl6dTydGp5OrU8nVqeTi1Pp5anU8vTqeXp1PJ0ank6tTydWp5OLU+nlqdTy9Op5enU8nRqeTq1PJ1ank4tT6eWp1PL06nl6dTydGp5OrU8nVqeTi1Pp5anU8vTqeXp1PJ0ank6tTydWp5OLU+nlqdTy9Op5enU8nRqeTq1PJ1ank4tT6eWp1PL06nl6dTydGp5OrU8nVqeTi1Pp5anU8vTqeXp1PJ0ank6tTydWp5OLU+nlqdTy9Op5enU8nRqeTq1PJ1ank4tT6eWp1PL06nl6dTydGp5OrU8nVqeTi1Pp5Yf6dR+Jt6Z0P3Pw3HXQHV47RHzuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcJJ+L5HORfC6Sz0XyuUg+F8nnIvlcHMnnxcTvIPE7SPwOEr+DxO8g8TtI/A4Sv4PE7yDxO0j8DhK/g8TvIPE7SPwOEr+DxO8g8TtI/A4Sv4PE7yDxO0j8DhK/g8TvIPE7SPwOEr+DxO8g8TtI/A4Sv4PE7yDxO0j8DhK/g8TvIPE7SPwOEr+DxO8g8TtI/A4Sv4PE7yDxO0j8DhK/g8TvIPE7SPwOEr+DxO8g8TtI/A4Sv4PE7yDxO0j8DhK/g8TvIPE7SPwOEr+DxO8g8TtI/A4Sv4PE7yDxO0j8DhK/g8TvIPE7SPwOEr+DxO8g8TtI/A4Sv4PE7yDxO0j8DhK/g8TvIPE7SPwOEr+DxO8g8TtI/A4Sv4PE7yDxO0j8DhK/g8TvIPE7SPwOEr8jWoma0dloGlqCcqgVTUQz0Sy0D01Fc9FkNActRDPQIjQFZdBSNA8tRvNRE5qNlqEFKB1VLfwsb7f5tUQMj69xefFrXAb9GpeVR3QzKqE8qqBD6CDajbag7egIOopWo8PoVnQTug3dju5Ad6Jj6C50PKpa+LkvXqCP9eZjTfqPwKPiR4vQsYL9OyjWx8rTMxv2H6JHxY9276OPjB99VHz9UeV/pf6HfPnM+M/7zPjRav5btPff49b+5xuHY/05Ln890YiDpu73P4m27n8cErGBamHJ2APk/v7ou17vr7/47eEXV7fUv+J/pRj6jfhb/Ebjt+j0t6j/yq82f/x7rW9U+3+z8RU31UfQsAvn1q8Z/Hz9S+p/06PN4W/4T+Nv/08bv/3/xolPhs1eGdI5w2avDJu9Mmz2yrDZK8NmrwybvTJs9sqw2SvDZq8Mm70ybPbKsNkrw2avDJu9Mmz2yrDZK8NmrwybvTLMMBk2e2XY7JVhs1eGzV4ZNntl2OyVYbNXhs1eGTZ7ZdjslWGzV4bNXhk2e2WYlTNs9sqw2SvDZq8Mm70ybPbKsNkrw2avDPNwhnk/w2avDJu9Mmz2yrDZK8NmrwybvTJs9sqwlsiw2SvDZq8Mm70ybPbKsNkrwyonwxokw2avDJu9Mmz2yrDZK8NmrwybvTJs9sqw2SvDZq8Mq7EMm70ybPbKsNkrw2avDJu9Mmz2yrDZK8NmrwybvTJs9sqw2SvDZq8Mm70ybPbKsNkrw2avDJu9Mmz2yrDZK8NmrwybvTJs9sqw2SvDZq8Mm70ybPbKsNkrM7Ju+98boTq6d+YXwugewcKIGREzI6ZELIpYEPHViM6IlohsxIqIlRHNEWdHTIuYFNEWsSRiecR5EamI8RG5iNaIiRETIqZHzIqYGjE3YnJEJmJpRDJiccT8iKaI2RHLItIB1cLSxkAZXaaMrar/7fCLP6u/GFs4ja3vz9grcOZy95vXmmcuvM9cfo2uwIcXWYXn6l8yttA7Nfx/bukPC6PR9dfY0nxsgTm6AKsW/g/OHP+ocYzcjx5AW9GDaACV0NOoHz2MTqCb0WNoD7oFPYfGo8dRFR1AL6MX0ItoF3oJ1dArKI+OoKPoVrQd3Y4q6Bi6C+1Gx9EhtBptQQfRYXQTug3dge6Mqg6fbsbl7s7Gl3ShPOqOur+pKdFU/29s3TvyRT1oElqH2tAGtBzdje5BK1AnSqFNaDNKogloC7oXTUf3oRaURUV0P3oAbUUPogH0EHoYPYJuRo+ix9AedAvai8ajx9ETqIpqaD8aRKtQCT2JnkJPo350Aj2DymgnehY9h55HB9AL6EW0C72EXkavoCPoKLoVbUe3owo6hu5Cu9FxdAitRgfRYXQTug3dge5Er6LX0OvoDfQmegu9jd5B76KT6D30PvoAfYg2RlULy+qP/awXGs3J+nM/z/7UVVEhVS82ptF2fvNSp74Y+hvNjdhtKvx0fQfllPovOlxfnayp15ksbT57SfPJSmY5TwwaaNTko9PHA1xwfYBLwQ9wufcBLoc+wOXQB7iI+0C8HNr9X0I4jmBrxIMRD0W0RTwa8WbEPRGPRaQibol4L2J6xIcRxYhSxJMR5YidEW9FPBfxbsR9ES9G7Ip4JeLViIGISRGvRTwc8UjEGxHLI/ZE7I14O+LxiHciJkSsjngiohpxMuJwxPsRtYj9EYMRqyKeing64vWIExHPRNwd8WzE8xHJiAMR90Z8EPFCxEsRLwdUCytYAY5jBTiOFeA4VoAjWoMK6Bx0LupBa9E6tB5tQBvReWgT6kQr0GbUis5HW9AFqAVlURFtRStRMzobTUNt6EKUQheh8ehiNB3NRVPRZLQNXYK2oxLageagRWgGKqOdaCmqoHloMboUzUaXoV1oN7ocXYGuRJPQVWgJWo6uRtegPWgvyqGJaAKqon1oJpqFrkW9aD9ahRaiKeg6lEHXoxtQEs1HTegA6kPL0AKURjdGVQsrCdUsoZolVLOEapZQzRKqWUI1S6hmCdUsoZolVLOEapZQzRKqWUI1S6hmCdUsoZolVLOEapZQzRKqWUI1S6hmCdUsoZolVLOEapZQzRKqWUI1S6hmCdUsoZolVLOEapZQzRKqWUI1S6hmCdUsoZolVLOEapZQzRKqWUI1S6hmCdUsoZolVLOEapZQzRKqWUI1S6hmCdUsoZolVLOEapZQzRKqWUI1S6hmCdUsoZolVLOEapZQzRKqWUI1S6hmCdUsoZolVLOEapZQzRKqWUI1S6hmCdUsoZolVLOEapZQzRKqWUI1S6hmCdUsoZolVLOEapZQzRKqWUI1S6hmCdXsSKj+rfpZ8e7hM9FHGu9Mv4r3TjhOqh4nE46TAsc50o9zpB8n845z3B/nuD/OkX6cI/042XWc4/44CX+cY/s4x/Zxju3jHNvHObaPk7/HOWKPc1Qe56g8zlF5nKPyOMfhiL6KLkdXokloI+pEV6NrUCuaiCagLaiK9qFetB+tQjegPpRGK9HZaBpah8ajqWgyKqJtaBGagdajDaiMdqIKmod2oSvQuagHXYWWoOVoD9qM9qIcmolmoWtRN1qIpqDrUAZtQtejJJqPmtABtAwtQFn0u1HVwup6HBZ66vXenNGbn7/S0n/f57irem39F6W4h/pzXCOtFro+/Wrtd3SRtn6h9Q/qv/q7uVr7OZrMT7k4mz9zR9kto7vTuhv/0G6W83+18e3vQnnUjdagAjoHnYt60Fq0Dq1HG9BGdB7ahDrRCrQZtaLz0RZ0AWpBWVREW9FK1IzORtNQG7oQpdBFaDy6GE1Hc9FUNBltQ5eg7aiEdqA5aBGagcpoJ1qKKmgeWowuRbPRZWgX2o0uR1egK9EkdBVagpajq9E1aA/ai3JoIpqAqmgfmolmoWtRL9qPVqGFaAq6DmXQ9egGlETzURM6gPrQMrQApdGNUdXCmkaoHhr+o7YP/89/NRy2V9YT+2vDL55NNH40Td2/0z+yw/tfj0wV3T81/PE3hj/+cv03KLCp5k8af8b96AG0FT2IBlAJPY360cPoBLoZPYb2oFvQc2g8ehxV0QH0MnoBvYh2oZdQDb2C8ugIOopuRdvR7aiCjqG70G50HB1Cq9EWdBAdRjeh29Ad6M6oauGcxsAc2/b/ed4mdexOktF3HT3jXVJrw5/4tf5P3h117GaLsd39Y/eajL796We/B+no+6HePPzxH/Z/cq9CtXAuS52faPzzulAedaM1qIDOQeeiHrQWrUPr0Qa0EZ2HNqFOtAJtRq3ofLQFXYBaUBYV0Va0EjWjs9E01IYuRCl0ERqPLkbT0Vw0FU1G29AlaDsqoR1oDlqEZqAy2omWogqahxajS9FsdBnahXajy9EV6Eo0CV2FlqDl6Gp0DdqD9qIcmogmoCrah2aiWeha1Iv2o1VoIZqCrkMZdD26ASXRfNSEDqA+tAwtQGl0Y1S10EOopgjVFKGaIlRThGqKUE0RqilCNUWopgjVFKGaIlRThGqKUE0RqilCNUWopgjVFKGaIlRThGqKUE0RqilCNUWopgjVFKGaIlRThGqKUE0RqilCNUWopgjVFKGaIlRThGqKUE0RqilCNUWopgjVFKGaIlRThGqKUE0RqilCNUWopgjVFKGaIlRThGqKUE0RqilCNUWopgjVFKGaIlRThGqKUE0RqilCNUWopgjVFKGaIlRThGqKUE0RqilCNUWopgjVFKGaIlRThGqKUE0RqilCNUWopgjVFKGaIlRThGqKUE0RqilCNUWopgjVFKGaIlRThGqKUE0RqilCNUWopkZCdW0jVOsF4qH6kvZP67el1l8crt9l27iXdJ23i9dv/P6vzf1nPuBz7N7hscJybDk+djfx2H3k5w2/+DDeXzx6J/Y330Y+et/x6O3kY83j2H3kYzcgj91QPtah/rfhFzfVX/zX4Rdfb+4P6/2xZf7Y7cnf4pbysTuXx+4tH7uF+Yynt555L/OZt51/obubP8fDXs98xuvYrehn1ryf/bDX0Zujv/me6NFb1EfvjT7zlujRO9TPuDX6m3voz7xV+rPvkB69Wb1aWM8CoJ0FQDsLgHYWAO0sANpZALSzAGhnAdDOAqCdBUA7C4B2FgDtLADaWQC0swBoZwHQzgKgnQVAOwuAdhYA7SwA2lkAtLMAaGcB0M4CoJ0FQDsLgHYWAO0sANpZALSzAGhnAdDOAqCdBUA7C4B2FgDtLADaWQC0swBoZwHQzgKgnQVAOwuAdhYA7SwA2lkAtLMAaGcB0M4CoJ0FQDsLgHYWAO0sANpZALSzAGhnAdDOAqCdBUA7C4B2FgDtLADaWQC0swBoZwHQzgKgnQVAOwuAdhYA7SwA2lkAtLMAaGcB0M4CoJ0FQDsLgHYWAO0sANpZALSzAGhnAdDOAqCdBUA7C4B2FgDtLADaWQC0swBoZwHQzgKgnQVAOwuAdhYA7SwA2lkAtLMAaGcB0M4CoH1kAbCBUE0SqklCNUmoJgnVJKGaJFSThGqSUE0SqklCNUmoJgnVJKGaJFSThGqSUE0SqklCNUmoJgnVJKGaJFSThGqSUE0SqklCNUmoJgnVJKGaJFSThGqSUE0SqklCNUmoJgnVJKGaJFSThGqSUE0SqklCNUmoJgnVJKGaJFSThGqSUE0SqklCNUmoJgnVJKGaJFSThGqSUE0SqklCNUmoJgnVJKGaJFSThGqSUE0SqklCNUmoJgnVJKGaJFSThGqSUE0SqklCNUmoJgnVJKGaJFSThGqSUE0SqklCNUmoJgnVJKGaJFSThGqSUE0SqklCNUmoJgnVJKGaJFSThGqSUE2OhOpGQvX3eBzd7/E4ut/jcXS/x+PoRjQJtaElaDnqRCk0HuVQK5qIJqDpaCZqQbPQVDQXTUZz0EI0Ay1CU1AGrUBLURLNQ4vRfNSEZqNlaAFKo2xUdficMQ6in2t8SRfKox40Ca1DbWg5ugd1ohTajCagLWg6akFF1I3WoA3obrQCbUJJdC+6D2XR/egBtBU9iAbQQ+hh9Ai6GT2KHkN70C1oLxqPHkdPoCqqof1oEK1CJfQkego9jfrRCfQMKqOd6Fn0HHoeHUAvoBfRLvQSehm9go6go+hWtB3djiroGLoL7UbH0SG0Gh1Eh9FN6DZ0B7oTvYpeQ2+gN9Hb6B10Er2H3kcfotfRW+hd9EFUtbCpEb8Hu5sKf6ulf+Qi/9r65zezYebrLLy+zhL76yx5R9SPdqGX0M0ojyroEDqIdqPtaAu6Cd2GbkdH0B3oLnQU3YlWo2PoMLoVHY+qFs6Pt9J3/3H4aYzgqxFbI1ZGNEecHTEtYlJEW8SSiOURGyM6I1IReyNyEa0REyMmRFQjZkZMj2iJmBWxL2JqxNyIyRH7I1ZFlCLmRCyMmBGxKGJKRDkiE7EzYkXE0ohkxLyIxRHzI5oiDkTMjuiLWBaxICIdkQ2oFrY0BnG98r/qc202/4JbzC/4jKd93j78Yl6iPz72s8j9QCfJnpPUFyepL05SX5ykvjhJfXGSkuckZcZJyoyT1DonqTZOUm2cJHdPUm2cpNo4SVlzkqLjJEXHSYqOkxQ5J6k9RrQGXYK2oxLageagRWgGWo82oDLaiVagpaiC5qHF6FI0G12GdqHd6KvocnQFOhddiXrQJHQVWoKWo42oE12NrkF70Ga0F+VQK5qIJqAtqIr2oZloFroW9aL9qButQgvRFHQdyqBN6Hp0A0qi+agJHUB9aBlagNIoG1UtbG0EYH2T6UP1rBx9PMqf1790dEn2y6yqf5m18i9zTvbLI2vJC7/4I9fHdnB/izcv/YLPXi+sq9+idD1Xz7/AU9jrj8S+taX/B/A+p78x/Ik/au7/vG94eqz+ov6s8we4Bj42a35XD2gvrK9/0wa+V49qH31E++gF8dFHtX/WE9orw7/RtfU//ONtFoUN9b/O0y2NA3N4hNRffDdPbf/14ReP17+j+eEXv1h/8SP1HPexGx4+84HuP7B3X73o+7Ff/Yx96vV9Oec393/ahvXhM9TCxub+L7Jz/ZMd6xd/T99V+Yf3TSG+P++2/HneZPkH/aYQXzRpvnwviOEppPuDT4mQH/w7OW+j+u+k+u+k+u+kNu+kNu/kskAnlwU6uSzQyWWBTur2Ti4SdFK+d3LJoJMqvpMLCJ1cQOikpu/kckInpX0nFxc6ubjQSaHfyaWGTur9Ti48dFL2d3IZopMCs5PSvpM6s5N6sZNys5Nys5PqsZOqs5Oqs5OCtpOSspMatJO6tpNStJNStJNys5OKtJMLHZ1c6OjkQkcnFzo6ubTRyQWLTi5YdLIc7uSiRCeXDDq5ZNDJZYFOqv9Oqv9Oyv5OKvxOKvxOavoRDaBH0M1oD9qLHkdPoCqqof1oEK1CT6Gn0Qn0DHoWPY8OoBfQS+hldAQdRbei7eh2dAztRsfRIXQbugPdiSroLnQQ3RRVLVwyVv3PG3mjm6bCf2vshd5OLtfI5Rq5XCOXa+RyjVyukcs1crlGLtfI5Rq5XCOXa+RyjVyukcs1crlGLtfI5Rq5XCOXa+RyjVyukcs1crlGLtfI5Rq5XCOpaiRVjaSqkVQ1jvIauVUj3WskQI0EqJFwNRKuRjrUyLsaWVEj/WokR43kqJEcNZKjRnLUSI4ayVEjX2vka41UqZEqNbK3RsbUyJgauVwjl2vkT42UrpFGNdKoRhrVyPMaeV4jqWokVY2sr5FbNXKrRm7VyK0auVUjVWqkWI2MqZFpNTKtRqaNaDU6iA6jm9Bt6A50J3oVvYZeR2+gN9Fb6G30DnoXnUTvoffRB+hDtBI1o7PRNLQE5VArmohmolloH5qK5qLJaA5aiGagRWgKyqClaB5ajOajJjQbLUMLUDqqWijFSbH7/T2fzIkjyEd0R6yJKEScE3FuRE/E2oh1EesjNkRsjDgvYlNEZ8SKiM0RrRHnR2yJuCCiJSIbUQyoFnY0Hka1sF74XT76LpyLR5+pVGnUNuXvaW1T71CrX/Y3X/Y3P5r9zV98b7OzcTjWD89f+3jPUOH3GicOFTLyo5iRH8WM/Chm5EcxIz+KGflRzMiPYkZ+FDPyo5iRH8WM/Chm5EcxIz+KGflRzMiPYkZ+FDPyo5iRH8WM/Chm5EcxIz+KGflRzMiPYkZ+FDPyo5iRDWyNWBnRHHF2xLSItogLI1IRF0WMj7g4YnrE3IipEZMjtkVcErE9ohSxI2JOxKKIGRHliJ0RSyMqEfMiFkdcGjE74rKIXRG7Iy6PuCLiyohJEVdFLIlYHnF1xDUReyL2RuQiJkZMiKhG7IuYGTEr4tqI3oj9EasiFkZMibguIhNxfcQNEcmI+RFNEQci+iKWRSyISEfcGFAtXDq26+ja0T1Gm+qp+K+HX/Q3UvEy6pRrm0Msfqw86kZrUA+ahNahNrQBLUd3o3vQCtSJUmgT2oySaALagu5F09F9qAVlURHdjx5AW9GDaAA9hB5Gj6Cb0aPoMbQH3YL2ovHocfQEqqIa2o8G0SpUQk+ip9DTqB+dQM+gMtqJnkXPoefRAfQCehHtQi+hl9Er6Ag6im5F29HtqIKOobvQbnQcHUKr0UF0GN2EbkN3oDvRq+g19Dp6A72J3kJvo3fQu+gkeg+9jz5AH0ZVC7uI368kYvx+hZ2fX2Ff2FfY7ziiAjoHnYt60Fq0Dq1HG9BGdB7ahDrRCrQZtaLz0RZ0AWpBWVREW9FK1IzORtNQG7oQpdBFaDy6GE1Hc9FUNBltQ5eg7aiEdqA5aBGagcpoJ1qKKmgeWowuRbPRZWgX2o0uR1egK9EkdBVagpajq9E1aA/ai3JoIpqAqmgfmolmoWtRL9qPVqGFaAq6DmXQ9egGlETzURM6gPrQMrQApdGNUdXCbkJ1G2vabaxpt7Gm3caadhtr2m2sabexpt3GmnYba9ptrGm3sabdxpp2G2vabaxpt7Gm3caadhtr2hG1oiSagLage9F0dB9qQVNRFhXR/egBtBU9iAbQQ+hh9Ai6GT2KHkN70C1oLxqPHkdPoCqqof1oEK1CJfQkego9jfrRCfQMKqOd6Fn0HHoeHUAvoBfRLvQSehm9go6go+hWtB3djiroGLoL7UbH0SG0Gh1Eh9FN6DZ0B7oTvYpeQ6+jN9Cb6C30NnoHvYtOovfQ++gD9GFUtXA5Jey/Cck8gnxEd8SaiELEORHnRvRErI1YF7E+YkPExojzIjZFdEasiNgc0RpxfsSWiAsiWiKyEcWIrRErI5ojzo6YFtEWcWFEKuKiiPERF0dMj5gbMTVicsS2iEsitkeUInZEzIlYFDEjohyxM2JpRCViXsTiiEsjZkdcFrErYnfE5RFXRFwZMSniqoglEcsjro64JmJPxN6IXMTEiAkR1Yh9ETMjZkVcG9EbsT9iVcTCiCkR10VkIq6PuCEiGTE/oiniQERfxLKIBRHpiBsDqoUreKfx/1EPwsJPJWBWtsNq4covfol57Mry2LXmH4E7A0YvKI9dYf7sK8v/fvgT2Zb+b3GJ+Vu8R9PnucRcvxD/n3lY5/f3WvPoNebRa84/yGvNR+rfhvpnRi861y8UTKt/4kf76vPoJeZvcRX6e3z1+ar6WzvWx9nPNNff2vFqbuVupdBrpY5qpcJrpY5qpXJqpW5rpYBqpYBqpYBqpVJrpYBqpVJrpY5qpWBrpZxqpYZspYBqpYZspY5qpY5qpY5qpY5qpTJspWRqpUhqpUhqpUhqpUhqpToa0VfR5ehKNAltRJ3oanQNakUT0QS0BVXRPtSL9qNV6AbUh9JoJTobTUPr0Hg0FU1GRXQj2oYWoRloPdqAymgnqqB5aBe6Ap2LetBadBVagpajPWgz2otyaCaaha5F3WghmoKuQxm0CV2Pkmg+akIH0DK0AGWjqoVrXA195kT4eR6CPrYoGp0sR6fXb/cw9NHpeHTRNLpY+kIPRx+dbkdXTT+sj0avLy9/ov6ZzzFvf4+2+n329D+2Hhud/s94iPpnrgdG12mfY1fad/849c+1XtjTGMv1TWr/o/4/6m8Kfbqxq3Rv43/85rCn1P9ph4d/06f+f/buPbCpO73zv21519hjDAPYDJdCW9N2YYGyu3RE3S4t2KqJ7QOWsbEx5mpjG2xuko/ggMzFko7EnRBESGIRSFBCYiAXclNgV9rVtJ1uMpnpzk5JKfPbdiYzHTp1O/2525mdJrurr4TE8w4kk/uQjvNPzkuWjRE6n+d5vucrSd2up7+h+t+k7l/96+pmFxoNNxoNNxoNN2LdjUbDjZB3I+TdCHk3WhI3mhA3GhQ3WhI3WhI3SoUbLYkbTYgbTYgbTYgbJcaNEuNGiXGjqLjRvLjRvLjRrrjRrrjRrrjRrrhRqNwoVG4UKjcKlRuFyo1C5UYL5EYL5EYRc6OIudEeudEeudEeudEeuVH83GiW3GiW3GiW3CiTbpRJNxopN4qmG22VG0XTjaLpRtF0owFzowFzowFzowFzo9i6UWzdKLZuFFs3Gjc3Gjc3Gjc3Gjc3Gjc3Gjc3CrgbBdyNAu5Gi+dGi+dGcXej4XOj1LtR6t0o9W6UejdKvRulPiU3lAvNgLKgXmg3tACaCY2HSqV0bXsyANNP/e/lyJMypVnQHGgCNBqaCM2U0rUdd34yyz/JpuTjfSLLh21G1Ges5GSbH/ejWu7VNuRz+QktWp568ciLaDI+zc9q0TUj+ZxU7zD3WvrpFU/u9dypFifUu5f8NFstTuzCtZgr6tl9n0SVRLVEjYQmsVhiiUSthF2iTmKpRL1Eg8QyiUaJMokKiSaJQonlEs0SKyQsEqUSLQJ64umrHtj0c109R9/JNj+5txLsvfun1X8/ccMM8yN+av3H+bB69Yn35y3yrP7rxFd85of89PrdP89Fbu031VnqzDHv0eXuT2uV+xdgcftTfiGVuk6w81/0mvYeVTY86je2qLKxF7ur7ssWdeOWqqBqqAXSoBqoFqqDlkL1UAO0DGqEyqAKqAkqhJqhUsgCdUN7pHRtHx7I386RD2RKVVA1VAPVQkVQHVQC1UPl0P3QcagCKoNGQI1QE5QLFUDN0ANQMXQCskClUAsUhE5CK6EHoVPQQ9DD0CNQH9QPhSAn5IN6oDzoNPQopENnIAM6C1VCbdBj0OPQOciEwtATUDvUAT0JnYeegnqhp6EBqAu6AF2ELkF+KADth1qhg1AndAQ6CnVDxyAPtAjaB3mhvdAB6BB0GHoGehZ6Dnoeugy9AL0IvQS9DL0CRaBXoSvQVSld60vGb4vqOM3b71H/9yKFU6iSqJZokqiRKJOokKiVqJNolrBI1EuUSjQK6Il+RBaUEApKCAUlhIISQkEJoaCEUFBCKCghFJQQCkoIBSWEghJCQQmhoIRQUEIoKCEUlBAKSggFJYSCEkJBCaGghFBQQigoIRSUEApKCAUlhIISQkEJoaCEUFBCKCghFJQQCkoIBSWEghJCQQmhoIRQUEIoKCEUlBAKSggFJYSCEkJBCaGghFBQQigoIRSUEApKCAUlhIISQkEJoaCEUFBCKCghFJQQCkoIBSWEghJCQQmhoIRQUEIoKCEUlBAKSggFJYSCEkJBCaGghFBQQigoIRSUEApKCAUlhIISQkEJoaCEUFBCKCghFJQQCkoIBSWEghJCQQmhoIRQUEIoKCEUlBAKSggFJYSCEkJBCaGghFBQQigoIRSUEApKCAUlhIKSkg3KgRZCY6F50GyoEBoJTYQmQS5oDDQNGgVNhWZBE6A50GhoCjQfmg7NhWZAWdBkaAE0ExovpWte7L78arYMzq/iSlBKppSu+VBTqzDtVmHarcK0W4VptwrTbhWm3SpMu1WYdqsw7VZh2q3CtFuFabcK024Vpt0qTLtVmHarMO1WYdqtwrRbhWm3CtNuFabdqtQDad5910ZmUe/DbN94n/dP+rj7ON5QS1jqT/20N3R8kJXCn+slleENHR9lscyPvChF71eKOlGKOlGKOlGKOpFSEVQCzYPKoTJoBNQD5UGzoUJoJFQA6dBEqBiyQJMgFzQGmgaNggyoEmqDpkKzoAnQHGg0NAXqgCqg+VAuNB2aC82AsqBeaDK0G1oAzYTGQ6VQA9QupWuBzGdm1VrMT/4zs/Z/Jh/nkEkKtcfqz0yR1R/8QxzUfqzXTPlhDgdwcfUV0TakUCVRLVEjoUksllgiUSthl6iTWCpRL9EgsUyiUaJMokKiSaJQYrlEs8QKCYtEqUSLgK4dRD/3DfRz30A/9w30c99ItSGHfi4fsqEuEu1R3/BhXlOjLugeM9/nYmPmJLqzl/hELza+zzXGTFPwObjYmL4qfY9fdFQ9zh+aH/J1NJmuLdPHfZxrjj+/d288jPZpSY4ct1KqgqqhGqgWKoLqoBKoHiqH7oeOQxVQGTQCaoSaoFyoAGqGHoCKoROQBSqFWqAgdBJaCT0InYIegh6GHoH6oH4oBDkhH9QD5UGnoUchHToDGdBZqBJqgx6DHofOQSYUhp6A2qEO6EnoPPQU1As9DQ1AXdAF6CJ0CfJDAWg/1AodhDqhI9BRqBs6BnmgRdA+yAvthQ5Ah6DD0DPQs9Bz0PPQZegF6EXoJehl6BUoAr0KXYGuSunakWT8Zt7ZAutba7HVfC0ar5QWQSbkhPKkdO0oUr8Gi2w1+CVqsMhWg0W2Giyy1WCRrQaLbDVYZKvBIlsNFtlqsMhWg0W2Giyy1WCRrQaLbDVYZKvBIlsNFtlqsMhWg0W2Giyy1WCRrSb1QB7Dy0B24aFLaSVkg3KghdBYqA4qgVZBy6AR0GooD1oDFUMWaBo0BhoFtUBroRpoHdQKtUHroanQHGgCtBSqh9qhDqgCmg91QtOhudAGaDK0EeqCuqFx0CZoM7QE2gLVQkXQVmgeVA41QGXQNsgBOaEmqAeaDRVCI6ECqBnSIRc0EZoEbYd2QAZUDVVCs6DR0E5oCtQI7YLcUC40A8qCeqHd0AJoJjQeKpXStfs/003E59QYrL71c/GWGR9iD7F6kcCJbFOM9emJX5uhNkr/eY55L0/6armlS/0h9/io/wv9VhnH0av8A4b7f8DAmVIOVAKtgpZBI6DV0BqoGLJA06AaaB3UCrVB66GpUAU0H5oLbYAmQxuhbmgctAnaAhVBDVAZtA1yQIXQSKgAaoZ0yAXtgAyoEnJDu6HxkA1aCI2F6qA8aAw0CmqB1kJzoAnQUqgeaoc6oE5oOtQFbYaWQLXQVmgeVA45oSaoB5oNTYQmQduhamgWNBraCU2BGqFdUC40A8qCeqEF0EyoVErXHlCvq0g/Vi+p/sWpncAkrGES1jDOaWj2NAw4GiZhDQOOhqZbwzinYTTRMJpoaLM1DHcamkQNLbiGsUVDm62hldbQLmto7zQMfhqGEQ2TsJZqBIO4/vY98TimUCVRLVEjoUksllgiUSthl6iTWCpRL9EgsUyiUaJMokKiSaJQYrlEs8QKCYtEqUSLxEoJm0SOxEKJsRIlEqskRkislsiTWCNRLDFNYozEKIm1EuskWiXaJNZLTJWYIzFBol2iQ2K+RKfEdIm5EhskJktslOiS6JbYJLFZYotEkcRWiXkS5RLbJBwSTokeidkSIyUKJHQJl8REiUkS2yV2SBgSlRKzJEZL7JSYIrFLwi2RKzFDIkuiV2K3xAKJmRLjJfYI6NrJZOal7/236g5eAT0xJMhQfFuG4tsyFN+Wofi2DMW3Zdq9LZ8vb8u0e1ue6W/LtHtbPnmSuF/iuESFRJnECIlGiSaJXIkCiWaJBySKJU5IWCRKJVokghInJVZKPChxSuIhiYclHpHok+iXCEk4JXwSPRJ5EqclHpXQJc5IGBJnJSol2iQek3hc4pyEKRGWeEKiXaJD4kmJ8xJPSfRKPC0xINElcUHiosQlib0SfomAxH6JVomDEp0SRySOSnRLHJPwSCyS2CfhlTggcUjisESDxGWJiMRViRckXpZ4RuJZieclXpR4SeIViVclnpO4IqBrp5I5mb4WnpMjzuRbWgk9CJ2CHoIehh6B+qB+KAQ5IR/UA+VBp6FHIR06AxlQC3QWqoTaoMegx6FzkAmFoSegdqgDOg89BfVCT0MDUBd0AboIXYKqIA/kh7qhALQIaob2QfshL7QXaoUOQAehQ1AndBQ6DB2Bjknp2kOZTaM9aqnyO4mWKNf8mJtHv5s4uKJ+2l12kT6c/PMaEz92SfKfJUv7arZ5Qhuj1oCr1R0ewcydh5k7DzN3HmbuPMzVeZi5U1oMLYFqITtUBy2F6qEGaBnUCJVBFVATVAgth5qhFZAFKoVaoJWQDcqBFkJjoRJoFTQCWg3lQWugYmgaNAYaBa2F1kGtUBu0HpoKzYEmQO1QBzQf6oSmQ3OhDdBkaCPUBXVDm6DN0BaoCNoKzYPKoW2QA3JCPdBsaCRUAOmQC5oITYK2QzsgA6qEZkGjoZ3QFGgX5IZyoRlQFtQL7YYWQDOh8dAeKV3rx9WdPsRoH0KgDyHQhxDoQwj0IQT6EJV9iIQ+REIfwrEPAdGHgOhDQPQhIPoQEH2IvD7ERR/iog9x0Yc47EN49KGg9CFK+hAlfYiSPkRJH6KkD1HShyjpQ3npQ3npQ8z0IWb6UEL6EDp9CJ0+hE4fQqcPodOH0OlD6PQhdPoQOimNgzZBm6El0BaoFiqCtkLzoHKoASqDtkEOyAk1QT3QbKgQGgkVQM2QDrmgidAkaDu0AzKgaqgSmgWNhnZCU6BGaBfkhnKhGVAW1AvthhZAM6HxUKmUroXSnwSRnXyzxdOKqvkclXwTrUfRc85J9sn3QVVQLVQE1UElUDl0HCqDRkBNUAHUDBVDFqgFqoZqoHrofqgCaoRyoQegE1ApFIROQiuhB6FT0EPQw9AjUB/UD4UgJ+SDeqA86DT0KKRDZyADOgtVQm3QY9Dj0DnIhMLQE1A71AE9CZ2HnoJ6oaehAagLugBdhC5BfigA7YdaoYNQJ3QEOgp1Q8cgD7QI2gd5ob3QAegQdBh6BnoWeh66DL0IvQS9AkWgV6Gr0HPQC9DL0BUpXTuTjN/0w/NNnKLfxMP6zdQ3nM28T//xbDP1boi/k3xP3cfkRfzLKvqd2uMf43WrZxK16Y/Nj/T61cwGQvVrNqhFkA/+AtbbL1w99/l6geTXzOEXSA6/QPIX5wWSYTSOX8yWjeMXMWV/ET34FzFbpqRBi6ElUC1kh+qgpVA91AAtgxqhMqgCaoIKoeVQM7QCskClUAu0ErJBOdBCaCxUAq2CRkCroTxoDVQMTYPGQKOgtdA6qBVqg9ZDU6E50ASoHeqA5kOd0HRoLrQBmgxthLqgbmgTtBnaAhVBW6F5UDm0DXJATqgHmg2NhAogHXJBE6FJ0HZoB2RAldAsaDS0E5oC7YLcUC40A8qCeqHd0AJoJjQe2iOla098bj5fVfVJX1J/yL34qpHhd54ffmXIJ9HjPJk8HdPLBouxLLIYSx+LMbktxuS2ODW5nf9E55nE+Vf9zU/5HP94p/Ydbwz3EU7tj/YOb5/1qZ0+pdOn+PCp/WFP7c9+fHkqeTamVxm/gzYoJR+UB7VBJtQFhaELUB9UJRXMzcrOUv9lOtHUnTzQPqgbaoWaob3QAegg5IcOQUehAHQYWgQdgbzQfuiYlJ5IEzlytmHkbMNj2IaRsw0jZxsGyTY01W0YJNswMLVhkGxDi53S/dBxqAIqg0ZAjVATlAsVQM3QA1AxdAKyQKVQCxSETkIroQehU9BD0MPQI1Af1A+FICfkg3qgPOg09CikQ2cgAzoLVUJt0GPQ49A5yITC0BNQO9QBPQmdh56CeqGnoQGoC7oAXYQuQX4oAO2HWqGDUCd0BDoKdUPHIA+0CNoHeaG90AHoEHQYegZ6FnoOeh66DL0AvQi9BL0MvQJFoFehK9BVqEFK1wZuvf1h6jP9kp/y99fJCxEXkl9Q72H5g+SjmVX9sLr5oro50T8l7ndNvXw/Xx01qaMGdfT72aZofNUHUP44JxnTWZo9caAVqDstVEdfUEdRtXOyUB39abZ5ezNlsmHcow4Wqx5THdgTB0ezk7ma3HipjVTfdVrdoqnORf2gItWRHU8cjFJfu65uGq2OvpudrDBZ2vfVTV9UNx1Qv1W6U07u3dReVL/VWHX0SznJxM7STqqbpqqbetSPWJI46FB/1XHqptWWZB3J0lrVQboL04rV10aqm5YnDurVTSXqpja0zNWJg03qa+PV1/rUn/MldfS76huXqlbekqwFWVpE3T0xDmgzLcmalmhrLckymPg91Q+YoL6tXv0tstXRQ+poonogfmJmGjNtkrohxxSN2a0+LDFEJA4WJGtEVrXNvGPQ1aaoO4wzUyPK4cQNv6xumJ04+BV1sMK83aBpk9VvsEn9+PRLAS8mn2SX8B6bX0dV+DqS/+tIza+nnqPPoGGwYXODDZsbbNgYYMPGABs2Ptiw8cGGjQ82bHywYUOBDdsgbNheYMOmCBs2G9iwRcKGLRI2bESwYcOEDdsSbNg+YcP2CRu2LNiwmcKGDQw2bK2wYTuDDRstbLhEa8O2BBsu2NpwAdWGy7c2XL614eKqDRdzbbiYa8MlaBsuw9pwodeGC9I2XPa14bKvDZdvbbgIbMNWDhu2ctiwlcOGrRw2bN6wYUuGDVsybNiEYcPagw2bImzYFGHDxgcbNjfYsLnBhu0MNmxSsGGTgg0bEVI6BT0C9UFOqAc6DT0K6dAZyIDOQpXQ49A5KAw9AT0JPQX1Qk9DF6CLkB8KQPuhVuggdATqho5BHugAdAg6DHVCR6F90F4pXXv253IFf3il63Ow0qUuH/zz8JLXZ7rk9dzw6Th8Ov6CLzyr3DlmuSdOx+dTG/aytOzkRuzLaf5ljuILyZN1f+IHHjBTH+tQZqoynVXtVt/8IiabEiyFlmAptARLoSVYCk1JgxZDS6BayA7VQUuheqgBWgY1QmVQBdQEFULLoWZoBWSBSqEWaCVkg3KghdBYqARaBY2AVkN50BqoGJoGjYFGQWuhdVAr1Aath6ZCc6AJUDvUAc2HOqHp0FxoAzQZ2gh1Qd3QJmgztAUqgrZC86ByaBvkgJxQDzQbGgkVQDrkgiZCk6Dt0A7IgCqhWdBoaCc0BdoFuaFcaAaUBfVCu6EF0ExoPLRHSk+UGRmqViwXWbFcZMWSkBVLQlYsCVmxJGTFIpAVyz5WLPRYsdBjxdKOFYs5VizmWLF8Y8WCjRVLNFYseVmx5GXF0pUVi1VWLE9ZsQRlxaKTFQtLViwlWbF4ZMUCihULKFYsoFixgGLF4oMVyylWLDpZsTBhxcKEFQsvViy8WLFoYcUyjBVLGFYsylixoGHFgoYVCxpWLGhYsaBhxYKGFQsaViz7WLHsY8VihxWLHVYsCVmx9GHF0ocVy0VWLBdZsSxixeKRFYskViySWLFIYsUykxXLTFYsoFixgGLFEpQVyylWLKdYsZxixXKKFcspVix2WLG4YsXShxVLLVYstVix1JLSImgf5IX2QgegQ9Bh6BnoWeh56DL0IvQS9AoUgV6FrkLPQS9AL0NXpHTtZWzJ+B5qY0o+aCWUB7VBJtQFhaELUB9UBXVCHmgf1A21Qs3QXugAdBDyQ4egAHQYWgQdgbzQfugodExK114ZXlgYXlj4BV9YSK8nqH2ZPzR/nusKkfd+myGtLnmPV4fP10/0fFWLSkuGT9zP94n78zthr9x6SW+qpq5C37MqVWGv4n0A8zEf5WM+ysd8lI/5KB/zUT7mo3zMR/mYj/IxH+VjPsrHfJSP+Sgf81E+5qN8zEf5mI/yMR/lYz7Kx3yUj4k2H9NSPqalfExL+ZiW8jEt5WNayse0lI9pKR/TUj6mpXxMS/mYj/IxH+VjPsrHfJSP+Sgf81E+5qN8zEf5mI9SqoI8kB/qhgLQIqgZ2gfth7zQXqgVOgAdhA5BndBR6DB0BDompScKXPp9AL+pTsxP+sOj/7Na2O9O8GpynT+K15Rcx9l+HfPJdcw11zGRXMeUcx3zyXXMJ9cxn1zHfHId88l1TCTXMa1cx4RwHdPKdUwr1zGtXMe0ch3TynVMK9cxrVzHtHId08p1zCfXMZ9cx3xyPZWescw/8M5bl3600+og0918gJfP31la1EcTvWQRlSPztHj3Xrnbfc27XwyWeQL9OHHQkS2fSemnYaY0ZkpIunnRtf+CifkHeC79ABPzDzAx/wDPrJROQW2QCQ1AXVAYugD1QVVQJ+SB/FAAWgQ1Q/sgL7Qf2gu1Qgegg9Ah6Ch0GDoCdUPHpHTtvw53559od55pylWb/gV1y3B3bg535+YH7M7j6evy30iW76/g7STPIsrOImRTskE50EJoLFQHlUCroGXQCGg1lAetgYohCzQNGgONglqgtVANtA5qhdqg9dBUaA40AVoK1UPtUAdUAc2HOqHp0FxoAzQZ2gh1Qd3QOGgTtBlaAm2BaqEiaCs0DyqHGqAyaBvkgJxQE9QDzYYKoZFQAdQM6ZALmghNgrZDOyADqoYqoVnQaGgnNAVqhHZBbigXmgFlQb3QbmgBNBMaD5VK6dofIgD9CEA/AtCPAPQjAP0IQD8C0I8A9CMA/QhAPwLQjwD0IwD9CEA/AtCPAPQjAP0IQD8C0I8A9CMA/QhAPwLQjwD0IwD9CEA/AtCPAPQjAP0IQD8C0I8A9CMA/QhAPwLQjwD0IwD9CEA/AtCPAPQjAP0IQD8C0I8A9CMA/QhAPwLQjwD0IwD9CEA/AtCPAPQjAP0IQD8C0I8A9CMA/QhAPwLQjwD0IwD9CEA/AtCPAPQjAP0IQD8C0I8A9CMA/QhAPwLQjwD0IwD9CEA/AtCPAPQjAP0IQD8C0I8A9CMA/QhAPwLQjwD0IwD9CEA/AtCPAPQjAP0IQD8C0J8KwD/CLqEf58gn5o+xFpuSDcqBFkJjoSKoBJoHlUMNUBk0AuqB8qDZUCE0EiqAdGgiVAxZoEmQCxoDTYNGQQZUCbVBU6FZ0ARoDjQaaoemQB1QBTQfyoWmQ3OhGVAW1AtNhnZDC6CZ0HioVErX/jg9C/Un9yh/FctPP0TYpRSEfNBKKA86DZ2C2iATGoC6oDB0AeqDqqBOyAP5oQC0CGqG9kFeaD+0F2qFDkAHoUPQYegIdBTqho5J6dqfoPcz8GAZ+Ec10PsZ6P0M9H4Gej8DvZ+B3s9A72eg9zPQ+xno/Qw8wQz0fgZ6PwO9n4Hez0DvZ6D3M9D7Gej9DPR+Bno/A/+oBp7eBno/A72fgd7PQO9noPcz0PsZ6P0M9H4Gej8DvZ+BE8FA72eg9zPQ+xno/Qz0fgZOUQNPPgO9n4Hez0DvZ6D3M9D7Gej9DPR+Bno/A72fgd7PQO9noPcz0PsZ6P0MxKGB3s9A72eg9zPQ+xno/Qz0fgaCxUDvZ6D3M9D7Gej9DPR+Bno/A72fgd7PQO9noPcz0PsZ6P0M9H4Gej8DvZ+B3s9A72eg9zPQ+xno/Qz0fgZ6PwO9n4Hez0DvZ6QC8L8lAzD91H8LncRb6CTeQu/wFvqKt9BJvIVO6S3U5LdSdfc15G4AuRtA7gaQuwHkbgC5G0DuBpC7AeRuALkbQO4GkLsB5G4AuRtA7gaQuwHkbgC5G0DuBpC7AeRuALkbQO4GkLsB5G4AuRtA7gaQuwHkbgC5G0DuBpC7AeRuALkbQO4GkLsB5G4AuRtA7gaQuwHkbgC5G0DuBpC7AeRuALkbQO4GkLsB5G4AuRtA7gaQuwHkbgC5G0DuBpC7AeRuALkbQO4GkLsB5G4AuRtA7gaQuwHkbgC5G0DuBpC7AeRuALkbQO4GkLsB5G4AuRtA7gaQuwHkbgC5G0DuBpC7AeRuALkbQO4GkLsB5G4AuRtA7gaQuwHkbgC5G0DuBlK5+zpm7gFM2QOYsgcwZQ9gyh7AlD2AKXsAU/YApuwBTNkDmKsHMFcPYK4ewFw9gLl6AHP1AObqAczVA5idB1AtBjBJD2CSHsAkPYBJegCT9AAm6QFM0gOYpAcwSQ+g/g2g/g2g4g2gGg6g/g1gdh7A7DyA2XkAs/MAZucBzM4DmJ0HMDsPYHYewLQ8gPl4ALV4APPxAObjgVSd/hrqdBR1Ooo6HUWdjqJOR1Gno6jTUdTpKOp0FHU6ijodRZ2Ook5HUaejqNNR1Oko6nQUdTqKOh1FnY6iTkdRp6Oo01HU6SjqdBR1Ooo6HUWdjqJOR1Gno6jTUdTpKOp0FHU6ijodRZ2Ook5HUaejqNNR1Oko6nQUdTqKOh1FnY6iTkdRp6Oo01HU6SjqdBR1Ooo6HUWdjqJOR1Gno6jTUdTpKOp0FHU6ijodRZ2Ook5HUaejqNNR1Oko6nQUdTqKOh1FnY6iTkdRp6Oo01HU6SjqdBR1Ooo6HUWdjqJOR1Gno6jTUdTpKOp0FHU6ijodRZ2Ook5HUaejqNNR1Oko6nQUdTqKOh1N1ek3ZJ2u/rG6x30SVRLVEjUStRJFEnUSJRL1EuUS90scl6iQKJMYIdEo0SSRK1Eg0SzxgESxxAkJi0SpRItEUOKkxEqJByVOSTwk8bDEIxJ9Ev0SIQmnhE+iRyJP4rTEoxK6xBkJQ+KsRKVEm8RjEo9LnJMwJcIST0i0S3RIPClxXuIpiV6JpyUGJLokLkhclLgksVfCLxGQ2C/RKnFQolPiiMRRiW6JYxIeiUUS+yS8EgckDkkclmiQuCwRkbgq8YLEyxLPSDwr8bzEixIvSbwi8arEcxJXBHTt63hfy2xL4kbt17LBUvLXQV37BiaiuhwRtbdUBVVDNVAtVATVQSVQPVQO3Q8dhyqgMmgE1Ag1QblQAdQMPQAVQycgC1QKtUBB6CS0EnoQOgU9BD0MPQL1Qf1QCHJCPqgHyoNOQ49COnQGMqCzUCXUBj0GPQ6dg0woDD0BtUMd0JPQeegpqBd6GhqAuqAL0EXoEuSHAtB+qBU6CHVCR6CjUDd0DPJAi6B9kBfaCx2ADkGHoWegZ6HnoOehy9AL0IvQS9DL0CtQBHoVugJdldK1P8Wk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk78Gk70lN+v9dbQVSLzcqSb4s4ptoaF9Pfkcf5IRMKV37H1g3+E/qHvdJVElUS9RIaBKLJZZI1ErYJeoklkrUSzRILJNolCiTqJBokiiUWC7RLLFCwiJRKtEioGvfwhatHyUf+yB0EloJPQidgtqgc5AJPQyFoT4oBDkhH3QeyoNOQzrUC12EnoYGoC7oAnQGugRVQX4oAO2HWqGDUCd0BDoKdUPHIA+0CGqG9kFeaC90ADoEHZbStT9LfhxIrXpTkqnqRWLq1WL54nWvml196a/u+urcj/hC7GsYmX8Fo1pKNigHWgiNhYqgEmgeVA6VQSOgHigPmg0VQiOhAkiHJkLFkAWaBLmgMdA0aBRkQJVQGzQVmgVNgOZAo6EpUAdUAc2HcqHp0FxoBpQF9UKTod3QAmgmNB4qhRqgdildexPBP4TgH0LwDyH4hxD8Qwj+IQT/EIJ/CME/hOAfQvAPIfiHEPxDCP4hBP8Qgn8IwT+E4B9C8A8h+IcQ/EMI/iEE/xCCfwjBP4TgH0LwDyH4hxD8Qwj+IQT/EIJ/CME/hOAfQvAPIfiHEPxDCP4hBP8Qgn8IwT+E4B9C8A8h+IcQ/EMI/iEE/1Aq+P/8c/MRx8OfbPzxPtlYvRVauTn86vZ7+ROOr6sxLvGkqv6GmuL+4vP21hNanXoSdX/kk/TTeQ8K9UYTJ3GSZk7kj3W2aktVT3zq5/xuFFq9+i3OWYbPXPPn+b4UNz5v5+o9dYr+Yrzpqgqi/54zfDp+Bqfjt2+9iWOW9o76y6j3e9uWXHX4/1SFNRP8TnKh9H9iofRrmIW+hunna5iovpbqnv8S1532YtTYi0EuJRuUAy2ExkJ1UAm0CloGjYBWQ3nQGqgYskDToDHQKKgFWgvVQOugVqgNWg9NheZAE6ClUD3UDnVAFdB8qBOaDs2FNkCToY1QF9QNjYM2QZuhJdAWqBYqgrZC86ByqAEqg7ZBDsgJNUE90GyoEBoJFUDNkA65oInQJGg7tAMyoGqoEpoFjYZ2QlOgRmgX5IZyoRlQFtQL7YYWQDOh8VCplK79Veol6Knb/ljd5tS+g1CMIRRjCMUYQjGGUIwhFGMIxRhCMYZQjCEUYwjFGEIxhlCMIRRjCMUYQjGGUIwhFGMIxRhCMYZQjCEUYwjFGEIxhlCMIRRjCMUYQjGGUIwhFGMIxRhCMYZQjCEUYwjFGEIxhlCMIRRjCMUYQjGGUIwhFGMIxRhCMYZQjCEUYwjFGEIxhlCMIRRjCMUYQjGGUIwhFGMIxRhCMYZQjCEUYwjFGEIxhlCMIRRjCMUYQjGGUIwhFGMIxRhCMYZQjCEUYwjFGEIxhlCMIRRjCMUYQjGGUIwhFGMIxRhCMYZQjCEUYwjFGEIxhlCMIRRjCMUYQjGGUIwhFGMIxVgqFL+LAPxRjgzAH+E6149wZetHuF6V0ipoGTQCWg2tgYohCzQNqoHWQa1QG7QemgpVQPOhudAGaDK0EeqGxkGboC1QEdQAlUHbIAdUCI2ECqBmSIdc0A7IgCohN7QbGg/ZoIXQWKgOyoPGQKOgFmgtNAeaAC2F6qF2qAPqhKZDXdBmaAlUC22F5kHlkBNqgnqg2dBEaBK0HaqGZkGjoZ3QFKgR2gXlQjOgLKgXWgDNhEqldO2tZAB2Jqbs7Wr6/vPEz/0N8awqS4bmQcgppWvfk33l86m+8vuI1TD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjBOqjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6yjD6ynAqFP/6jljVfjVHhMuXkatfxlPgy6kf8QNsuupK3uU+qAqqhmqgWqgIqoNKoHqoHLofOg5VQGXQCKgRaoJyoQKoGXoAKoZOQBaoFGqBgtBJaCX0IHQKegh6GHoE6oP6oRDkhHxQD5QHnYYehXToDGRAZ6FKqA16DHocOgeZUBh6AmqHOqAnofPQU1Av9DQ0AHVBF6CL0CXIDwWg/VArdBDqhI5AR6Fu6BjkgRZB+yAvtBc6AB2CDkPPQM9Cz0HPQ5ehF6AXoZegl6FXoAj0KnQFugo1SOnazeG9Vx/4mvFnt/dKXaVtVzd8Gpuwhjdf3aubrzIF8FLq5PwbdEp/nyM7pb/Hkl5KGlQL1UEN0DKoDGqCuqFCqBmyQHugaqgFqoGWQvVQI1QBlUrp2g+x9XkQbdAg2qBBtEGDaBoG0RQNoikaRJswiFZgEK3AIBqmQTQGg2iYBtEiDaJFGkSLNIjGYBAt0iBapEE0BoNoDAbRGAyiMRhEYzCIxmAQTfsgSvMgyv0gWohBFPhBNBSDKOmDaI0HUeAHUeAH0YgMotwPoi0ZRPEfRJMyiFZgEG3JIBqDQTQwg2hSBlNn8d8mn3zLEuf4Vyxm6uN3X85OnhNZ2k8s6h6DyXuoT4/rzUn+tKzqN9Ttf5e8Xc1Y/82SfBRvTV3pf9q5+KXn4gkyN/WH/z0+JvQdPNffwXP9HTy738Gz+x08Z9/Bs/QdPEvfwS/xDp6l76CRfwfP0nfwLH0Hjfw7aOTfwTmZUgt0FqqE2qDHoHOQCYWh89BTUC/0NDQAdUEXoIvQJagK8kB+qBsKQIugZmgftB/yQnuhVugAdBA6BHVCR6HD0BHomJSu/YjNbKItrf6WebvRSTc4mcYm09Jmus5Mq5NpctM9T7o7fHdrm+6F0i1uphfK9LaZpijT5GZ620xXl2lqMw3S+zS1md4p091mmqg7tkbe2U3d2fh+qP7qI+2kzDTDd3Zlma443Y1lmuF0d/zurizdJKe7szubsnRrfEdz9u7W+D2btffp0W61y7r2D+jOdHRnOrozHV2Pjj5HR6+m4wKhjs5Nx6VZHR2RjgtFKd0PHYcqoDJoBNQINUG5UAHUDD0AFUMnIAtUCrVAQegktBJ6EDoFPQQ9DD0C9UH9UAhyQj6oB8qDTkOPQjp0BjKgs1Al1AY9Bj0OnYNMKAw9AbVDHdCT0HnoKagXehoagLqgC9BF6BLkhwLQfqgVOgh1Qkego1A3dAzyQIugfZAX2gsdgA5Bh6FnoGeh56DnocvQC9CL0EvQy9ArUAR6FboCXZXStf+fVyJUWz0ufUmiINlWD2Hqu4nO9CY605vohG+iM72JTvgmusib6BRvose7iR7vJrrIm+j4bqKfvoke7yb6o5vo+G6i47uJHu8meryb6PFuose7ia7uJjq+m+jxbqLHu4ke7yZ6vJvo8W6iq7uJru4murqb6Fpvose7merx/nH4RS4feMHyF/VFLh9/nVItwJ5R9/x8LVh+9i9y+V/J0/GHCf+N+suoTwL7O0sylRJPq2QK/1PyHp7ED30smXJZ1WXq5h/fMatp/5RtfsQhTS2uXJX/8unnys+a2tLPrX9O/ICcbPMjjnFvJw72firz3I8TBzvuFgdannrJ5a/l3PX5l4kKtaT0ksW852a9O2a89DP73pr1dO0n6Y+3+9XkS7X+d/JJm35ua/9W/RscUd/xvcTBH6q/kDoTDqhb0pPgCZTzE2g0UrJBOdBCaCxUB5VAq6Bl0AhoNZQHrYGKIQs0DRoDjYJaoLVQDbQOaoXaoPXQVGgONAFaCtVD7VAHVAHNhzqh6dBcaAM0GdoIdUHd0DhoE7QZWgJtgWqhImgrNA8qhxqgMmgb5ICcUBPUA82GCqGRUAHUDOmQC5oITYK2QzsgA6qGKqFZ0GhoJzQFaoR2QW4oF5oBZUG90G5oATQTGg+VSunaT7FJNoIAjCAAIwjACAIwggCMIAAjCMAIAjCCAIwgACMIwAgCMIIAjCAAIwjACAIwggCMIAAjCMAIAjCCAIwgACMIwAgCMIIAjCAAIwjACAIwggCMIAAjCMAIAjCCAIwgACMIwAgCMIIAjCAAIwjACAIwggCMIAAjCMAIAjCCAIwgACMIwAgCMIIAjCAAIwjACAIwggCMIAAjCMAIAjCCAIwgACMIwAgCMIIAjCAAIwjACAIwggCMIAAjCMAIAjCCAIwgACMIwAgCMIIAjCAAIwjACAIwggCMIAAjCMAIAjCCAIwgACMIwAgCMIIAjCAAIwjACAIwggCMIAAjqQD852QAJmYP7b9mJ59NWdq31cH/UF2iOrg/cfDX6uD5xMFfYBkhPcE8kLjhLXXD3yRuyDfVol1W9SJTLVFnaRtUq6n+KgdNtbqWVf2gmWz2qx831XpeVnXUFMPI1cQNdaYYShYlbnjTTE1JexL//3biC7nqC3+WuOGSqRYBs7TfUDfcOSW8krjLn5hqvS9LW6nucjxxwz+aarEuSytWN7yg2n118FLiIIJm/XLi4IY6eDVxsFU24Wo0+CN1w7cSB19Xf1AkcTA1+X4Jbycfzsxv8EEe18zDmf7t0g9r4tGrflI+vOlHMfNoZX7ZzMOVfpje+3dNP27ph0vX3km+meUSNSD0qbvuVX/hnFt/cEAdpD9L5ZoIgCR07f+ggJoooCYKqIkCaqKAmiigJgqoiQJqooCaKKAmCqiJAmqigJoooCYKqIkCaqKAmiigJgqoiQJqooCaKKAmCqiJAmqigJoooCYKqIkCaqKAmiigJgqoiQJqooCaKKAmCqiJAmqigJoooCYKqIkCaqKAmiigJgqoiQJqooCaKKAmCqiJAmqigJoooCYKqIkCaqKAmiigJgqoiQJqooCaKKAmCqiJAmqigJoooCYKqIkCaqKAmiigJgqoiQJqooCaKKAmCqiJAmqigJoooCYKqIkCaqKAmiigJgqoiQJqooCaKKAmCqiJAmqigJoooCYKqIkCaqKAmiigJgqomSqg/xcB6EIAuhCALgSgCwHoQgC6EIAuBKALAehCALoQgC4EoAsB6EIAuhCALgSgCwHoQgC6EIAuBKALAehCALoQgC4EoAsB6EIAuhCALgSgCwHoQgC6EIAuBKALAehCALoQgC4EoAsB6EIAuhCALgSgCwHoQgC6EIAuBKALAehCALoQgC4EoAsB6EIAuhCALgSgCwHoQgC6EIAuBKALAehCALoQgC4EoAsB6EIAuhCALgSgCwHoQgC6EIAuBKALAehCALoQgC4EoAsB6EIAuhCALgSgCwHoQgC6EIAuBKALAehCALoQgC4EoAsB6EIAuhCALgSgCwHoQgC6EICuVABmWeTeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUV27C2yY2+RHXuL7NhbZMfeIjv2Ftmxt8iOvUX21N6ibIvsP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP53oP52p/jPHcusVSdX+ZAXLqt6lbrZYUu8Nr+3PVtshchGTPsSkDzHpQ0z6EJM+xKQPMelDTPoQkz7EpA8x6UNM+hCTPsSkDzHpQ0z6EJM+xKQPMelDTPoQkz7EpA8x6UNM+hCTPsSkDzHpQ0z6EJM+xKQPMelDTPoQkz7EpA8x6UNM+hCTPsSkDzHpQ0z6EJM+xKQPMelDTPoQkz7EpA8x6UNM+hCTPsSkDzHpQ0z6EJM+xKQPMelDTPoQkz7EpA8x6UNM+hCTPsSkDzHpQ0z6EJM+xKQPMelDTPoQkz7EpA8x6UNM+hCTPsSkDzHpQ0z6EJM+xKQPMelDTPoQkz7EpA8x6UNM+hCTPsSkDzHpQ0z6EJM+xKQPMelLxeS/sshXV1owLFowLFowLFowLFowLFowLFowLFowLFowLFowLFowLFowLFowLFowLFowLFowLFowLFowLFowLFowUlswOlowOlowOlowOlowOlowOlowOlowOlowOlowOlowOlowLFowLFowLFowLFowLFowLFowLFowLFowLKZUBXkgP9QNBaBFUDO0D9oPeaG9UCt0ADoIHYI6oaPQYegIdExK1/61Rb584y3kZ0o+aCWUB7VBJtQFhaELUB9UBXVCHmgf1A21Qs3QXugAdBDyQ4egAHQYWgQdgbzQfugodExK1/Iswy/RGH6JxvBbyQyZH++VGepFKA+oP+4TeU+Zl1Mn5wiLeFfTP1K3ObV8y61PKqkuFt+wJRXDBeob1KvrfjM5833BIj+t5Bpy8RrS9RoS+xpy8RoS9BoS9Boy8xoy8xoy8xoy8xpS6xpy8RqS8Bqy7xry7RqS9xqS9xqS9xqy9hrS9Rry9Boy8xoy81rqn6Uw+bC2Jh7m59RTrzHxb7HETD3uX0087toYtZOoLjuVh9pfJPcYjVTfkzhhEzdcUy9HyFdHTerbM7mqXhjzY3VQmziwJw60AnWnheroC+ooqn54oTr602zx5yVzaY86WKyiTB3YEwdHs2//btpI9V2n1fcXqfP9eOJglLrpurpptDr6buqFEFna99VNX1Q3HcgROZz6W72ofpmx6uiX1BebEgcn1cGSxEGH+nuNU19brf5e9YmDVos8s5cnDurVnUrUndoQvtWJg03qa+OT27DUH/MldfS76huXqqJgST59srSIunudykV1S436VdT3TVD3rle/aLY6ekgdTVR/15/cPrO1SeqGHHlm3zqRtcnJfw/1Tb+k7rPAVC1xVrXNvOPFKdoUdYdxqX/d6sOJG35Z3TA7cfAr6mCFOMV1rQgXB/9Dsne6D6qCaqEiqA4qgcqh41AZNAJqggqgZqgYskAtUDVUA9VD90MVUCOUCz0AnYBKoSB0EloJPQidgh6CHoYegfqgfigEOSEf1APlQaehRyEdOgMZ0FmoEmqDHoMeh85BJhSGnoDaoQ7oSeg89BTUCz0NDUBd0AXoInQJ8kMBaD/UCh2EOqEj0FGoGzoGeaBF0D7IC+2FDkCHoMPQM9Cz0PPQZehF6CXoFSgCvQpdhZ6DXoBehq5I6dqo4fFmeLy5F8YbNR9MVT/jcz7nfLxXoI9Ono6L1F3VXyZdLNdg+liT6rK/KDun6m+LximFKolqiRoJTWKxxBKJWgm7RJ3EUol6iQaJZRKNEmUSFRJNEoUSyyWaJVZIWCRKJVokVkrYJHIkFkqMlSiRWCUxQmK1RJ7EGoliiWkSYyRGSayVWCfRKtEmsV5iqsQciQkS7RIdEvMlOiWmS8yV2CAxWWKjRJdEt8Qmic0SWySKJLZKzJMol9gm4ZBwSvRIzJYYKVEgoUu4JCZKTJLYLrFDwpColJglMVpip8QUiV0SbolciRkSWRK9ErslFkjMlBgvsUdA18YMtyvD7cq90K78AncpyVbtPyffDmcs9sx8BeugX8F1rJRsUA60EBoL1UEl0CpoGTQCWg3lQWugYsgCTYPGQKOgFmgtVAOtg1qhNmg9NBWaA02AlkL1UDvUAVVA86FOaDo0F9oATYY2Ql1QNzQO2gRthpZAW6BaqAjaCs2DyqEGqAzaBjkgJ9QE9UCzoUJoJFQANUM65IImQpOg7dAOyICqoUpoFjQa2glNgRqhXZAbyoVmQFlQL7QbWgDNhMZDpVK6Nm64HxnuR36x+pFE9a8eb96DfYmuFWMH20+TJ+xJaCX0IHQKehjqg0KQE/JBedBp6FFIh85ALdBZqBJqgx6DzkEmFIbOQ09BvdDT0ADUBV2ALkoFs7Kys9R/mYsLP0UnmZIH8kMBaBHUDO2D9kNeaC/UCh2ADkKHoE7oMHQEOgp1Q8ekdK0k+TzfmHje16oLsv9KXZqdoI6WqaOS5LkwHtdVW5M/5j6oCqqGaqBaqAiqg0qgeqgcuh86DlVAZdAIqBFqgnKhAqgZegAqhk5AFqgUaoGC0EloJfQgdAp6CHoYegTqg/qhEOSEfFAPlAedhh6FdOgMZEBnoUqoDXoMehw6B5lQGHoCaoc6oCeh89BTUC/0NDQAdUEXoIvQJcgPBaD9UCt0EOqEjkBHoW7oGOSBFkH7IC+0FzoAHYIOQ89Az0LPQc9Dl6EXoBehl6CXoVegCPQqdAW6CjVI6dqXbu0zS7Syqtv6q8RBdq76woT0ZjXNKbe3bU5dnJ2IDG9Bhrcgw1uQ4S3Io5Q0qAaqheqgpVA91AAtgxqhMqgCaoIKoWaoFLJA3dAeKV2bZLn1zre/nqO2/U3G42pgz5GBPUcG9usY2K9jYD+Sgf1IBvYjGdiPZGCfj4HdSQZ2/RjYq2RgD5CBnUsGdi4Z2B9kYB+Tgd1CBnY1GdjVZGAnkYE9Tgb2FRnY8WRgl5GB/U8G9hwZ2HNkYM+RgT1HBvYcGdhzZGDPkYE9Rwb2HBnYc2Rgz5GBPUcG9hwZ2HNkYM+RgT1HBvYcGdhzZGDPkYE9Rwb2HBnYc2Rgz5GBPUcG9hwZ2HNkYM+RgT1HBvYcGdhzZGDPkYE9Rwb2HBnYc2Rgz5GBPUcG9hwZ2HNkYM+RgT1HBvYcGdhzZGDPkYE9Rwb2HBnYc2Rgz5GBPUcG9hwZ2HNkYM+RgT1HBvYcGdhzZGDPkYE9Rwb2HBnYc2Rgz5GBPUcG9hwZ2ANkYAeSgR1IBvYHGdiPZGA/koG9QwZ2JxnYnWRgd5KBXUYG9ioZqbL2S8n4VWsP01TRSy8ppReMMqtCmXWizErJnStUdyxY6NqUD7wmpy5kxIcX54YX5/7FLM7dg4tyUzNn+wTLp3C2/zJ6uWL0yMXokYvRIxejDy5Gj5zSYmgJVAvZoTpoKVQPNUDLoEaoDKqAmqBCaDnUDK2ALFAp1AKthGxQDrQQGguVQKugEdBqKA9aAxVD06Ax0ChoLbQOaoXaoPXQVGgONAFqhzqg+VAnNB2aC22AJkMboS6oG9oEbYa2QEXQVmgeVA5tgxyQE+qBZkMjoQJIh1zQRGgStB3aARlQJTQLGg3thKZAuyA3lAvNgLKgXmg3tACaCY2H9kjp2q9kliW+lCP+XZ5NffVXsetDR8jqiAgdEaEjInREhI6I0BGkOgJDR2DoiE4d8aEjPnTEh4740BEfOgJRR5joCBMdYaIjLHVEi45yoyNodASNjqDRETQ6gkZH0OgIGh3FR0fx0RFCOkJIR4HREUk6IklHJOmIJB2RpCOSdESSjkjSEUkpjYM2QZuhJdAWqBYqgrZC86ByqAEqg7ZBDsgJNUE90GyoEBoJFUDNkA65oInQJGg7tAMyoGqoEpoFjYZ2QlOgRmgX5IZyoRlQFtQL7YYWQDOh8VCplK6VIgDjCMA4AjCOAIwjAOMIwDgCMI4AjCMA4wjAOAIwjgCMIwDjCMA4AjCOAIwjAOMIwDgCMI4AjCMA4wjAOAIwjgCMIwDjCMA4AjCOAIwjAOMIwDgCMI4AjCMA4wjAOAIwjgCMIwDjCMA4AjCOAIwjAOMIwDgCMI4AjCMA4wjAOAIwjgCMIwDjCMA4AjCOAIwjAOMIwDgCMI4AjCMA4wjAOAIwjgCMIwDjCMA4AjCOAIwjAOMIwDgCMI4AjCMA4wjAOAIwjgCMIwDjCMA4AjCOAIwjAOMIwDgCMI4AjCMA4wjAOAIwjgCMIwDjCMA4AjCOAIwjAOMIwDgCMJ4KwGl46dFX1D3uk6iSqJaokdAkFksskaiVsEvUSSyVqJdokFgm0ShRJlEh0SRRKLFcollihYRFolSiRaJbYo+Arv1apiX/gcVMXcz6veQe7F9PfiHzMVI5MlwiqQXX30C98qJeeVGvvKhXXtQrL+qVF/XKi3rlRb3yol55Ua+8qFde1Csv6pUX9cqLeuVFvfKiXnlRr7yoV17UKy/qlRf1yot65UW98qJeeVGvvKhXXtQrL+qVF/XKi3rlRb3yol55Ua+8qFde1Csv6pUX9cqLeuVFvfKiXnlRr7yoV17UKy/qlRf1yot65UW98qJeeVGvvKhXXtQrL+qVF/XKi3rlRb3yol55Ua+8qFde1Csv6pUX9cqLeuVFvfKiXnlRr7yoV17UKy/qlRf1yot65UW98qJeeVGvvKhXXtQrL+qVF/XKi3rlRb3yol55Ua+8qFde1Csv6pUX9cqLeuVFvfKiXnlRr7ypevVvPtFt2p/kFaDP65Wf9/704/R1nve+vPPuDzNOX61JX735NK7afICrNZ/6VZpP5eKMuuD2w4/7vlq6Nj29Q+Z/ZqsdMjNwVeU57MxIyQblQAuhsVARVALNg8qhMmgE1APlQbOhQmgkVAAVQxMhCzQJckFjoGnQKMiAKqE2aCo0C5oAzYFGQ1OgDqgCmg/lQtOhudAMKAuaDC2AZkLjoVIpXfu3yafptxM/vNnMfGakrs3EePJH6hvvk6iSWCJRK2GXqJNokFgmUSbRJLFcolnCItEiUS1RI7FYYqlEvUSjRIVEqcQeCU2iUGKFgK7NwlQxElPFSEwVKWlQDlQCLYNWQSOg1dByaA20AiqGLNA0qAZaBy2GWqE2aD00FaqA5kNzoQ3QZGgj1A2NgzZBW6AiqAEqg7ZBDqgQGgkVQM2QDrmgHZABVUJuaDc0HrJBC6GxUB2UB42BRkEt0B5oLTQHmgAtheqhdqgD6oSmQ13QZmgJVAvZoa3QPKgcckJNUA80G5oITYK2Q9XQLGg0tBOaAjVCu6BcaAaUBfVCC6CZUKmUrs1O92GXk33YbyYzNt30ZaaGTNOZGVfu2E5zZ1uvus1V5p3t9wfYZpOZLzI9cqaXTPeumYEj04Onm1hdm3Nr7Sr1N72OnZPXU5X83yXv8p6bg9RfOC/b/Mi7hP598serffeVOeaJzE58XfsP+NW+hQ2f30r9anPf9c6kjero+ey7v0fp+701qXpD0urLyfqWVb3cFO9L2pg4+Ft132J13/XqJ2rqL5Et3480+Zajjuy7vh/pB3wX0u7EganudZ/62qTsn/F+pHsSB6Fs8Y+rVal7P5Nt3u39SO/yLqSJCTnRjJm334409d6jX1c/IPPGpB/iTUh/5luPJt/89Ur23d6EdJH60p9kp9/r9W+yf8Ybk/7W5+al3Wob6zfVH/J5XUwY3kY6vI30Zy1QfDl5Oqb31L+B13W8gT31b+C1G2+g2ryBvfhv4HUIbyD830iFvxULIaeTd7kPqoKqoRqoFiqC6qASqB4qh+6HjkMVUBk0AmqEmqBcqABqhh6AiqETkAUqhVqgIHQSWgk9CJ2CHoIehh6B+qB+KAQ5IR/UA+VBp6FHIR06AxnQWagSaoMegx6HzkEmFIaegNqhDuhJ6Dz0FNQLPQ0NQF3QBegidAnyQwFoP9QKHYQ6oSPQUagbOgZ5oEXQPsgL7YUOQIegw9Az0LPQc9Dz0GXoBehF6CXoZegVKAK9Cl2BrkI2KAdaCI2F5kGzoUJoJDQRmgS5oDHQNGgUNBWaBU2A5kCjoSnQfGg6NBeaAWVBk6EF0ExovJSuzfvwrXGmI870yJ+DF1alG+FMZ/wROuL3GcjvoY443QmnO+N0R6ze7Od75nBn/ME743T7+z4d8ifcGf82ljC+YJHFJqV9UrpWNnz6fqKnr5q/A9n39Hk8fP7eu+fv72CyfRNjyJtoAd/EqPEm2so30Tq+ibb5TTSnb6aK+O/iIukL6h73SVRJVEvUSGgSiyWWSNRK2CXqJJZK1Es0SCyTaJQok6iQaJIolFgu0SyxQsIiUSrRIqBr/xEP7A35wN6QD+wN+cDekA/sDfnA3pAP7A35wN6QD+wN+cDekA/sDfnA3pAP7A35wN6QD+wN+cDekA/sDfnA3pAP7A35wN6QD+wN+cDekA/sDfnA3pAP7A35wCaxUsImkSOxUGKsRInEKokREqsl8iTWSBRLTJMYIzFKYq3EOolWiTaJ9RJTJeZITJBol+iQmC/RKTFdYq7EBonJEhsluiS6JTZJbJbYIlEksVVinkS5xDYJh4RTokditsRIiQIJXcIlMVFiksR2iR0ShkSlxCyJ0RI7JaZI7JJwS+RKzJDIkuiV2C2xQGKmxHiJPQK6Nj+ZeekFpDdxxfdNXG9+E1fQU+qD2qAqqBPyQPugbqgZaoW80F7oAHQQ8kOHoAB0GFoEHYH2Q0ehY1K69ntYmV6RLerMLVVB1VALpEE1UC1UBy2F6qEGaBnUCJVBFVATVAg1Q6WQBeqG9kjp2u/LDxF9Tt3m1Bao21Sn/6xFceF7fTil1qCOWrLNz/pjKu9yffiT/LxKbaq6qUf9iA/yyZWp69Yj1U2f4GdY3nH1+BP7MMtP8iMsU5+MuUn9+HRX82zyeVWO/XGv4pRMaSVkg3KghdBYqA4qgVZBy6AR0GooD1oDFUMWaBo0BhoFtUBroRpoHdQKtUHroanQHGgCtBSqh9qhDqgCmg91QtOhudAGaDK0EeqCuqFx0CZoM7QE2gLVQkXQVmgeVA41QGXQNsgBOaEmqAeaDRVCI6ECqBnSIRc0EZoEbYd2QAZUDVVCs6DR0E5oCtQI7YLcUC40A8qCeqHd0AJoJjQeKpXStYo7X7I4MbnpyvZJbK1Rq25f+Mz22AxvrRneWvPZLEB+9ltr/gALkK9hAfI1LEC+hgXI17AA+RoWIF/DAuRrWIB8LbUAWSmvW1R/VdwjhXES90lUSVRL1EhoEosllkjUStgl6iSWStRLNEgsk2iUKJOokGiSKJRYLtEssULCIlEq0SKxUsImkSOxUGKsRInEKokREqsl8iTWSBRLTJMYIzFKYq3EOolWiTaJ9RJTJeZITJBol+iQmC/RKTFdYq7EBonJEhsluiQ2SWyW2CJRJLFVYp5EucQ2CYeEU6JHYrbESIkCCV3CJTFRYpLEdokdEoZEpcQsidESOyWmSOyScEvkSsyQyJLoldgtsUBipsR4iT0CurYovdf/L5KLDPelP/u3ulQE8B9gbvwDzBYpeaR0rSrxY7TqzJtu9qgq9J3Ewa9ZzI/57pvfTRxcyTHvusG+BsNuEL90EMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEMNuEE/IIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdIIbdYCp2NTTRr6OJfh1N9Otool9HE/06mujX0US/jib69VQTvThdQ95M1pAlmdc5fZ+vc6pNfiH9nPsOfqGUHoD6pHTNrv4Yf+Jx3K3+lDqEvQNh70DYOxD2DoS9A2HvQNg7EPYOhL0DYe9A2DsQ9g6EvQNh70DYOxD2DoS9A2HvQNg7EPYOhL0DYe9A2DsQ9g6EvQNh70DYOxD2DoS9A2HvQNg7EPYOhL0DYe9A2DsQ9g6EvQNh70DYOxD2DoS9A2HvQNg7EPYOhL0DYe9A2DsQ9g6EvQNh70DYOxD2DoS9A2HvQNg7EPYOhL0DYe9A2DsQ9g6EvQNh70DYOxD2DoS9A2HvQNg7EPYOhL0DYe9A2DsQ9g6EvQNh70DYOxD2DoS9A2HvQNg7EPYOhL0DYe9A2DsQ9g6EvQNh70DYOxD2DoS9A2HvQNg7UmG/NBmA6ddg/CX+iVPyQXlQG2RCXdAFqA+qgjohD7QP6oZaoWZoL3QAOgj5oUNQADoMLYKOQF5oP3QUOiala/VcXVbLw/+kDtJLjZklxszicmbZN7PomFllVhdzr8plyPTC5a31Wi1PXf2br+7x7mXn9IJlesnznxN3zMk2b69HZ0atzEJ0ZikzsyKdWYh+O3GwVx38OHFQhtXZzJp0ZqHzfdakM2ugmcXpzGLoHavUd66KZtatvWoN1GKKBewPtWD6kVa3M4vady6zvvfbUaXXW9+9zJpe7E6vqd652ppe675jtfXdm23fc/X1/RZdGz43Ly8evvQx+9b1puqYOXwJ5F/kJZBld9aMX86569m4K3HwZfmSiMTTJHG0QN2EnTzlanvL76ivHc95nzPz1hl5t/d0SO8fypybt7fsZE7KWxuDMieneE+KzNmZOV93JA4WIftbEwd16iCzy+ffJzc05chISp+5iZDRVqmvrEkcbMnBez+kz+FMmUqfzHe+kiJ9emdO3cz2nvQ5nPhtE0eunLuezavUSYw4TO8Keu/z+/beoPQJntkcpM1Vf9Yx9QO3JQ7uVweZdMyc4271PMi5fVKLjVzpnUGJ1i1LeyLnfU7wzImdaSrSsfyuE/z2nq4vJ99rRP1Q1T1cVgeOxMGr6he3qq/9Yc7ts1zs40rHlzZP3fTH2Nr128k3wlA3qXWD13LEuX97p9pdUmBT4k8J3s6xRBOS+MqfqrtsThz8GRaG0+d85hRPn9rrEjfcyHm/Ezm9JWurqm05dzuz04m1Xv1b5tz1zN6SOPhH9Zf9XfVL/kQdZXbv3S6od3RZ2n9Ud/qp+tqt6pfaVfd/7l7k0rUttS0vV910Z3XbnjjIwwa3TBVTO90K1UFn4mCMevznJ9+XRd2UKVo7EwdTZI1698X427vZ3qMSpfYa/oZF7mtLF6XVia9MT7+IabY6WJs4+C2L3Om2QaWFuuX31M8pV3dK16pvqkRRN6Rrlfb76j6L1b0XqKM6S3qP3lp1t1uVSytPbg7E9Yb3rGF31C6tQn33RvVN6Sp2t82J6d2GH6p8ZarWu6tVooYkbtms7psuV+9dprQ/SG6fVHd+dxlKBHniaLf6Urr8ZEayrVgZ2ZoaZxqxz9eSvMt9UBVUDdVAGrQYWgLVQnaoDloK1UMN0DKoESqDKqAmqBBaDjVDKyALVAq1QCshG5QDLYTGQiXQKmgEtBrKg9ZAxdA0aAw0CloLrYNaoTZoPTQVmgNNgNqhDmg+1AlNh+ZCG6DJ0EaoC+qGNkGboS1QEbQVmgeVQ9sgB+SEeqDZ0EioANIhFzQRmgRth3ZABlQJzYJGQzuhKdAuyA3lQjOgLKgX2g0tgGZC46E9UnqiQVahqpZSutMV+QtyWUPXliN2D+bI2E2pCqqGaqBaqAiqg0qgeqgcuh86DlVAZdAIqBFqgnKhAqgZegAqhk5AFqgUaoGC0EloJfQgdAp6CHoYegTqg/qhEOSEfFAPlAedhh6FdOgMZEBnoUqoDXoMehw6B5lQGHoCaoc6oCeh89BTUC/0NDQAdUEXoIvQJcgPBaD9UCt0EOqEjkBHoW7oGOSBFkH7IC+0FzoAHYIOQw3QZSgCXYVegF6GnoGehZ6HXoRegl6BXoWeg65I6VozLjj3o+vtR8/Wjy6tH51YPzqxfvSk/ejL+tGX9aMT60cn1o/esh99WT868H70Xv3ovfrRe/Wj9+pH79WP/rgfHVU/uqZ+dE396Jr60TX1o09KaRy0CdoCFUENUBm0DXJAhdBIqABqhnTIBe2ADKgSckO7ofGQDVoIjYXqoDxoDDQKaoHWQnOgCdBSqB5qhzqgTmg61AVthpZAtdBWaB5UDjmhJqgHmg1NhCZB26FqaBY0GtoJTYEaoV1QLjQDyoJ6oQXQTKhUStdWoBs10Y2a6EZNdKMmulET3aiJbtREN2qiGzXRjZroRk10oya6URPdqIlu1EQ3aqIbNdGNmuhGTXSjJrpRE92oiW7URDdqohs10Y2a6EZNdKMmulET3aiJbtREN2qiGzXRjZroRk10oya6URPdqIlu1EQ3aqIbNdGNmuhGTXSjJrpRE92oiW7URDdqohs10Y2a6EZNdKMmulET3aiJbtREN2qiGzXRjZroRk10oya6URPdqIlu1EQ3aqIbNdGNmuhGTXSjJrpRE92oiW7URDdqohs10Y2a6EZNdKMmulET3aiJbtREN2qiGzXRjZroRk10oya6URPdqIlu1EQ3aqIbNdGNmuhGTXSjJrpRE92oiW7URDdqohs10Y2a6EZNdKMmulEz1Y22JMP4bxPZfibxxcHE/08n/v93if//lvkeW+tXpq+RaYn//yjxf/WF/5X4whyL+f/Yu/P4ps4z7eNGdsceLxIDAYZF2BovFEYwtKUdvW6HDhhqglEghC2OCSF2sImNQVhCWEgIsQgEYg0g9kWAzJ59lZuO1XU67TTdl2m6psu0TZc0rtsqbV8dnUfi/kFISJv0k3TSP3rrazuEgM51rufROZL+glEw+HKvnWr704u1LeLsS1L5qZ+1puavUnNO8MrriS+k5jtS81upWRFMv7ZR9+6g2F/PvOCS3We3pL5wV2r+OjVvDu61L9A2pk9q/1btlYazwZd7xePF1HempOZvUtMcTL84VDc3mH5pq+5DwexLhS77wrc/ce2N+sS11/cGzqsvZvnbvjpBexX5tpe/hOitcJnCnVgHx7AOjmEdHMNqJYZVcQxrlxjWLjGsXWJYP8ewfo5h/RzD+jmG9XMMK6AYVtMxrKZjWE3HsJqOYeUUw8ophpVTDCunGFbhMazCY1iFx7AKj2EVHsMqPIbVWAyrsRhWYzGsxmJYjcWwGothZR/Dyj6GlVoMK7UYVv0xrPpjWPXHsOqPYYUXwx5ADHsAMewBxLAWjGEtGMP+QAwrwxh2C2JYJ8awToxhnRjDvkIM+wox7CvEsK8Qw/oyhvVlDOvLGNaXMexHxLAfEcN+RAz7ETHsR8SwHxHDmjWGNWsMa9YYdi5i2LmIYT0bwz5GDKvbGFa3MaxuY1jdxrC6jWF1q8sL5UFjoBzIB62FJkFWaAhULuWyL8J7K35H+4mbJaZL1EnMkLBL3CIxU2KWxK0SsyVuk5gjMVdinsR8iWqJKRILJIolbpeol7hDIleiXKJBYqHEVAmDxGSJgRKDJe6UKJBYJJEvcZfEIIkKiQESJonFEndLNEo0SdwjUSoxXmKoxBKJZomJEi0SoyUmSCyVGCFxr0SrRJvEMol2ieUSRokVEjaJGgmHxEqJDgmnxDiJEolCCZfEKolhEsMl3BKrJTolaiXGSvSX8EiMlFgj4ZXIkxgjkSPhk1grMUnCKjFEwi/gst+VzrzMrXzpm/s2pdvgYrRBB9qgA23QgTboQBt0oA060AYdaIMOtEEH2qADbdCBNuhAG3SgDTrQBh1ogw60QQfaoANt0IE26EAbdKANOtAGHWiDDrRBB9qgA23QgTboQBt0oA060AYdaIMOtEEH2qADbdCBNuhAG3SgDTrQBh1ogw60QQfaoANt0IE26EAbdKANOtAGHWiDDrRBB9qgA23QgTboQBt0oA060AYdaIMOtEEH2qADbdCBNuhAG3SgDTrQBh1ogw60QQfaoANt0IE26EAbdKANOtAGHWiDDrRBB9qgA23QgTboQBt0oA060AYdaIMOtEEH2qADbdCBNuhAG3SgDTrQBh1ogw60QQfaoANt0KG3wbvxqsh57MbrmgoZoMnQQMgIDYZsUA1UDRVATigfGgcVQyVQITQIGgblQsOhVdAAqAIyQZ1QLdQElUJjoaHQeKg/NBJqhqZAE6E8aDQ0ARoD5UAjoEmQFRoClUu57I3pp2nmdP9T7Sc2CrjsTTiRx3Eij+NEHseJPI4TeRwn8jhO5HGcyOM4kcdxIo/jRB7HiTyOE3kcJ/I4TuRxnMjjOJHHcSKP40Qex4k8jhN5HCfyOE7kcZzI4ziRx3Eij+NEHseJPI4TeRwn8jhO5HGcyOM4kcdxIo/jRB7HiTyOE3kcJ/I4TuRxnMjjOJHHcSKP40Qex4k8jhN5HCfyOE7kcZzI4ziRx3Eij+NEHseJPI4TeRwn8jhO5HGcyOM4kcdxIo/jRB7HiTyOE3kcJ/I4TuRxnMjjOJHHcSKP40Qex4k8jhN5HCfyOE7kcZzI4ziRx3Eij+NEHseJPI4TeRwn8jhO5HGcyOM4kcdxIo/jRB7HiTyOE3kcJ/I4TuRxnMjjOJHHcSKP40Qe10/k91zv/bVv8IOVMx+onPmA5Ws/WDl9C0y+Qd5blb3jTn9z7N9p/7rs+2WnPyB5ryF4o++X/Zo+RvmGPjxZv6lopyH4cu9//ervda1/VPMm7UtvyLtep+/pWWfQ/vaWpE9f21MO5Ipj85L+d9uc/rs1aL9ALH3my6nzaF9vyb477PO54nz3QWSirg1SLvvStz+/6oZfa3xrf/zc3/Yt09otdx7tt/DW/vyqe9FePWivHrRXD9qrB+3Vg/bqQXv1oL160F49aK8etFcP2qsH7dWD9upBe/WgvXrQXj1orx60Vw/aqwft1YP26kF79aC9etBePWivHrRXD9qrB+3Vg/bqQXv1oL160F49aK8etFcP2qsHSe1Be/WgvXrQXj1orx60Vw/aqwft1YP26kF79aC9etBePWivHrRXD9qrB+3Vg/bqQXv1oL160F49aK8etFcP2qsH7dWD9upBe/WgvXrQXj1orx60Vw/aqwft1YP26kF79aC9etBePWivHrRXD9qrB+3Vg/bqQXv1oL160F49aK8etFcP2qsH7dWD9upBe/WgvXrQXj1orx60Vw/aq0fvI63qvfVy7N/TMvun2slee7BZO6+mbyZry3yczH39tPfPW4YNgZ9rv+RGAZe9HZHqQ6T6EKk+RKoPkepDpPoQqT5Eqg+R6kOk+hCpPkSqD5HqQ6T6EKk+RKoPkepDpPoQqT5Eqg+R6kOk+hCpPkSqD5HqQ6T6EKk+RKoPkepDpPoQqT5Eqg+R6kOk+hCpPkSqD5HqQ6T6EKk+RKoPkepDpPoQqT5Eqg+R6kOk+hCpPkSqD5HqQ6T6EKk+RKoPkepDpPoQqT5Eqg+R6kOk+hCpPkSqD5HqQ6T6EKk+RKoPkepDpPoQqT5Eqg+R6kOk+hCpPkSqD5HqQ6T6EKk+RKoPkepDpPoQqT5Eqg+R6kOk+hCpPkSqD5HqQ6T6EKk+RKoPkepDpPoQqT49Uper1zz1L+Zon1tsr+wHlpNVoMu+Iv0rrNO6u7ZcnaktGUYEtbsDcuxbtHTOfPDA58TTJw2X3YHXFUrTv8GboelQHTQDskO3QDOhWdCt0GzoNmgONBeaB82HqqEp0AKoGLodqofugHKhcqgBWghNhQzQZGggNBi6EyqAFkH50F3QIKgCGgCZoMXQ3VAj1ATdA5VC46Gh0BKoGZoItUCjoQnQUmgEdC/UCrVBy6B2aDlkhFZANqgGckAroQ7ICY2DSqBCyAWtgoZBwyE3tBrqhGqhsVB/yAONhNZAXigPGgPlQD5oLTQJskJDIL+Uy77yFe+auPreiMwtEanSXLcl+Bfc//Bqtz1kb3bQ7sYYoJ0YXuUeB5e9Axch/l6cHXRMl6iTmCExS8IoMVtisMQciRqJ3RJ7JKZIVEsUSMyXWCCRJ1EoUS9xn8Qgib0SuRLlEg0S+yT2SyyUiEgckDgocUjisMR6iSMSRyU6JDZJOCXyJY5JHJdwSZyQ6JQ4KVEr0SQRlTglcVoiKHFGIiaxRKJZokvirMQ5CZ/EeYkLEq0SFyUuSVyWWCexWWKLREiiUWKbRIvEDomdEm0SuyQ2SEyTCEhslNgqEZbYLjFX4mGJJyW6JR6ReFzifokHJB6SeFTiMYknJJ6SeFAiLuCyOzOfTfAng7br4ZKf92VfhrsRl+HOyGW4w3GZfhXFKuyJdKGGd6FEdqFEdqFEdqFEdqFEdqFqd6FSdqFSdqFcd6FgdqFgdqFgdqFgdqFgdqEyd6FudqFudqFudqFOd6F8dmFB0oUq2oUq2oUq2oUq2oUq2oUq2oUq2oXlSReWJ12oqV2oqV1YgnShtHahtHahtHahtHahtHahtHahtHahtHahtOq6CVoGtUMzoeXQLMgIrYBsUA00F6qGHNBKqANaADmhcVAxVAIVQvWQC1oFDYOGQ25oNdQJ1UG10FioP+SBRkLzoTWQF8qDxkA5kA9aC02CrNAQqFzKZXe//Y7hN/yy95viHcPffqfw4JvxncK1l90b//KXvVdjk3B5+oi9GZoO2aFZ0GxoLjQPqoYWQG1QMVQP5UINUB3kh2ZAt0FzoPnQFKgcWggZoMHQnVABtAi6HboLugMaBFVAd0O3QI1QE3QPVApNhCZAS6ER0L3QMmg5ZIQc0EqoBCqEXNAqaDXUCdVCXmgtNASaCk2GBkL50ADIBC2GxkNDoSVQM9QCjYZaoXZoJnQrtAKyQTVQB+SExkHDoOGQGxoL9Yc80EhoDZQHjYFyIB80CbJCm6VSOYtvPgf9QMpl70QalyGNy5DGZUi5MuRaGZK6DMd9Gf5Wy5DiZfg7LkOmlyEry5CVZcj7MuR9GXK0DOlfhlQtw7mgDOlfhjwsw7mgDHlYhjNDGZK6DOeJMuR2GY7fMqR4GY7mMhzNZUj4MiR8GRK+DAlfhhQoQ8KXIdPLkOllyIsy5EUZ8qIM6V+GvC9D3pch78uQ92VInTKkThlSpwypU4bzRBkyqAwZVIZzSBnOIWU4h5ThHFKG7NLVBi2D2qHlkBFaAdmgGsgBrYQ6ICc0DiqBCiEXtAoaBg2H3NBqqBOqhcZC/SEPNBJaA3mhPGgMlAP5oLXQJMgKDYH8Uq5UXZcvdPSKTNUxXaJOYobELAmjxGyJwRJzJGokdkvskZgiUS1RIDFfYoFEnkShRL3EfRKDJPZK5EqUSzRI7JPYL7FQIiJxQOKgxCGJwxLrJY5IHJXokNgk4ZTIlzgmcVzCJXFColPipEStRJNEVOKUxGmJoMQZiZjEEolmiS6JsxLnJHwS5yUuSLRKXJS4JHFZYrPEFomQRKPENokWiR0SOyXaJHZJbJCYJhGQ2CixTmKrRFhiu8RciYclnpR4ROJxiYckHpN4QiIu0S1xv8QDEo9KPCXxoIDLvubad2hYlb7u04tWakYrNaOVmtFKzWilZrRSM1qpGa3UjFZqRis1o5Wa0UrNaKVmtFIzWqkZrdSMVmpGKzWjlZrRSs1opWa0UjNaqRmt1IxWakYrNaOVmtFKzWilZrRSM1qpGa3UjFZqRis1o5Wa0UrNaKVmtFIzWqkZrdSMVmpGKzWjlZrRSs1opWa0UjNaqRmt1IxWakYrNaOVmtFKzWilZrRSM1qpGa3UjFZqRis1o5Wa0UrNaKVmtFIzWqkZrdSMVmpGKzWjlZrRSs1opWa0UjNaqRmt1IxWakYrNaOVmtFKzWilZrRSM1qpGa3UjFZqRis1o5Wa0UrNaKVmtFIzWqkZrdSMVmpGKzWjlZrRSs1opWa0UjNaqRmt1IxWatZbqS8dqm2pkLXq13Hm2F9Kp+3azOvNuXna683+9M9l3tN2Kd5XeSneJ3cpXoteqr/evO6qe1IHaY/ekffyd6dqn+jX92q3qeo3oX6+X/CqT4pM36l6i/baRr90XufYd6p7V7WPdrTfnv6stH6ZO0KP9UufDHLskX7ybtb059R9o9/LfpKkfoPr1hu/m3WE9qVLhqD4XMhXusH19tSDOdoPDU7/VvFSzbW3utr/UXv0AXwkXuamV+1lKLs1N3jlnld7vfbT03H361DtS3Oyd6Ee7HdDd8S+IffBZt9t7XL6SRN4+zW6/yOv0WmvIj2t/QNvv1j35n2/3PWZe8zrbg1qAZ8KtfSZYkM628do4eHQ/gntY7/2qqtL7W7twXdSD2Zp/5na+aRVe3Bae5amf9WN2nkmU/UOa2eLDvsmNH0Lmr4FTd+Cpm9B07eg6VvQ9C1o+hY0fQuavgVN34Kmb0HTt6DpW9D0LWj6FjR9C5q+BU3fgqZvQdO3oOlb0PQtaPoWNH0Lmr4FTd+Cpm9B07eg6VvQ9C1o+hY0fQuavgVN34Kmb0HTt6DpW9D0LWj6FjR9C5q+BU3fgqZvQdO3oOlb0PQtaPoWNH0Lmr4FTd+Cpm9B07eg6VvQ9C1o+hY0fQuavgVN34Kmb0HTt6DpW9D0LWj6FjR9C5q+BU3fgqZvQdO3oOlb0PQtaPoWNH0Lmr4FTd+Cpm9B07eg6VvQ9C1o+hY0fQuavgVN34Kmb0HTt6DpW9D0LWj6FjR9C5q+BU3fgqZvQdO3oOlb0PQtaPoWNH2L3vSDCFUDQtWAUDUgVA0IVQNC1YBQNSBUDQhVA0LVgFA1IFQNCFUDQtWAUDUgVA0IVQNC1YBQNSBUDQhVA0LVgFA1IFQNCFUDQtWAUDUgVA0IVQNC1YBQNSBUDQhVA0LVgFA1IFQNCFUDQtWAUDUgVA0IVQNC1YBQNSBUDQhVA0LVgFA1IFQNCFUDQtWAUDUgVA0IVQNC1YBQNSBUDQhVA0LVgFA1IFQNCFUDQtWAUDUgVA0IVQNC1YBQNSBUDQhVA0LVgFA1IFQNCFUDQtWAUDUgVA0IVQNC1YBQNSBUDQhVA0LVgFA1IFQNCFUDQtWAUDUgVA0IVQNC1YBQNSBUDQhVA0LVgFA1IFQNCFWDHqqb06G6K9Vmf67V2q2pB0+kS/EWpO0ovJvmKLyb5ii8m+YovJvmKLyb5ii8m+YovJvmKLyb5ii8m+YovJvmKLyb5ii8m+YovJvmKLyb5ii8m+YovJvmKLybpi4XNAwaBOVCw6FV0ACoAjJBnVAt1ASVQmOhodB4qD80EmqGpkAToTxoNDQBGgPlQD5oBLQWmgRZoSFQOTQXWiLlsoe4UXPdxXp2mya7k5Jdvmf3a7Q9nSHaz2Q3bjIr+8xeQGYv5OqNnMzKP7N3kNnYyWzoZHcCsjs72S2B7BZPdmcns0mQ2dnJbnZkt3iy2wWvsMWT3UnI7vVktxSu2fS5dm/h2m2g17LbsC8np1+O9r/stsMrbxolbnTT6Pq7F9ldpMzuRXbzKLObdN3tjMzu0g1sa2R2ma7Z3rj6DdD+su2OrW/yW2wzd9b2puYTwet/iph2FH40NX+RmibtP2wbLkT5nXY83ywxXaJOYobELAmjxGyJwRJzJGokdkvskZgiUS1RIDFfYoFEnkShRL3EfRKDJPZK5EqUSzRI7JPYL7FQIiJxQOKgxCGJwxLrJY5IHJXokNgk4ZTIlzgmcVzCJXFColPipEStRJNEVOKUxGmJoMQZiZjEEolmiS6JsxLnJHwS5yUuSLRKXJS4JHFZYp3EZoktEiGJRoltEi0SOyR2SrRJ7JLYIDFNIiCxUWKrRFhiu8RciYclnpTolnhE4nGJ+yUekHhI4lGJxySekHhK4kGJuIDLHkaFX2MQQak0HaqDZkCzICM0GxoMzYFqoN3QHmgKVA0VQPOhBVAeVAjVQ/dBg6C9UC5UDjVA+6D90EIoAh2ADkKHoMPQeugIdBTqgDZBTigfOgYdh1zQCagTOgnVQk1QFDoFnYaC0BkoBi2BmqEu6Cx0DvJB56ELUCt0EboEXYY2Q1ugENQIbYNaoB3QTqgN2gVtgKZBAWgjtA7aCoWh7dD90APQg9BD0MPQI9Cj0GPQ49AT0JPQU1Ac6pZy2bejpj4n0lfHdIk6iRkSdolbJGZKzJK4VWK2xG0ScyTmSsyTmC9RLTFFYoFEscTtEvUSd0jkSpRLNEgslJgqYZCYLDFQYrDEnRIFEosk8iXukhgkUSExQMIksVjibolGiSaJeyRKJcZLDJVYItEsMVGiRWK0xASJpRIjJO6VaJVok1gm0S6xXMIosULCJlEj4ZBYKdEh4ZQYJ1EiUSjhklglMUxiuIRbYrVEp0StxFiJ/hIeiZESayS8EnkSYyRyJHwSayUmSVglhkj4BVz2HenM097V/1Tqe8/W5dhv1jYXXt/FJNbqWJ7f4DITC/frrzmxisda/c9ZgGLhfv3VKBbu11+aYq2OdSrWaH/xovX661RsePzFi1bscWAFi20N7GS8rmtbl30nlkv/hJquaypkgCZDAyEjNBiyQTVQNVQAOaF8aBxUDJVAhZALGgYNgnKh4dAqaABUAZmgTqgWaoJKobHQUGg81B8aCTVDU6CJUB40GpoAjYFyIB80AloLTYKs0BCoHJoLLZFy2Xeln+yZVZMdq0I7nlJ2rC3tWA/Y9V9sN97L61n8yLP6j+y54UthtcszP3Wj18S+ntfCvlWvgX0Nl75e/4rXq196yLxWlXkt6o24fvUGrlt9w69XfRNepnof3tquFlc21eK6nFpcy1SL63Jqce1NLa47qsWVOLW4EqcWV+LU4tqiWlyJU4srcWpxpVEtrjSqxVU6tbgeqxZX4tTieqxaXJdTi+tyanFdTi2uy6nFtVO1uNqmFlfU1OKKmlpcUVOLK2pqcQ2NrpugZdByyAjNhaohB7QSKoZKoEKoHnJBq6DVUCdUC3mhtdAQaCo0GRoIzYbyoQGQCfJDDdBiaDw0FLoNmgMtgZqhFmg01Aq1QzOhWdCt0ArIBtVAHdACyAmNg4ZBwyE3VAeNhfpDHmgkNB9aA+VBY6AcyAdNgqxQuZTLvhcfIfCu9I9sgzqkXPZ9WA3MT//IzdB0qA5qgOzQDGgWNBu6DZoDzYXmQfOhamgKtAAqhuqhcigXaoP8Ui77/uxHL8zNFcf4hfTPrpdy2SPpn82cT7PNLHs+z1bCTHV6hQ+0u7rRXNvdrm0Fme6WKgH2s7ip7UepB0dyg+LMnSkI2XqXLTqZpuCyH7jR1mufoxWs/sG3P6Twxj6kULvfav+b45aw/5ufVvjW/pDCg694adQ14aI9/xZmnrsvd9HUNX8K9ju0u8l+nav+yBb3C/4ZV1Rl/76ve2mVdg/b+Fe4xsq+QHu2vfCyx+yrfLBB9lDWLs/6qvaHdghnxFqDPCPqmg7VQTOgWZARmg0NhuZANdBuaA80BaqGCqD50AIoDyqE6qH7oEHQXigXKocaoH3QfmghFIEOQAehQ9BhaD10BDoKdUCbICeUDx2DjkMu6ATUCZ2EaqEmKAqdgk5DQegMFIOWQM1QF3QWOgf5oPPQBagVughdgi5Dm6EtUAhqhLZBLdAOaCfUBu2CNkDToAC0EVoHbYXC0HbofugB6EHoIehh6BHoUegx6HHoCehJ6CkoDnVLueyHEb/tWJC0Y0HSjkVHO5YZ7VhmtGMp0Y6lRDsWD+1YLrSj9rdj8dCOxUM7lgvtWBy1Y+HUjsVDO5ZK7VgOtWM51I4lTzsWOe1YuuhaCBmgwdCdUAG0CLodugu6AxoEVUB3Q7dAjVATdA9UCk2EJkBLoRHQvdAyaDlkhBzQSqgEKoRc0CpoNdQJ1UJeaC00BJoKTYYGQvnQAMgELYbGQ0OhJVAz1AKNhlqhdmgmdCu0ArJBNVAH5ITGQcOg4ZAbGgv1hzzQSGgNlAeNgXIgHzQJskKbpa68w7D+zeegH0i57EfwklcrTmutOMW24lTZqof5Ubwb0TPoW8/gXPcMOtUz+Bc9g3PkM+gHz+As/Iz+rz2W/te2pJYAbrWPYC/ulz6GU0szbf3y1dSDF7RvfS314Gfag6+nHryvnzgOJuJ5MlH/4zieue7DHtB+Npx64NIehFIPvpVecp3Q345J/6ce1f6pDvvJ9D+VXWWmVlf2ROa386z24EupBx/XHuxOPfgRNi72pP7SXwxeWSxrn+T5nPYN7dmwLSiW8tlFZHZLQ1uK+4NX1ozaTsEntG98OfXgc9pv5Sup71wOiqVwpnyXoHyXoHyXoHyXoHyXoHyXoHyXoHyX4MlQgvJdgvJdgvJdgidKCcp3Ccp3Ccp3Ccp3Ccp3Ccp3Ccp3CZYoJajiJajiJajiJajiJajiJajiJajiJajiJajiJajiJajiJajiJajiJajiJajiJajiJajiJTjUSlDFS1DFS1DFdU2HNkCboS3QNKgeCkAhaCO0DmqEtkLboDDUAm2HdkA7oTZol5TLHk3nQeZQ+00/eaj9BuVNVwQ6AB2C1kNHoQ5oE5QPHYOOQy7oBNQAnYRqoSYoCp2GgtAZ6Cx0DvJB56ELUCt0EboEXYamQxugzdAWaBpUDwWgELQRWgc1QluhbVAYaoG2QzugnVAbtEvKZT/FTyXAuUPXVMgATYYGQkZoMGSDaqBqqAByQvnQOKgYKoEKIRc0DBoE5ULDoVXQAKgCMkGdUC3UBJVCY6Gh0HioPzQSaoamQBOhPGg0NAEaA+VAPmgEtBaaBFmhIVA5NBdaIuWyn8682Zq9IE88f87ph8KZ9HcbUt/9F0NQfy2kKB14OXUvpSMrp+6H6YjNqQuJyOxNH1b7oP3QQigCHYCaoNNQEDoEnYHWQ0ehDmgTdBbKh45BLsgHXYLOQxegVugidAK6DE2HNkNboBDUCG2DWqAd0E6oDdoFbYCmQfVQANoIrYO2QmFou5TLHkOYlyLMSxHmpQjzUoR5KcK8FGFeijAvRZiXIsxLEealCPNShHkpwrwUYV6KMC9FmJcizEsR5qUI81KEeSnCvBRhXoowL0WYlyLMSxHmpQjzUoR5KcK8FGFeijAvRZiXIsxLEealCPNShHkpwrwUYV6KMC9FmJcizEsR5qUI81KEeSnCvBRhXoowL0WYlyLMSxHmpQjzUoR5qR7mXa/j+6Pc8NuiaK+69uYG335/lFd7Df761xH/bb8binbxzCdyg6/xtf+z2kbUtBSXGLQ9qHNYc/ahUvShUvShUvShUvShKPShGvShGvShGvShGvShDPShDPRhzdmHatCH03gf1px9WHP2Yc3ZhyLUhzVnH2pRH2pRH4pQHwpNH9acfSgtfagpfagpfagpfagpfSg7fagpfagpfagGfSgtfSgtfagNfagNfagNfag3fSgRfSgRfag+fagUfShCfSgYfahFfagbfShJfShJfShJfShJfXpNOZ+t4ZFc8Sfj0HP9AkpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMJUpMpf5kv4gney+e7L14svfiyd6LJ3svnuy9eLL34sneiyd7L57svfjt9uKp34unfi+e+r146vfiqd+Lp34vnvq9eOr34qnfi6d+L576vXjq9+Kp34unfi+e+r146vfiqd+Lp34vnvq9eOr34qnfi6d+L576vXjq9+Kp34snQy8OhF4cCL04EHpxIPTiQOjFgdCLA6EXB0IvDoReHAi9OBB6cSD04kDoxYHQiwOhFwdCr/5kv4QXGD+b/pH10DpoE7QB2gi1Qm1SLvtlHGMVOMYqcIxV4BirwDFWgWOsAsdYBY6xChxjFTjGKnBUVeCoqsBRVYGjqgJHVQWOqgocVRU4qipwVFXgqKrAUVWBo6oCR1UFjqoKHFUVOKoqcFRV4KiqwFFVgaOqAkdVBY6qChxVFTiqKnBUVeA4qsBxVIHjqALHUQWOowocRxU4jipwHFXgOKrAcVSB46gCx1EFjqMKHEcVOI4qcBxVIKErkCEV+pP9fjzZPekfuRmaDtVBM6BZkBGaDQ2G5kA10G5oDzQFqoYKoPnQAigPKoTqofugQdBeKBcqhxqgfdB+aCEUgQ5AB6FD0GFoPXQEOgp1QJsgJ5QPHYOOQy7oBNQJnYRqoSYoCp2CTkNB6AwUg5ZAzVAXdBY6B/mg89AFqBW6CF2CLkOboS1QCGqEtkEt0A5oJ9QG7YI2QNOgALQRWgdthcLQduh+6AHoQegh6GHoEehR6DHocegJ6EnoKSgOdUu57A+g4jyNQ/Rp/LE+jT+6p/G0eRp/OU/rv/SD3O/8u9TDDwSvvRn+Ne17ah8K1y1v73m1t4HObG++pm3Nl1IP1uFOprfOfuaf9X4Ir7CPmd2/vGbfMrOheb1ty8xuYXaTMrt9mUx9YWhQbGP+5W/mfO1mpdoRd9kfyu7ehA3i+bxSf5Y+jP4xEuc9XVMhAzQZGggZocGQDaqBqqECyAnlQ+OgYqgEKoRc0DBoEJQLDYdWQQOgCsgEdUK1UBNUCo2FhkLjof7QSKgZmgJNhPKg0dAEaAyUA/mgEdBaaBJkhYZA5dBcaImUK5UD8t0Uf6P9xM0S0yXqJGZIzJIwSsyWGCwxR6JGYrfEHokpEtUSBRLzJRZI5EkUStRL3CcxSGKvRK5EuUSDxD6J/RILJSISByQOShySOCyxXuKIxFGJDolNEk6JfIljEsclXBInJDolTkrUSjRJRCVOSZyWCEqckYhJLJFoluiSOCtxTsIncV7igkSrxEWJSxKXJTZLbJEISTRKbJNokdghsVOiTWKXxAaJaRIBiY0S6yS2SoQltkvMlXhY4kmJRyQel3hI4jGJJyTiEt0S90s8IPGoxFMSDwq47I9mP+SyOqhff99o0L7+WPpDLhu025L/TbtBeaFWYgekHtypfWlX+qXRx1EoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqlAoqvRC8QTvhdHuc9kr36Dk3XjB9t142f7d+ourT171oeDZjwK3z9UencHS8I38UPC/2keBl2pfcmq/xI18FLj+Kekl2pfeyA8Ff1N+FLj+qenLtF8+8ybXF9JPmqfSz7tnUz8+L33OSr9Vrssex27GV7CboWsdtAnaAG2EWqE2KZe9G++L9Efti/bKfmA5WQW67B9OHwSLtP/au7W/jFOpB2O0Bwe13QDtv/9w6sHFful8y6k7nvol7tJ++L390pmTY/+a9qe1WPvzmxHU3zakXfvWEW2jQPvW3dpPB+VNWC/hKp2XcJXOS7hK5yVcpfMSrtJ5CVfpvISrdF7C4f4SrtLR5YTyoWPQccgFnYAaoJNQLdQERaHTUBA6A52FzkE+6Dx0AWqFLkKXoMvQdGgDtBlqg7ZA06B6KACFoI3QOqgR2gptg8JQC7QT2g7tgHZJuexPq2Myx/5R7Tj6burBV3K1b3wEB+v78ft5P56x79d/pf+44XddffvNVl/3N1u9gTeVunqP8K/xXlFv/Luuam+V9WtD8PV9k6i//vuw9qRPbP+snX1maP9ZP0g9+Lj2IPMa737E2H6chnRNhQzQZGggNBsaDN0JzYMKoEVQPnQXNAjKhSqgAZAJaoAWQzOgu6FGqAm6ByqFxkNDodugOdASqBmaAk2EWqDR0ARoKTQCuhdqhdqgm6BlUDs0E1oOzYKM0ArIBtVAc6FqyAGthDqgBZATGgcVQyVQIVQPuaBV0DBoOOSGVkOdUB1UC42F+kMeaCQ0H1oDeaE8aAyUA/mgtdAkyAoNgcqlXPZEdvFSH8wuXt7+eI/g2x/voeFN/fEeH73mNX17mVZFru3Ca1IP3iffgjXV3lKPJmlfwq5MjfaV67Vi1YZfZtcluwOU7cVi0+W92qMPad/MVGS1yZOtyle2ma505Wx7Xp16MA0v4DemHsw2BMWOzbu1f75B+1J2QZDp0do7wtypfeeu1IPlBrknk23U2UsMMtX62nduzZTtbJHObtVkGnXqd5t6tEr7p65959Y7tW6NxUhmh+f6tfvKPk+md2c3euwT0lvc2i/oSD3YrT3IrlGy7+vq1Z4H2rcymz1XNuUyuzypJ16OPWYIXr+oZwt69mqPzOLoqqJ+ZX/ufdq/5iHtF02mHjysPViZevCU9hv/V+17HzcEs61d7MllVhV2m/alT2Kb7v9pX/pP7Usd2tpJdvoru44v0+6Xpf4t+4LZ9661V6d3I7UfaU89+Ir2INvlMxU+29gzTf3u1Be+qf3EVb08tSjVjgTtO9mGntloW5H6wg+071xT2TPvV3uP9req/cS1lX156sGL2n/2B7R/wW+1R9k92SsL22uulbH/m/ZDv9e+p978WN8r/ePLLz4za059szVP+9K1q0536kE+ti2zq0tt/7JYe6BtOQ/Q/iYmar/QcKwqPakHI+Ui8uol45U9yqvfh1i9/7C+gzwqV+5WZt6SeFHqO6Mzb588TnuwOPXgvbly/3KplhvaVz6o/To12g9lVp9f1LJF+0Jm9Wn/d+1nbtF+epL2aLb2aLL2aF5uZg92sfYPqFWpvSa9+at95dXfy/ia9al9ivZP36v9Q5mV6sttPmd2k1/TLZTZhenVC9LUMjH1lXbtZzMr0uuvRO0fSm+Paz/clnqw+uXuTUzlferRWu1bV5aaH0ufm172fYfTz52+1HcWyWel9h/g1H6/30t9pzn4cm9qrr0Z12O5wZd5d/Psn/33Uw/i6VcHP57+DWg7TfWZvZ+PprecPoHbI99hEA1PaSEUgQ5AB6FD0GFoPXQEOgp1QJsgJ5QPHYOOQy7oBNQJNUAnoVqoCYpCp6DTUBA6A8WgJVAzdBY6B/mg89AFqBW6CF2CLkPToQ3QZqgN2gJNg+qhABSCNkLroEZoK7QNCkMt0E5oO7QD2iXlsn/yOm/Hp70L3x2qZujvy/e11KH7ruB1341vG3TVe/N9Cq/qD0//yM3QdKgOmgHZoVugmdAs6FZoNnQbNAeaC82D5kPV0BRoAVQM3Q7VQ3dAuVA51AAthKZCBmgyNBAaDN0JFUCLoHzoLmgQVAENgEzQYuhuqBFqgu6BSqHx0FBoCdQMTYRaoNHQBGgpNAK6F2qF2qBlUDu0HDJCKyAbVAM5oJVQB+SExkElUCHkglZBw6DhkBtaDXVCtdBYqD/kgUZCayAvlAeNgXIgH7QWmgRZoSGQX8qVamHyctQ/iUzVMV2iTmKGxCwJo8RsicEScyRqJHZL7JGYIlEtUSAxX2KBRJ5EoUS9xH0SgyT2SuRKlEs0SOyT2C+xUCIicUDioMQhicMS6yWOSByV6JDYJOGUyJc4JnFcwiVxQqJT4qRErUSTRFTilMRpiaDEGYmYxBKJZokuibMS5yR8EuclLki0SlyUuCRxWWKdxGaJLRIhiUaJbRItEjskdkq0SeyS2CAxTSIgsVFiq0RYYrvEXImHJZ6U6JZ4ROJxifslHpB4SOJRiccknpB4SuJBibiAy/5pXLLwHrTV9+CU9h49WP8LwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZqUwZpM5+Rnrr18+Z2GKweJ3YaotSFqbXrUfhYbA6sMImuVpkN10AxoFmSEZkODoTlQDbQb2gNNgaqhAmg+tADKgwqheug+aBC0F8qFyqEGaB+0H1oIRaAD0EHoEHQYWg8dgY5CHdAmyAnlQ8eg45ALOgF1QiehWqgJikKnoNNQEDoDxaAlUDPUBZ2FzkE+6Dx0AWqFLkKXoMvQZmgLFIIaoW1QC7QD2gm1QbugDdA0KABthNZBW6EwtB26H3oAehB6CHoYegR6FHoMehx6AnoSegqKQ91SLvt/I35tiF8b4teG+LUhfm2IXxvi14b4tSF+bYhfG+LXhvi1IX5tiF8b4teG+LUhfm2IXxvi14b4tSF+bYhfG+LXhvi1IX5tiF8b4teG+LUhfm2IXxvi14b4tSF+bYhfG+LXhvi1IX5tiF8b4teG+LUhfm2IXxvi14b4tSF+bYhfG+LXhvi1IX5tiF8b4teG+LUhfm2IXxvi14b4tSF+bYhfG+LXhvi1IX5tiF8b4teG+LUhfm2IXxvi14b4tSF+bYhfG+LXhvi1IX5tiF8b4teG+LUhfm2IXxvi14b4tSF+bYhfG+LXhvi1IX5tiF8b4teG+LUhfm2IXxvi14b4tSF+bYhfG+LXhvi1IX5tiF8b4teG+LXp8fs5xK8V8WtF/FoRsVZErBURa0XEWhGqVsSoFcFpRXBaEZVWhKMV4WhFHFoRgFZEnhWnECtOIVacCqwIfyvi3opItyLErQhqK6LZijC2In6tiF8r4teK+LUifq2IXyvi14r4tSJ+rYhfK+LXivi1In6tiF8r4teK+LUifq2IXyvi14r4tSJ+rYhfK+LXivi1In6tiF8r4teK+LUifq2IXyvi14r4tSJ+rYhfK+LXivi1In6tiF8r4teK+LUifq2IXyvi14r4tSJ+rYhfK+LXivi1In6tiF8r4teK+LUifq2IXyvi14r4tSJ+rYhfK+LXivi1In6tCFwrAteKiLUiYq0IVStC1YpQtSJGrYh7KyLditi2Ioytevw+k47fTOB24zqEbryK3o1X0bvxKno3XkXvxqvo3bjWoBuvqXfjNfVuXF3QjVfYu/EKezdeYe/GK+zdeIW9G9cMdOP19m683t6N19u7cT1BN15978YVGd14Lb4br8V347X4brwW343X4rvxWnw3XovvxvUZ3bg+oxuv03fjdfpuXIPRjVftu/GqfTdete/Gq/bdeNW+G6/ad+NV+268at+NV+113QQtg9qhmdByaBZkhFZANqgGmgtVQw5oJdQBLYCc0DioGCqBCqF6yAWtgoZBwyE3tBrqhOqgWmgs1B/yQCOh+dAayAvlQWOgHMgHrYUmQVZoCFQu5bJ/Ph2AP0v9q06kvvl8ah5LzZ+n5nuD+sX29tT8ZWrmBvULzoPpf0FO3ZaguH49P/UFa2r+KjXnBK/chvBCar4jNb+VmhXpVMype3fwykXZ2etuLakv3JWav07Nm4P6lcdnU7NXu1Re+1e/mPrClNT8TWqa0ymWUzc3ncE5dR/S/ku+kP4v0a40r9B2oLW3q/tx+uLRL8rPfH1E+8/usH8Jtbs+/SdzMzQdqoMaIDs0A5oFzYZug+ZAc6F50HyoGpoCLYCKoXqoHMqF2iC/lMv+ZVyZW4AWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYAWXYB1TwE6dQE6dQE6dQE6dQE6dQE6dQE6dQE6dQE6dQE6dQE6dQFadAFadAFadAFadAFadAFadAFadAFadAFatK7p0AZoM9QGbYGmQfVQAApBG6F1UCO0FdoGhaEWaCe0HdoB7ZJy2b+CdhpCLoXQTkNopyG00xDaaQjtNIRcCqGdhtBOQ0iiENppCO00hHYaQjsNoZ2GkDYhtNMQ2mkI7TSEFA6hnYaQwiG00xDaaQjtNIR2GkI7DaGdhtBOQ8jyELI8hHYaQjsNIa9DaKchtNMQ2mkI7TSEdhpCOw2hnYbQTkNI9hDaaQjtNIR2GkI7DaGdhnDGC6GdhtBOQ2inIbTTEM5/IZzjQminIbTTENppCOe/ENppCO00hHNjCO00hHYawnkzhHYaQjsNoZ2G0E5DaKchtNMQ2mkIzSOEdhpCOw2hnYbQTkNopyE0iBDaaQjtNIR2GkI7DaGdhtBOQ2inIbTTENppCO00hB4S0tvFV1HT9hnkk0HXDGg2lAuVQ1OgzNP0EJqArrlQi5TL/jUktBsJ7UZCu5HQbiS0GwntRkK7kdBuJLQbCe1GQruR0G4ktBsJ7UZCu5HQbiS0GwntRkK7kdBuJLQbCe1GQruR0G4ktBsJ7UZCu5HQbiS0GwntRkK7kdBuJLQbCe1GQruR0G4ktBsJ7UZCu5HQbiS0GwntRkK7kdBuJLQbCe1GQruR0G4ktBsJ7UZCu5HQbiS0GwntRkK7kdBuJLQbCe1GQruR0G4ktBsJ7UZCu5HQbiS0GwntRkK7kdBuJLQbCe1GQruR0G4ktBsJ7UZCu5HQbiS0GwntRkK7kdBuJLQbCe1GQruR0G4ktBsJ7UZCu5HQbiS0GwntRkK79YT+OgLwBfT5F7D+0zUVMkCToYHQbGgwdCc0DyqANkOLoHzoLmgQlAs9B1VAAyAT1AAthmZAd0ONUBN0D1QKjYeGQrdBc6AlUDM0BZoItUCjoQnQUmgEdC/UCrVBN0HLoB9A7dBMaDk0CzJCKyAbVAPNhaohB7QS6oAWQE5oHFQMlUCFUD3kglZBw6DhkBtaDXVCdVAtNBbqD3mgkdB8aA3khfKgMVAO5IPWQpMgKzQEKpdy2b+BMhtO/8jN0HSoDpoBzYKM0GxoMDQHqoF2Q3ugKVA1VADNhxZAeVAhVA/dBw2C9kK5UDnUAO2D9kMLoQh0ADoIHYIOQ+uhI9BRqAPaBDmhfOgYdBxyQSegTugkVAs1QVHoFHQaCkJnoBi0BGqGuqCz0DnIB52HLkCt0EXoEnQZ2gxtgUJQI7QNaoF2QDuhNmgXtAGaBgWgjdA6aCsUhrZDc6GHoSehbugR6HHofugB6CHoUegx6AnoKehBKC7lsv8PeqsfC3c/Fu5+LNz9WLj7sXD3Y+Hux8Ldj4W7Hwt3Pxbufizc/Vi4+7Fw92Ph7sfC3Y+Fux8Ldz8W7n4s3P1YuPuxcPdj4e7Hwt2PhbsfC3c/Fu5+LNz9WLj7sXD3Y+Hux8Ldj4W7Hwt3Pxbufizc/Vi4+7Fw92Ph7sfC3Y+Fux8Ldz8W7n4s3P1YuPuxcPdj4e7Hwt2PhbsfC3c/Fu5+LNz9WLj7sXD3Y+Hux8Ldj4W7Hwt3Pxbufizc/Vi4+7Fw92Ph7sfC3Y+Fux8Ldz8W7n4s3P1YuPuxcPdj4e7Hwt2PhbsfC3c/Fu5+LNz9WLj7sXD3Y+Hux8Ldj4W7Hwt3Pxbufizc/Vi4+7Fw92Ph7sfC3Y+Fux8Ldz8W7n594f5NtFEv2qgXbdSLNupFG/WijXrRRr1oo160US/aqBdt1Is26kUb9aKNetFGvWijXrRRL9qoF23UizbqRRv1oo160Ua9aKNetFEv2qgXbdSLNupFG/WijXrRRr1oo160US/aqBdt1Is26kUb9aKNetFGvWijXrRRL9qoF23UizbqRRv1oo160Ua9aKNetFEv2qgXbdSLNupFG/WijXrRRr1oo160US/aqBdt1Is26kUb9aKNetFGvWijXrRRL9qoF23UizbqRRv1oo160Ua9aKNetFEv2qgXbdSLNupFG/WijXrRRr1oo160US/aqBdt1Is26kUb9aKNetEcvWiOXnQ+L3qkF73Vi27qRcf0omN60Vu9aJxetF8v+qcXjdOLZuzV++eziN8R/WT8jkAbHYFz1Qh0MF126BZoJjQLuhWaDd0GzYHmQvOg+VA1NAVaABVDt0P10B1QLlQONUALoamQAZoMDYQGQ3dCBdAiKB+6CxoEVUADIBO0GLobaoSaoHugUmg8NBRaAjVDE6EWaDQ0AVoKjYDuhVqhNmgZ1A4th4zQCsgG1UAOaCXUATmhcVAJVAi5oFXQMGg45IZWQ51QLTQW6g95oJHQGsgL5UFjoBzIB62FJkFWaAjkl3LZv6Vf6ZlTd692jee38R4uHxUJq2O6RJ3EDAm7xC0SMyVmSdwqMVviNok5EnMl5knMl6iWmCKxQKJY4naJeok7JHIlyiUaBFz277yun+ejfYjZ8KD+bsC3vt4f8KPeUvkt+0E/2Tcjf30/8Sf7duPXefvm7EcBZd6zWb0V91/lo4Eyb718Ax8RlHlb7r/wo4Le2p8Q9F0ejpm/omveDD57MGYPk+xfEo7Klwziry3zvL76oMz8dWYOzuxfZ/aozP69XvOW51eemNnDMft3/AqHY/avP3tcZp8H1xyg1z4hrj1kX9NT5M86nrOH8bVPrOzxnHlCZQ/jzHF99RMrc3hnnkXXPr8yR/c1z6+rP+Drus+36z/NMke8y/69157+2adX9jRwTfq/+UI/81TKPrf+jNDPPiWufba8iUI/87TIhP9bNvS1CjG/32s9tF/P9M8cnK9wFnid0//7WufVPl3llwat9D6XPjqzR0nmtip1l1T28MrcXqXdl/WQ/vut+0Jqfjv1Dz4vz1WZvyhX6nDVfuXsn2PquW9PqPON/VntwZdSDz6uPdidevAjHJp7Ur/ai+J5cV/qG89p39CWBdvkszb7x5Q9aLVnnV/8qWgHxSe0b3w59eBz2m/lK6nvXJZ/2Zm91SLsrRZhb7UIe6tF2Fstwt5qEfZWi7C3WoS91SLsrRZhb7UIe6tF2Fstwt5qEfZWi7C3WoS91SLsrRZhb7UIe6tF2IEuwk5rEXZai7DTWoSd1iLstBZhp7UIO61F2Gktwk5rEXZai7DTWoSd1iLstBZhp7UIO61F2Gktwk5rEXZai7DTWoSd1iLstOqaDm2ANkNboGlQPRSAQtBGaB3UCG2FtkFhqAXaDu2AdkJt0C4pl/2HuPPvd/3kofY77LjpikAHoEPQeugo1AFtgvKhY9BxyAWdgBqgk1At1ARFodNQEDoDnYXOQT7oPHQBaoUuQpegy9B0aAO0GdoCTYPqoQAUgjZC66BGaCu0DQpDLdB2aAe0E2qDdkm57D/CBv070z9yMzQdqoNmQHboFmgmNAu6FZoN3QbNgeZC86D5UDU0BVoAFUO3Q/XQHVAuVA41QAuhqZABmgwNhAZDd0IF0CIoH7oLGgRVQAMgE7QYuhtqhJqge6BSaDw0FFoCNUMToRZoNDQBWgqNgO6FWqE2aBnUDi2HjNAKyAbVQA5oJdQBOaFxUAlUCLmgVdAwaDjkhlZDnVAtNBbqD3mgkdAayAvlQWOgHMgHrYUmQVZoCOSXcrneaf9xOlazHxymffbXp/sFr6y2r//pY9m147Vr9mtWbi77/772XYrUutL++KtsVr/94fNv2K7E3+an0L+1t5Z/gqtke1B7enDS7sFJuwcn7R6ctHtw0u5BtenBKbwHp/AelJkenNB7cELvwQm9Byf0HpzQe1BRenB678HpvQen9x7Ulx6c7HtQAHtw6u/Bqb8Hp/4enPp7cOrvwam/B6f+HtTBHtTBHtSCHtSCHlS+HpSEHpSEHpSEHpSEHpSEHpSEHpSEHpSEHpQEXTdBy6B2aCa0HJoFGaEVkA2qgeZC1ZADWgl1QAsgJzQOKoZKoEKoHnJBq6Bh0HDIDa2GOqE6qBYaC/WHPNBIaD60BvJCedAYKAfyQWuhSZAVGgKVS7nsP31dX+p+873I8bf7yvbVdeIt92LGK9SMz6QeTPxb7Bs/U5/TpH/ub/qTgD+lPdDe1e3Z9Ju5PZ/+icwR/Dw2zp/HRvbz+jblz1FhEqgwCVSYBCpMAhUmgQqTQIVJoMIkUGESqDAJVJgEKkwCFSaBCpNAhUmgwiRQYRKoMAlUmAQqTAIVJoEKk0CFSaDCJFBhEqgwCVSYBCpMAhUmgQqTQIVJoMIkUGESqDAJVJgEKkwCFSaBCpNAhUmgwiRQYRKoMAlUmAQqTAIVJoEKk0CFSaDCJFBhEqgwCVSYBCpMAhUmgQqTQIVJoMIkUGESqDAJVJgEKkwCFSaBCpNAhUmgwiRQYRKoMAlUmAQqTAIVJoEKk0CFSaDCJFBhEqgwCVSYBCpMAhUmgQqTQIVJoMIkUGESqDAJVJgEKkwCFSaBCpNAhUmgwiRQYRKoMAlUmIReYX7BCpM532WLyzUnvle4TugVuk3mLJk5r77ahUOZ83CmA2XOqpkO9JouKMqceDNl6BUuMLqRevQKVxppxW9QbvCvcclR5lT+OhWu6zeCV78W6boVIdPMbqAq/OVXJ91QhfglXre5PV0JboamQ3XQDGiW1L67m3PS/8sGsv5Ds6HB0ByoBtoN7YGmQNVQATQfWgDlQYVQPXQfNAjaC+VC5VADtA/aDy2EItAB6CB0CDoMrYeOQEehDmgT5ITyoWPQccgFnYA6oZNQLdQERaFT0GkoCJ2BYtASqBnqgs5C5yAfdB66ALVCF6FL0GVoM7QFCkGN0DaoBdoB7YTaoF3QBmgaFIA2QuugrVAY2g7dDz0APQg9BD0MPQI9Cj0GPQ49AT0JPQXFoW4pl/1Xb73LxYqRVMVIqmIkVTGSqhhJVYykKkZSFSOpipFUxUiqYiRVMZKqGElVjKQqRlIVI6mKkVTFSKpiJFUx8rwYuVWM3CpGbhUjt4qRW8XIrWLkVjFyqxi5VYzcKkZuFSO3ipFbxcitYuRWMXKrGLlVjNwqRm4VI7eKkVu6pkMboM3QFmgaVA8FoBC0EVoHNUJboW1QGGqBtkM7oJ1QG7RLymV/4dqtHW9ma+cD6Zdsf53+Ce19+xty0392OXVntK+/+NZLEiOSxIgkMSJJjEgSI5LEiCQxIkmMSBIjksSIJDEiSYxIEiOSxIgkMSJJjEgSI5LEiCQxIkmMSBIjksSIJDEiSYxIEiOSxIgkMSJJjEgSI5LEiCQxIkmMSBIjksSIJDEiSYxIEiOSxIgkMSJJjEgSI5LEiCQxIkmMSBIjksSIJDEiSYxIEiOSxIgkMSJJjEgSI5LEiCQxIkmMSBIjksSIJDEiSYxIEiOSxKgnSW86D55NHXvz0r/tnLpTVw69ut+JI0/HQomIxAGJgxJGicEShyQOS6yXqJE4InFUYo9EgcQmCadEvsQxiUKJ4xIuiUESJyQ6JRokTkqsk6iVaJKISpySOC1xRiImsVtiiUSzRJfEWYlzEnkSPon7JPZKnJe4INEqcVHiksRlAZf9N6/zrXq3vH2r3l/xVr1rtsUy+2Vv1lv1+t56zcmE5mRCczKhOZnQnExoTiY0JxOakwnNyYTmZEJzMqE5mdCcTGhOJjQnE5qTCc3JhOZkQnMyoTmZ0JxMaE4mNCcTmpMJzcmE5mRCczKhOZnQnExoTiY0JxOakwnNyYTmZEJzMqE5mdCcTGhOJjQnE5qTCc3JhOZkQnMyoTmZ0JxMaE4mNCcTmpMJzcmE5mRCczKhOZnQnExoTiY0JxOakwnNyYTmZEJzMqE5mdCcTGhOJr05/TadB9e/xDYb5Nnrc7+XevCFl7/WdqMWvLkyKDOJnj3BaFf3xrXv9KW+M0H7HfwOu/O3pF+vuhmaDtVBDZAdmgHNgmZDt0FzoLnQPGg+VA1NgRZAxVA9VA7lQm2QX8qV+ouTb27yB/HnqGO6RJ3EDIlZEkaJ2RKDJeZI1EjsltgjMUWiWqJAYr7EAok8iUKJeon7JAZJ7JXIlSiXaJDYJ7FfYqFEROKAxEGJQxKHJdZLHJE4KtEhsUnCKZEvcUziuIRL4oREp8RJiVqJJomoxCmJ0xJBiTMSMYklEs0SXRJnJc5J+CTOS1yQaJW4KHFJ4rLEOonNElskQhKNEtskWiR2SOyUaJPYJbFBYppEQGKjxFaJsMR2ibkSD0s8KdEt8YjE4xL3Szwg8ZDEoxKPSTwh8ZTEgxJxAZc9mc7Jr6bOP53pP+0cu1u97YS9OFOFZ2inqK+lfqQ1Nb+e+sL7+l05jOwTcVHMRD1+X3pD3gLp1a4P1d7fwK/9A29fKPr2WyC9/RZIVy76+AOuCv2JQda8n+jd949onvMMojEpTYfqoBnQLMgIzYYGQ3OgGmg3tAeaAlVDBdB8aAGUBxVC9dB90CBoL5QLlUMN0D5oP7QQikAHoIPQIegwtB46Ah2FOqBNkBPKh45BxyEXdALqhE5CtVATFIVOQaehIHQGikFLoGaoCzoLnYN80HnoAtQKXYQuQZehzdAWKAQ1QtugFmgHtBNqg3ZBG6BpUADaCK2DtkJhaDt0P/QA9CD0EPQw9Aj0KPQY9Dj0BPQk9BQUh7qlXPY/Yb36aZG+OqZL1EnMkLBL3CIxU2KWxK0SsyVuk5gjMVdinsR8iWqJKRILJIolbpeol7hDIleiXKJBYqHEVAmDxGSJgRKDJe6UKJBYJJEvcZfEIIkKiQESJonFEndLNEo0SdwjUSoxXmKoxBKJZomJEi0SoyUmSCyVGCFxr0SrRJvEMol2ieUSRokVEjaJGgmHxEqJDgmnxDiJEolCCZfEKolhEsMl3BKrJTolaiXGSvSX8EiMlFgj4ZXIkxgjkSPhk1grMUnCKjFEwGXPyZN3G0WwoxnB3UYR3G0Uwd1GEdxtFMHdRhHsaEZwt1EEdxtFsIcZwd1GEdxtFMHdRhHcbRTB3UYR7FNGcLdRBHcbRXC3UQT7txHcbRTB/m0EdxtFcLdRBHcbRXC3UQR3G0Vwt1EEdxtFsAscwS5wBHcbRXC3UQQ7vRHcbRTB3UYR3G0Uwd1GEdxtFMHdRhHcbRTB3UYR7AlHcLdRBHcbRXC3UQR3G0Vwt1EEe+UR3G0Uwd1GEdxtFMHdRhHsnEewOx7B3UYR3G0UwcZKBDvnEdxtFMHdRhHsqkdwt1EEdxtFsOMewd1GEdxtFMHdRhHcbRTB3UYR3G0Uwd1GEbxmEcHdRhHcbRTB3UYR3G0Uwd1GEbz2EMHdRhHcbRTB3UYR3G0Uwd1GEdxtFMHdRhHcbRTB3UYR3G0UwSsYEX1jrJ8WgPa8fqml+SJtjf7T1IMPph6kFuqpf/0nglqVz7G/W9tyyH72JVIyjJQMIyXDSMkwUjKMlAwjJcNIyTBSMoyUDCMlw0jJMFIyjJQMIyXDSMkwUjKMlAwjJcNIyTBSMoyUDCMlw0jJMFIyjJQMIyXDSMkwUjKMlAwjJcNIyTBSMoyUDCMlw0jJMFIyjJQMIyXDSMkwUjKMlAwjJcNIyTBSMoyUDCMlw0jJMFIyjJQMIyXDSMkwUjKMlAwjJcNIyTBSMoyUDCMlw0jJMFIyjJQMIyXDSMkwUjKMlAwjJcNIyTBSMoyUDCMlw0jJMFIyjJQMIyXDSMkwUjKMlAwjJcNIyTBSMoyUDCMlw0jJMFIyjJQMIyXDSMkwUjKMlAzrKWlATQwgAAMIwAACMIAADCAAAwjAAAIwgAAMIAADCMAAAjCAAAwgAAMIwAACMIAADCAAAwjAAAIwgAAMIAADCMAAAjCAAAwgAAMIwAACMIAADCAAAwjAAAIwgAAMIAADCMAAAjCAAAwgAAMIwAACMIAADCAAAwjAAAIwgAAMIAADCMAAAjCAAAwgAAMIwAACMIAADCAAAwjAAAIwgAAMIAADCMAAAjCAAAwgAAMIwAACMIAADCAAAwjAAAIwgAAMIAADCMAAAjCAAAwgAAMIwAACMIAADCAAAwjAAAIwgAAMIAADCMAAAjCAAAwgAAMIwAACMIAADCAAAwjAgB6AuQhAJwLQiQB0IgCdCEAnAtCJAHQiAJ0IQCcC0IkAdCIAnQhAJwLQiQB0IgCdCEAnAtCJAHQiAJ0IQCcC0IkAdCIAnQhAJwLQiQB0IgCdCEAnAtCJAHQiAJ0IQCcC0IkAdCIAnQhAJwLQiQB0IgCdCEAnAtCJAHQiAJ0IQCcC0IkAdCIAnQhAJwLQiQB0IgCdCEAnAtCJAHQiAJ0IQCcC0IkAdCIAnQhAJwLQiQB0IgCdCEAnAtCJAHQiAJ0IQCcC0IkAdCIAnQhAJwLQiQB0IgCdCEAnAtCJAHQiAJ0IQCcC0IkAdCIAnQhAJwLQiQB0IgCdCEAnAtCJAHTqAZiXXifP0NbJa7R18nOpB9VyVXwQmXgQmXgQKXgQ2XYQ2XYQ2XYQ2aZrM7QIugsaBOVCFdAM6G6oEWqC7oFKoSnQRGgCtBQaAd0LtUE3Qcug5ZARmgtVQw5oJVQMlUCFUD3kglZBq6FOqBbyQmuhIdBUaDI0EJoN5UMDIBPUAC2GxkNDodugOdASqBlqgUZDrdAPoHZoJjQLWgHZoBqoA1oAOaFx0DBoOOSG6qCxUH/IA42E5kNroDxoDJQD+aBJkBUql3LZ35HOywItL7+aikn732uPFuQGxQV281IP+gzpv4oc+62pB/ZC7Ycma4+KtEcf0fYhi7VHn++XztYc+6e0B9p1aX7twS3apWzag1tTD3ZqPz1C++knc9P//Tl1M1NfKdG+ckz7Ibt2qZT2Q0Zta3NP6oFJ+943tC/11x59v186z3PsP9S+9A/al7YaglcuzbMP0L70qPb7G6g9MhvSz4Ac+37tS6Xp33xu+omWY2/W/qNvSm+r5qaf6zn2Ru1B5rIv+yDteyXal25PPZijfWmw9qUmXKNXl3qwTPveEO1767V/zz9qjz6Qmz6ccuy1uem8Sf1HG9IRlWO35qaP7Bz7u3LT0Z76fWq/wFDtH5uj/Vf00x4d1B4N0/4gfhvMXglmH659wRAUV4KpC7/sZu07k9LHfk7d1OA1Nz7ZR2o/cFNQvzhye+oLZdoXxqUeWLQHdwTFFWGZF84fTD9V/i69ttA2nj9mCL7MfnMUZ9YozqxRJF4U59ko8i+K/Isi/6I4I0dxRo7ijBzFGTmKc3AUKRrFGTmKM3IUZ+QozshRpG8U6RtF+kaRvlGcyaM4k0dxJo/iTB7FmTyKM3kUiR5FokeR6FEkehSJHkWiR9EOomgHUaR9FGkfRXOIojlE0RyiaA5RnCWi6BFR9IgoekQUZ5AoziBRdIwozidRNI4ozi5RnF2iOLtE0U2i6CZRdJMoukkUZ6UozkpRnJWiOCtF0Wmi6DRRdJooOk0UnSaKThPFmS6KM10UZ7oo2k8U7SeKs2AUXSiKc2IU58QozolRnBOjOCdGcU7U5YXyoDFQDuSD1kKTICs0BCqXctnz896sb2P8Vr0q/f/WhyC8zheZfy71hXPad96aV5sX5MlLyV/EJcy6pkIGaDI0EDJCgyEbVAPNhaqhAsgJ5UPjoGKoBCqEXNAwaBCUCw2HVkEDoArIBHVCtVATVAqNhYZC46H+0BJoJNQMTYEmQnnQaGgCNAbKgXzQCGgtNAmyQkOgcimXK1zc4Vy80rko9f/Oezr2+vbeW5Gbk2Nfl9sRLrynvenqr0/P7XC1PBk2zVq8smNpe/OHVi5vd6Z+bK+r5cML975T+4XrznWkx3l9XNDHRX1c0sdlfdyvjwf08aA+HtLHw/p4RB+P6uMxfTyujyf08aQ+ntJHXB/d+viwPp7Wx0f08R/66NFHQh8f1cfH9PFxfXxCH5/Ux6f08Z/6+LQ+/ksfn9HHZ/Xx3/r4nD6e0cfn9fEFfXxRH1/Sx5f18RV9fFUfX9PH1/XxDX38jz6+qY9n9fEtfXxbH9/Rx3f18T19fF8fz+njB/r4oT5+pI8f6+N/9fETffxUHz/Tx/P6+Lk+fqGPX+rjV/p4QR+/1seL+ujVx2/00aeP3+rjd/r4vT6S+nhJH3/Qxx/18af0SGW/PvupaVAzV808Nd+h5t+pma9mgZp/r2ahmkVqFqtZoqZRTZOa/dX8BzUHqDlQzZvUHKTmYDWHqPmPag5Vc5iaw9UcoaZZzZFqlqpZpqZFzX9Ss1zNCjUr1axSc5Sa71RztJpj1PxnNa1qjlVznJr/ouZ4Nd+l5rvVfI+aE9R8r5rvU/Nf1bSp+f/UrFbz/Wp+QM1/U3Oimh9U89/VnKTmZDVr1Jyi5lQ1P6RmrZrT1LxZzelq1qk5Q027mreoOVPNWWrequZsNW9Tc46ac9Wcp+Z8NReoebua9WreoWaDmgvVvFPNRWrepeZiNe9Ws1HNJjXvUXOJms1qtqi5VM171WxVs03NZWq2q7lczRVqOtRcqWaHmk41XWquUtOt5mo1O9X0qLlGTa+aPjXXqulXc52aATXXq7lBzY1qblIzqOZmNbeoGVJzq5rb1AyruV3NHWruVHOXmrvV3KPmfWruVXOfmvvVjKh5QM2Dah5S87CaR9Q8quYxNY+reULNk2pG1Tyl5mk1z6gZU7NLzbNqnlPzvJoX1Lyo5iU1L6t5v5oPqPmgmg+p+bCaj6j5qJqPqfm4mk+o+aSaT6kZV7NbzQ+r+bSaH1HzP9TsUTOh5kfV/JiaH1fzE2p+Us1Pqfmfan5azf9S8zNqflbN/1bzc2o+o+bn1fyCml9U80tqflnNr6j5VTW/pubX1fyGmv+j5jfVfFbNb6n5bTW/o+Z31fyemt9X8zk1f6DmD9X8kZo/VvN/1fyJmj9V82dqPq/mz9X8hZq/VPNXar6g5q/VfFHNXjV/o2afmr9V83dq/l7NpJovqfkHNf+o5p/UzDHos5+aBjVz1cxT8x1q/p2a+WoWqPn3ahaqWaRmsZolahrVNKnZX81/UHOAmgPVvEnNQWoOVnOImv+o5lA1h6k5XM0RaprVHKlmqZplalrU/Cc1y9WsULNSzSo1R6n5TjVHqzlGzX9W06rmWDXHqfkvao5X811qvlvN96g5Qc33qvk+Nf9VTZua/0/NajXfr+YH1Pw3NSeq+UE1/13NSWpOVrNGzSlqTlXzQ2rWqjlNzZvVnK5mnZoz1LSreYuaM9Wcpeatas5W8zY156g5V815as5Xc4Gat6tZr+YdajaouVDNO9VcpOZdai5W8241G9VsUvMeNZeo2axmi5pL1bxXzVY129Rcpma7msvVXKGmQ82Vanao6VTTpeYqNd1qrlazU02PmmvU9KrpU3Otmn4116kZUHO9mhvU3KjmJjWDam5Wc4uaITW3qrlNzbCa29XcoeZONXepuVvNPWrep+ZeNfepuV/NiJoH1Dyo5iE1D6t5RM2jah5T87iaJ9Q8qWZUzVNqnlbzjJoxNbvUPKvmOTXPq3lBzYtqXlLzspr3q/mAmg+q+ZCaD6v5iJqPqvmYmo+r+YSaT6r5lJpxNbvV/LCaT6v5ETX/Q80eNRNqflTNj6n5cTU/oeYn1fyUmv+p5qfV/C81P6PmZ9X8bzU/p+Yzan5ezS+o+UU1v6Tml9X8ippfVfNran5dzW+o+T9qflPNZ9X8lprfVvM7an5Xze+p+X01n1PzB2r+UM0fqfljNf9XzZ+o+VM1f6bm82r+XM1fqPlLNX+l5gtq/lrNF9XsVfM3avap+Vs1f6fm79VMqvmSmn9Q849q/knNnFx99lPT8P9bMJuciGEYCg+a6fwD0nAIWHER0NxgFLmpaUPTJnJcibkBlbzMVUAcj7ST1RdbT/Zzli9zmbnKLDLXmZvMbeYuc595yDxm3i8DysZ5Nq6fErAXKSoshzqOsg5MRnN6PbaIXoG1il2LSTfKnglRaQshxLMUGnSDqb3xLrDFr3hu7j6fl4uFFKlCis2fHJigDx+OulSf56jtckvcQLaejCPD1yjrPinARtlBV5p6mJsrGNhFKQjrNHyUJ0/OQw2MKm00N/fJ6LxM6WS1BN1OB8mpg2uZZBY0Ns5WSJPyASvDipE604NNNzQ/b4vmd5SjoyTBSgXkEL/laDrviJUHbkK8RDkEN5DGuZFO36bJQ23mz5tSw9U7UBuH13/kfXPy'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'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'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
