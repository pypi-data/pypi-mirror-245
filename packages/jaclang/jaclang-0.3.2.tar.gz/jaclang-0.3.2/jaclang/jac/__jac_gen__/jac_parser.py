# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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c/xl3ActP3QBaoHOQ+eg/lAX5ILOQK3QLKgEuggdg7ZBZ6HjkAc6DZ2ATkKnoC1SEWuQ/YwHLFfw+/afMqUaeD8aeD8aeD8aeD8aeD8aeD8aeD8aeD+adD/acj/acj/acj/acj/acj8acT8acT8acT9abz9abz9abz9abz+abT+abT+abT+abT+abT+abT+abT/aaz/aaz/aaz/aaz/aaz/aaz/aaz/aaz/aaz/aaz/aaz8aXD/aSD8aTj8aaj9aUz+aXz8aYz+aXz+aXz/aeT9aYT9aYT+aez8afz+aez+aez+aez+aZj9afT+aez8aeD8aar9u6wbfof+8f5rHfn8+RzZ5bjR5bhyY3Wj53Gj53Gj53DiEu3EId6MddOOA7kZz6EZz6MbB3o1W0Y1W0Y1GwI1GwI020o020o0mwY0mwY2i6kbD6UaBd6PgulG23Wgn3GgntJ6HVkMvQC9CL0HroEtQAdQFHYQuQ+uhl6FXoFehIugINBuaA+2D5kI9oHlQKbQQ2g8tgsqgxVA5tASqgJZCA6DlUCV0DloBWdBRKAeqhoZDe6GRUC10AKqHGqB8aBK0FloDNUKvQa9Db0CHoUKoGNoAbYTehO6G7oHegt6G3oHelYpYQ+yamupefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefOhefLp7GSr6FeuSfYYMifkSCySelnhGYpnEsxIDJbIkDkk8J5EtUSURlNgjUSOxUsItMVoiV2KWRJ1Ei0SJhEtilUSexPMSqyVekHhR4iWJdRKXJAokuiQOSlyWWC/xssQrEq9KFEkckZgtMUdin8RciR4S8yRKJRZK7JdYJFEmsViiXGKJRIXEUokBEsslKiXOSayQsCSOSuRIVEsMl9grMVKiVuKARL1Eg0S+xCSJtRJrJBolXpN4XeINicMShRLFEhskNkq8KfGWxNsS70jcLfGuQMQa9t4fkLY/QTzK0/G//pPSv88PSKc+9Jj6EOT/sg9Ipz8pm/6k9K/+gHT6Y7Hpj87+v3xAOv0J1/QnpNOfcE19CDb9Sdf0h2DTn3RNf3b6j+4D0sPtfdGeMHHZq/1qYY3z+coR9nr7uf2WfY9Srfm33LKV1JoCFUJFkB9qhHpDLdAF6DzUH+qCzkEu6AzUCs2CSqCL0DFoG3QWOg55oNPQCegkdAraIhWxRprPulvPdfzOH3U/oBYm2Jf6bT7zni4N13/4/a/Uwq2e99zJf5tPwV9fgX/N1yD8vj8F/yW1UPOH8nH41BHhuiLxh/dx+Ig1Sn9zmN46P+MR4xijHlBPqBfkhXxQJuSHekN9oL5QP2gAFIAGQllQNjQIGgzlQEOgodAwaDg0AhoJjYJGQ2OgsdANUC40DhoPTYDyoHxoIjQJmgw1QlOgqVABNA0qhIqg6dAMaCZUDB2DjkP9oRPQSegUNAtqgUogF9QFnYbOQK3QNugsdA46D22BLkAXoXuh+6D7oQegB6GHoIehR6BHocegx6EnoCehp6Aq6CBUCu2HKqBKyIJWQ3ugfdBe6BB0GDoqFbFGy6/1+rIq0f/m0dU+2ODueI8v+DpmHwfR/6YPadd/b9dX1MIKeyF95PprtfC0feZUdxCxxtj3ILU/fwHPXhLPbBLPZRLPXhKvSBLPcxLPbFI/7rHyrb82vPXXhjf72vBmXxve7GvDG3pteAuvDW/hteFNuza8adeGN+ba8MZcG95ua0PH2Ya+tQ1vorXhzbA2vI3Vhrex2vA2VhveZGrDm0xteOuoDW8dteGtoza8ddSGt47a8PZQG94easPbQ214C6gNbwG14S2gNrwF1Ia3gNrwpk8b3thpwxs7bXhjpw1v7LThjZ02vHnThpFNG95o0ZoPLYOehbKgbGgPVAONhnKhWVALtArKg1ZDL0AvQi9Bl6ACqAs6CF2GXoWKoCPQbGgOtA+aC5VCC6H9UAW0FDoHrYD2QrXQAWgN1Ai9Dr0BHYY2QBuhYqmIdYP8io7xHvnMjUdHrjUXKoXmQT2g+dACaCG0CCqDFkPl0BKoAloKLYMGQMuhgVAWVAmtgCyoCsqBglA1VAONhGqhlVAuNBqqhxqgVVAelA9NgtZAa6FGaB1UAK2HCqEN0EaoGBoOrZaKWLnykzTrsZVq9YR6QV7IB2VCfqg31AfqC/WDBkABaCCUBWVDg6DBUA40BBoKDYOGQyOgkdAoaDQ0BhoL3QDlQuOg8dAEKA/KhyZCk6DJUCM0BZoKFUDToEKoCJoOzYBmQsXQMcgDHYf6Qyegk9ApaBbUApVALqgLOg2dgVqhbdBZ6Bx0HtoCXYAuQvdC90H3Qw9AD0IPQQ9Dj0CPQo9Bj0NPQE9CT0F7oH3QXqgU2g9VQBZ0EDoEHYYqoSroqFTEGidHWmGMtMIYaYUx0gpjpBXGSCuMkVYYI60wRlphjLTCGGmFMdIKY6QVxkgrjJFWGCOtMEZaYYy0whhphTHSCmOkFcZIK4yRVhgjrTBGWmGMtMIYaYUx0gpjpBXGSCuMkVYYI60wRlphjLTCGGmFMdIKY6QVxkgrjJFWGCOtMEZaYYy0whhphTHSCmOkFcZIK4yRVhgjrTBGWmGMtMIYaYUx0gpjpBXGSCuMkVYYI60wRlphjLTCGGmFMdIKY6QVxkgrjJFWGCOtMEZaYYy0whhphTHSCmOkFcZIK4yRVhgjrTBGWmGMtMIYaYUx0gpjpBXGSCuMkVYYI60wRlphjLTCGGmFMdIKY6QVxkgrjJFWGCOtMEZaYYy0whhphfVIa7ysfyHUvxDqXwj1L4T6F0L9C6H+hVD/Qqh/IdS/EOpfCPUvhPoXQv0Lof6FUP9CqH8h1L8Q6l8I9S+E+hdC/Quh/oVQ/0KofyHUvxDqXwj1L4T6F0L9C6H+hVD/Qqh/IdS/EOpfCPUvhPoXQv0Lof6FUP9CqH8h1L8Q6l8I9S+E+hdC/Quh/oVQ/0KofyHUvxDqXwj1L4T6F0L9C6H+hVD/Qqh/IdS/EOpfCPUvhPoXQv0Lof6FUP9CqH8h1L8Q6l8I9S+E+hdC/Quh/oVQ/0KofyHUvxDqXwj1L4T6F0L9C6H+hVD/Qqh/IdS/EOpfCPUvhPoXQv0Lof6FUP9CqH8h1L8Q6l9I178Jv+vvXdh/+PX59/+cq+P9P+d6/8+5On6XP+dKV+Rzes/Mk3PAEzyypmllQHOhUmge1AOaDy2AFkKLoDJoMVQOLYEqoKXQMmgAtBwaCGVBldAKyIKqoBwoCFVDNdBIqBZaCeVCo6F6qAFaBeVB+dAkaA20FmqE1kEF0HqoENoAbYSKoeHQaqmIla/fZb72S08jU7/01Nf5m6SJ8qMV3xYbv8Z8iQUST0s8I7FM4lmJgRJZEocknpPIlqiSCErskaiRWCnhlhgtkSsxS6JOokWiRMIlsUoiT+J5idUSL0i8KPGSxDqJSxIFEl0SByUuS6yXeFniFYlXJYokjkjMlpgjsU9irkQPiXkSpRILJfZLLJIok1gsUS6xRKJCYqnEAInlEpUS5yRWSFgSRyVyJKolhkvslRgpUStxQKJeokEiX2KSxFqJNRKNEq9JvC7xhsRhiUKJYokNEhsl3pS4W+Ieibck3pZ4R+JdgYg1KfW33d+22xD7b7vvd/4gZ7J8u+xWHNC1ekK9IC/kgzIhP9Qb6gP1hfpBA6AANBDKgrKhQdBgKAcaAg2FhkHDoRHQSGgUNBoaA42FboByoXHQeGgClAflQxOhSdBkqBGaAk2FCqBpUCFUBE2HZkAzoWLoGOSBjkP9oRPQSegUNAtqgUogF9QFnYbOQK3QNugsdA46D22BLkAXoXuh+6D7oQegB6GHoIehR6BHocegx6EnoCehp6A90D5oL1QK7YcqIAs6CB2CDkOVUBV0VCpiTflv/HnQbrXiMfsyv3q6xD4+ZPzaeRN7euaH7g4xb5KeSfnfO4GS/gGB92dS/i/OpESsqbJJ2oz3MrR6Qr0gL+SDMiE/1BvqA/WF+kEDoAA0EMqCsqFB0GAoBxoCDYWGQcOhEdBIaBQ0GhoDjYVugHKhcdB4aAKUB+VDE6FJ0GSoEZoCTYUKoGlQIVQETYdmQDOhYugY5IGOQ/2hE9BJ6BQ0C2qBSiAX1AWdhs5ArdA26Cx0DjoPbYEuQBehe6H7oPuhB6AHoYegh6FHoEehx6DHoSegJ6GnoD3QPmgvVArthyogCzoIHYIOQ5VQFXQUWi0VsQrkVw55MPD0YODpwcDTg4GnBwNPDwaeHgw8PRhcejCc9GA46cFw0oPhpAfDSQ8GkB4MID0YQHowZPRgyOjBkNGDIaMHg0QPBokeDBI9GCR6MEj0YJDowSDRg2GhB8NCD4aFHgwLPRgWejAs9GBY6MGw0INhoQfDQg+GhR4MzDwY/ngwUPJgIOjBkMqDQZsHAzoPBm0eDNo8GIZ6MITzYAjnwaDUgwGrB4NSDwalHgxKPRjseTBE9WBQ6sHA04OBoEcPR6bJefFv2mfIkJgvsUDiaYlnJJZJPCsxUCJL4pDEcxLZElUSQYk9EjUSKyXcEqMlciVmSdRJtEiUSLgkVknkSTwvsVriBYkXJV6SWCdxSaJAokvioMRlifUSL0u8IvGqRJHEEYnZEnMk9knMleghMU+iVGKhxH6JRRJlEoslyiWWSFRILJUYILFcolLinMQKCUviqESORLXEcIm9EiMlaiUOSNRLNEjkS0ySWCuxRqJR4jWJ1yXekDgsUShRLLFBYqPEmxJ3S9wj8ZbE2xLvSLwrELEK7ZLXT434HnU7RxRXMJIhDldXMZC4ioHZVbT5V9GuX0W7fhXDu6sYEFzFgO4qGuaraEuvooG9igb9Ktrnq2h8r6LRvopm+iqa6ato3q+isb+K5v0qBhJX0YRfRRN+FcOKqxhyXEWbfxWDjKsYZFxFS34VzftV3RgW2a9k6nFdwvN4Ca/UJbwal/Slp/83zsT9Xv5eyZ6Jm+np+AOcd/vlbx35X/aHS+lZtuu/tOa66bZf8w01v8V0W2pOLT3bdv1XzKTn1NLzbunptvRk3R/ddNuMP7Z98b9oF1S7uPWj93fF93fF/7ldcaa9K6bmjVZipmglZpG0aqFSaD9UAh2AXNBqqAKyoLuhLuggdAjKhg5DldA9UBV0BDoqFbGK7efxq+rp7ZUqaRvtl/JramGsveYFtfBYhnNfXMFSd8d7fetaib3J2Wu+rhbetBf2qIVJGc5tu4K32QtvqoV3ZH17Vq34hwxR6NK1ca9a0STrXKq+pcuaXXD/2b7sLHXKyF9b59Jl7SV1Si+V31CZI8rcN1UOUHlFZYnKv1H5IZXfUhd8XhbIb6vM6hBV8DtqxWBnS1OFxT5nqgoWqRym8qrKcR3Xv++XKnb7Vb7aIQpsqup1qRVjzDfgOGUv/S1v6bqXOrT8rcrxHfaA3WVNcDYgl/Xjjmv1MH2geVWtmNIhCuTfqRXzOkQVTBe/v1enLOxw3nW1lnTYMx2u4HPuDlHWU0eef1C5tEOUwu+qhb32daRrYqpip46J6fKZLo116pTyjmuVMV0H01X0H9Upyzr0caeq41o5TFfB69/2u77W/ZNd2uw16Rr3PXU1Gzrs8YjLWtkhDgPfVytWdThfDGitUfkDlevfo4C9rHKjLFx2JbvJ2anV0dVe8YpacbPKf1a5vcMejLqsHR2iwl1SK8IdosKl24t/UafYO+wXVUZU/lCdUCi7jH9VKw7Yj+NHasVtHaKHSDUVP1Z5R8d79RDPqFM+2iFahnQ/8KI6pUPlT1RO6xBtwE/Vik93vMe3/f2bWrHPXvHLB/vUQT51UE8dzP9d5Z+o/A/7pbEf0V+qhbXyaJ46eP9M5Z0d4iD+c7XiGyr/U+VnOt7roP6aOuWzHb/2CP4L+3bthcNqIazuedDlVpf6fIc4gh9VC/fLA3fQbZ/nCx3vdeROH7CfVmfZ12FPM7isro73+r7G9BE3deBOH6+vexc6dQhOH2h/9bE4dQgOeuw7ebjjNx+LzbE3mGFf4Lha6GEvnOqwJ95c1tmOa8fe1J/tpw5+u5zDiFsqYs0yX+sZLMro+J2/1/N3/DrP/3/f4pl+Ma/vov/rv8XzD+HLO9NtXGq//kP+8s4S+XHWgc4WmQHNhxZAT0PPQMugZ6GBUBZ0CHoOyoaqoCC0B6qBVkJuaDSUC82C6qAWqARyQaugPOh5aDX0AvQi9BK0DroEFUBd0EHoMrQeehl6BXoVKoKOQLOhOdA+aC7UA5oHlUILof3QIqgMWgyVQ0ugCmgpNABaDlVC56AVkAUdhXKgamg4tBcaCdVCB6B6qAHKhyZBa6E1UCP0GvQ69AZ0GCqEiqEN0EboTehu6B7oLeht6B3oXamINfsOe3LcFRyeYf8q3Rz5p2VVHrkFa/WEekFeyAdlQn6oN9QH6gv1gwZAAWgglAVlQ4OgwVAONAQaCg2DhkMjoJHQKGg0NAYaC90A5ULjoPHQBCgPyocmQpOgyVAjNAWaChVA06BCqAiaDs2AZkLF0DHIAx2H+kMnoJPQKWgW1AKVQC6oCzoNnYFaoW3QWegcdB7aAl2ALkL3QvdB90MPQA9CD0EPQ49Aj0KPQY9DT0BPQk9Be6B90F6oFNoPVUAWdBA6BB2GKqEq6KhUxJprV197VuMjGU4pcgWnpibh+nicAuQKrvA4VUO17x5RWn7klgVDayyUC42HJkBeKA/KhCZCfmgy1Aj1hvpAU6C+UD9oKlQIFUHToRlQDjQMaoEuQOeh/lAXdA5yQWegVugYtA06Cx2HPNAJ6CR0CtoCzYJKoNPQRamIVSo/2Z/tbOZzoAxoLlQKzYN6QPOhBdBCaBFUBi2GyqElUAW0FFoGDYCWQwOhLKgSWgFZUBWUAwWhamg4VAONhGqhlVAuNBqqg+qhBmgVlAethvKhSdAaaC3UCK2DCqD1UCG0AdoIFUtFrHnmB55PeexWer69H/SyJ30yOvQM2B0ZHWJyLD3HY88v1aqFYE+3Wvo45vzusmdFUm/HxjAp1lMtfNWe/etlX+xR+7ShaqHY05GejAl67ZO+5+4Q01A32HNp7z1nlSr8/Z0H54MyIT/UG+oD9YX6QQFoIJQNDYIGQznQEGgYNBwaAY2CRkNjoLFQLjQOGg9NgPKgfGgiNBlqhKZAU6ECaBpUCBVB06EZ0EyoBboAnYf6Q+egLsgFnYFaoWPQNugsdBzyQCegk9ApaAs0CyqBTkMXpSLWAvlHzV8Xx0ON+RILJJ6WeEZimcSzEgMlsiQOSTwnkS1RJRGU2CNRI7FSwi0xWiJXYpZEnUSLRImES2KVRJ7E8xKrJV6QeFHiJYl1EpckCiS6JA5KXJZYL/GyxCsSr0oUSRyRmC0xR2KfxFyJHhLzJEolFkrsl1gkUSaxWKJcYolEhcRSiQESyyUqJc5JrJCwJI5K5EhUSwyX2CsxUqJW4oBEvUSDRL7EJIm1EmskGiVek3hd4g2JwxKFEsUSGyQ2SrwpcbfEPRJvSbwt8Y7EuwIRa6F82+ZTblHzjBZAT0PPQAOhQ9BzUBUUhFZCbqgOKoFc0PPQOmg99DL0CtQDmgctgsqgxVA5tAQaAC2HKiELOgrlQNXQcGgkVA81QPnQJGgt9BpUCL0JzYeWQc9CWVA2tAeqgUZDudAsqAVaBeVBq6EXoBehl6BLUAHUBR2ELkOvQkXQEWg2NAfaB82FSqGF0H6oAloKnYNWQHuhWugAtAZqhF6H3oAOQxugjVCxVMRaZNe/Y6p6PNRht5gu64UOuyl1Wffap5bJX6T8NGZIPo15D62eUC/IC/mgTMgP9Yb6QH2hftAAKAANhLKgbGgQNBjKgYZAQ6Fh0HBoBDQSGgWNhsZAY6EboFxoHDQemgDlQfnQRGgSNBlqhKZAU6ECaBpUCBVB06EZ0EyoGDoGHYf6Qyegk9ApaBbUApVALqgLOg2dgVqhbdBZ6Bx0HtoCXYAuQvdC90H3Qw9AD0IPQQ9Dj0CPQo9Bj0NPQE9CT0FV0EGoFNoPVUCVkAWthvZA+6C90CHoMHRUKmItlp1qAJ1qAN1FAH1rAH1rAH1rAH1IAH1IAD1tAF1JAB1uAB1uAB1LAP1uAP1uAN1MAN1MAL1wAL1wAJ1OAJ1OAJ1OAF1zAH1PAD10AD10AD1RAD1RAP11AB1SAB1SAB1SAB1SAH15AP1SAP1SAP1SAP1SAP1SAN19AN19AN19AJ1VAJ1VAJ1VAJ1VAJ1VAJ1VAJ1VAOOHAMYPAXRdAXRdAXRdAYw0AhhpBDDSCGCkEcBII4DeLYDeLYBRSACjkABGIQF0eQF0eQGMUAIYoQQwQglghBLACCWAXjGA8UoAnWMAnaNWPdQA5UOToLXQGqgReg16HXoDOgwVQsXQBmgj9CZ0N3QP9Bb0NvQO9K5UxCr/fXwH/zB3x3t9ju6CWhj9R/uBuvc/SPf+B+n+hz5It0Q2Op1odDrR2nSitelEa9OJ9qUTDUsnGpZOtCidaFE60YZ0og3pRHPRiXaiE+1EJ1qGThz6O3HQ7sRBuxMH7U4cUjtxSO3EgbITB8pOHCg7caDsxIGyEwfDThwMO3Ew7MQBrxMHvE4c8DpxwOvEAa8Th7hOHMY6cRjrxGGsE4exThzGOnGo6sQBqBOHFa350DLoWSgLyob2QDXQaCgXmgW1QKugPGg19AL0IvQSdAkqgLqgg9Bl6FWoCDoCzYbmQPuguVAptBDaD1VAS6Fz0ApoL1QLHYDWQI3Q69Ab0GFoA7QRKpaKWBVy0u1OTLrdiUm3OzHpdicm3e7EpNudmHS7E5Nud2LS7c5rk26fd7ncLvtfenUfnKkv1A8aAAWggVAWlA0NggZDOdAQaCg0DBoOjYBGQqOg0dAYaCx0A5QLjYPGQxOgPCgfmghNgiZDjdAUaCpUAE2DCqEiaDo0A5oJFUPHoONQf+gEdBI6Bc2CWqASyAV1QaehM1ArtA06C52DzkNboAvQRehe6D7ofugB6EHoIehh6BHoUegx6HHoCehJ6CmoCjoIlUL7oQqoErKg1dAeaB+0FzoEHYaOSkWspfrv56yx9p/PLZMdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdahQdalR3qMtl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SgFspQC2UgBbKYCtFMBWCmArBbCVAthKAWylALZSAFspgK0UwFYKYCsFsJUC2EoBbKUAtlIAWymArRTAVgpgKwWwlQLYSgFspQC2UgBbKYCtFMBWCmArBbCVAthKAWylALZSAFspgK0UwFYKYCsFsJUC2EoBbKUAtlIAWymArRTAVgpgKwWwlQLYSgFspQC2FgrgusHnT18/VAX+JN8HJ6fA4l+48Ivl/GJ9smqwhOZ3EZryqbI4ly5uBRQ3CYpT7p8ysh7+mcXFIXZx12H4ELs4qB8+xB4+sh6+FTF8x+GnTLGHbUIUNxSG70YMP4j2TwZ+sGbErs86SVX8xOBh0/DiXHv4NLw4BC/uZhSn4T97CF6ceRen4MNOxQ07UvWztkCGpuM/fjrux5+YNrQF8rmn50NbI8UpenF6PrQnUp9cz3LexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLexXLeVVjOq9k/HDMyfEEKqkALUBStQotRFapGS0PVJx//zAdn5peN7+366h+g+Qs9OHPDr+LDV/KPM/nwqz8yMZQThnLDr9gTNL/0j9Qp3ijFUDj8s3SG7qHiDVLMjcVwOOyj678x5+03FqfYz+ef/TAx/6SGp8N59sCLkf+v5H9qKAm2kARbSIItJMEWkmALSbCFJNhCEmwhCbaQBFtIgi0kwRaSYAtJsIUk2EISbCEJtpAEW0iCLSTBFpJgC0mwhSTYQhJsIQm2kARbSIItJMEWkmALSbCFJNhCEmwhCbaQBFtIgi0kwRaSYAtJsIUk2EISbCEJtpAEW0iCLSTBFpJgC0mwhSTYQhJsIQm2kARbSIItJMEWkmALSbCFJNhCEmwhCbaQBFtIgi0kwRaSYAtJsIUk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/++OSfwMr+BYlC9LNEv5UBIaCA2CBkM7oSHQUGgXtBu6H3oAGg6NhMZAY6FiqAKaAE2C6qFKaDJkg6ZC06DpUBRqhcqgPdAMqAfUE+oFbYF6Q/dAfaC+0GZoL1QI9YP6QwOgIuheqA3aB90HDYM2QSOgUdBoaBw0HpoITYFKIA0qheogO7Qf0iEHdAB6ECqHGqEmKAJVQc1QNeSGtkExKA7VQLVQC3QQOgQdho5AR6Fj0HHoBHQSOgWdhlLQGeislN/491w/9edmhn9N/VT3NXlr+sEk87teX0P1Wvqo9IfTeW1EWNRn3auvVxgG/64bqq+ahcZr7axyK3qunsst9l9JP7gie/GXX+NzS3pukc9VhdlqsNti/9s6qjevk7pNB/Ufcv7sfvzh8K03Kc5gicRKifkSGyQ2SiyWqJKokaiVqJZwS8ySKJCYLdFDYp7EXIk5EgskFkosknBKuCSKJAZLLJUwJJZJjJJYLuGV2CqxQmKVhCaxRqJOYp3EeolyAb/xnygenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenSgenVbx+F93xhEOcxx3yvzeu2c5wq8weLt7hMP9h3uEw2/8PPvOu27zN2drm09aV2oX9tlexML3IhboF1G4vIjF7UUUBC+i3HoRC/uL1q99CS/deSQz5C+A5kBzoXboHOSCnoAGQYOhGHQeGgLVQgbUCHkgL5QHjYGKoQrIB9VDlZANWgVNhi5Aq6GL0CXoSWgddBmaDkWhbdBT0HroaegZ6ApUBm2HZkKzoCboIagHNBuqguZBzdB8aAG0EFoEOaFqaDFUBC2BaqA2aCnkhlqgYdAyaAQU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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'eJzVXQl8G8XVj+8zce4DKCGGJE6CY8IRwDgJsi0nYjWSkew4IU4WWV7bcmTJleQkBgdKS0sBl0IxUMpVCqWlF22BUnrfFFoopfSm90lbSm/aUuDb1a40szM7o7XeruGjvybZWc17/3fMmzfnvqHihpJ5JfO0/47ONEnaH9PliciYMjNd0eUPenpmpqvGI5mMkkrMaO8qDkXiE+rLNU39g5ua+jf3D27cMKX9tWlD0z7Fu3/fpub9O7SnHSqBoXhkOD2zf2a6LBU5PDN9YkvBSi0z05Xy4dhgZkSt1iSVXlXxivrfPGW6WpYzk+OKLM9M13TreELemYnp6vFULJmKZSZnpHkjC6brepTUWCwRiXcqQzMTUokKeaR0urYz2CGHe0K+wM6ZkXKtrHJ6dWNjY9Pmqdqp+Rs27lD/PbV+/fr8s/rvmZHq/TMjtdNrW/Qf9iem+lOmn+ZK1KeWmZF6DW9lDu/IgpGGiZGFGqaRRRNSqY6jqntvwO8LePMglrW2jk+2tub56o851qta8q9zvPSCHLt6DrsynV0lJfKSxn0HGufX7t+oSrDvwHrtX+sxL+1lf6o/kXut/zsvWimHV7nOq7w9GPTnOdX2pCaUqa5IPK3kGNS34LIczXKpIk+uRCdXYUCX+uSAL5AnWN8/kEhm+tObYon+gRzJBS1kKdcGBuVKTNkXNlGOpVUSGiETZVxaiHKVTrlsl3dPnuziU/Yd2bN/3ynNZ0eahzzNXfL+TTniS1vYdzkWZRwtVxss2gmd1J2yb6BdJbOFoD2/hSgsRLTGIBrs6MHqOGVfMqhhO5OguqCFLC1EttYg6wsQZDVpsyLL+zdismRpjmwJh2yd4WiBXj92tPJAMpF3scoW7Qk7VzltqHojHEh93nCHHPAg3BJXtm3fF2m+yNN8gbzf+IcZ7DEtvF8U0sf8HHCS33Ixt5UtYl48JS0wJOzZ200HvLJ0JpUjX9GoPjTOqAGz1gimYfUlQafBCFgaHdKOZbFEBhNRHzQiI2mi5kK9Zo1WU+9AcnXV7iAZydeuasw+MvUX6fWrtfp+XxhXL4/H0vnalY3aE1N5McG8p7fbj/VdkZkYjyuYefaRqb+EEDvsJcROK4TY6gNTcykBu9NHNKjywViUgK09MZWXEZVNcbR8IJmM48raE1N5OSFz+94ebxjLPDCZUdJY5uwjU38FIbMnsBfLHElMYpnVB6bmSgK2+n+s7HKtq8awtSem8ioDthqOu0Je7wVE7aFU8iJcW3tiah+j165Ta3vaVUf3EBoviwykCeADrMjHYt7B9vO8ZN3kwCiuqz4wdY8z1KXW9QZ6EUatJCbGMGrtian7Olw3EOwkJE4kBwl9aU9M3eMxZt/OQDCEa1fGhhPJVL5+daP+zFBYbZhLpbDbF/YRDfNQLB0jGmb2kal+Qj54yiGvmUBVSjGRqGk0ChgiazCGcLenD3dmFenxyOEExpB9ZKo3YgX2+Xp2YQUejqkZY16B2hNT90TM2hvoCWFHr1ASmdQkZp19ZKqfRNh9DyF7uXIkRrRv7Ympu5awHeoOhnoI242NJ1MZwnbZZ4bCOqx8X6DD30s4T1UsEY1PYP+paTQKGCLrsQhdoSAyNbgxU4NjXbdJr1uhNTgcYUoj+ZZW3hhhG9oGQmmdOwmHVwaHCYfXnpi6G7HS+jx+yRvCSjsciR9UUlhp+jNDYRO2uCe8N9CBLR5JTyai2OLZR6b6yUT1Pg/ZXiKHI2R7yT4y1Zux7GpQJhxGDcKEw2hPTN3NWHZPOOwlHSaSTiukw+jPDIUWbC9fF7ZXbAjbKzbE1DqFsJefqFeuxHFN1V5xi7pbyLph0tbEKECrm2ZtfSrOzbuC2NBlQ0kiZVEfmIqnYTF7gljMTBKLmUkytU7HtdpxHCgdmMS1BtgIcAb2h75dPjK3ODwSI3OL7CNTfSvusjqCgR5foBdTqI4mE5lYYiJPpLYxV8LQORPDaA95PRLR3aeUyEGiu9cemepn6dXr1eqdvrA3sNNDtMuawVhaSQxHcOOsa8wXMaTOxkj2+rz+ToxkMqbEBzGS7CNTvRU7TFjydWOHSR+MjWOH0Z6YuufgBhLymiNqSjFHVP2ZodBGUujpDQVICpmJVIKkoD0zFLZhCp1ev7cHq7FsUIljv1UfmLrbscOTXVEZ0RFVNFp1QzswU++eDm83IbhyJKqME4LrzwyFc3FX0uULePx+zL5qSJs6iU/irsQoYIh4sOlDHh/R2itSkViaaAvZR6Z6OxGdAkR0ShDRiVV4B1GL6INiRB8UY/ugTuxm3SHfbuxm46nYIexm2hNT14vN1N3bjs00PjGAzaQ+MBW7SKZBIlMaTyUzSpTIlIwChsJOzHoX0eOWjUSI5HbEos/dhT1kpz/Y7iFGE8Px5ACWWHtiavsw2w4PNk1ZNJLAbNUHpuJ5mG24x9Pjw71tZToTycSi2DH1Z4aChH0KeXo6cHZXMRbJREewT2Ufmep+rPIOD9n/RCNk/6M9MXWRUdcTCgX7ZKyxsrbm5rzYLepDfqwvldFD74CJBtGJNTdvxzTUBwGNoKECnUa7DwvRRlCp1JBst5rnMMh0G03cEEfu3kIS6t9HEurfJ8BzvolQSO4+FYu1nxRrv1CsEI0Hkyndn1dwuUolP9soldJEwjSWLYSKsUyqirFIFmR6DBV30LauaOvf1J+f8qpqyT4KhOo1E8IGr9AqbseEso8CQruNxKDDwlxZUPvMoEQG6zPTMlmsfD8Bq7JlvxjVHgYVaXusqAqNkEDfexlEhDOSwlW2kLJZULrAaGC7vCGvHMT5Qm3byPapthElpeSlq2/BZVjGSpriPoNi2OvvMlNMq7XTSnyIpJgvE1DsNyj6Ar4eM8WYWjuWiGVIivkyAcX9Rr7WHQz3yDTZhW3jGo3xZDojm4gvbqHf4HBRR7M4YHhyuLfbGyLJz29LT4xrUk+MK6k87YYWU3GOcIVURROWDW2EgkFKGym1eiqZNGkjXybQxoVGL6P3bCTN+tbh1qlWrU+LxPMrKAtayFJMt5qmGzG8NBAM+IMdZsoNrYm4SiSRTMSTUYL4ohbqBVZxLU1/wMCtj2TNuA+rNPQRLImbKBXgjhoa1qaTTBpuTWSRDSqtWMO4TKDhQYOiNl43U1TU2tpInaSYLxNQVAzZ9ak2kmZNa1KtnxwYzZOsa8kXYYoVNMUhA6M26WjS5YVTrRm1ujbhSOiSLM1PoLM4h3OSB3oRSbWyVZvMy9OrbtGf86tCLKWRXFfV7vP7evaaRY6qUNQEihQ5VyQQOZYjKXf7VKG7+vBoq7R1O+5CW7cLIuio4eUGkXaJpNLWiqm0tQqoHDTCBQOkrH+KSAnUBwGRuOEULJCytv4pIufqnxJQGTNM1qnGFzOSzSSSzSIkCUMcjQYNZDMJZLOASNLQrD6UlHeRayalzYR9mkVQxg0oXv9uX5j0mrL+Ha2EPDtE5nl9LiT0+tUwhqcHSvt3YBj9O3BDKKEppAzbqFk46vXL3vMxjXO3YRrnbhOgSOe06u0ImuJdybk5CmUt5wpAZPBAxBPARqlct24qkhjEjVF/xkhwImMs+k0czY8aiamlqv6p/qkpPL1U02IUWMlkUDpkQPJ0dpJKKevftI0wziaRWg4bJMK97Sa9NhN6bRYROGI4mjrGUlMpNaEiqFT2b1T/tw3rRn8WJHmTBhzKzGX9G0mJNooAXWTkJ13+oGroTt9uklBFf0t/S56UmgprjwI8Fxt4KDJlBJEKkoQFnqmcSEGTkUrXEhpeKyJw1PD+9qzjmWisI2isE9G4xPD+ds3nzJJMkZJMiYhcioHsoakcIKkcEFF5A6YSUCMcKc4lhDiXiGhcZtDwh3f5ukw0ytraCCTqg8C4bzSohFgq27cTVNQHAZU3GfbVsRDdVxvRfbUJhLncIBCiCGwnovR2UZR+s06gzE/M+JW2EbpsE+nyLUbtnWTt7UTt7aLaV+i1S4k9RKVriMprRJXfarAOEBNSFWumEkm8ltGSfcRhmYmmV+JENtQbNrlTK4GjVYTjKiMidwT9QTzFVNKKO4ZWQcdwdc4B2kOeDqyGkotx9YsF1adz5qeqH8XVjwqqv02vXh72Ijw7U3IOrnyOoPI1hvW8hPW2EVrbJtLa23OVscpLtmG+2wR8rzUM30kYvhQnN2o6sFlQ+zqDsR9XLmnDjNsEVd9hVN1JVN2Oq24XVL0+7yQIeXDtk3HtkwW1Zwwzdft7iZliPGuhirxJUP0GgznyBYj6Jc2YebOg9o1G9M/10cR8h9ohE/Md6pPA4DeRZNQempBjIyHHRgGSdxqtNd85E1DUfpSAov5PAOXmnAMRFEpx/XKitgWKdxm11S4Z63It1uVaQd1bjObabk4DS9bh6usE1W81DNluSv5K8QhDhT4lqH8bZr/HROAAQeCAgMDtmAAZdksuwfgvEVS/Ixfsuj0hL7FS0t9E8G8SEHh3LtzRBDYQBDYICNypE6jyh8/v9RC7TkrxzJ1KYZ+AwnsMCiGGwn6Cwn4Bhbt0CrVd4Z6QtrpALPeVagvR+RXi/kY8tW90WHcbrShb10u6UL5ieSNZz+D5XpJnt89L9BU1+w70X9x/tBFvkKxv0Yv6G/H2SHqL3nnak077nlyz1Gi3e8PEzoSLL546ehR3x9lHwZDkfYZutSjpJcacS07s35jfVdy/8cSpEzfnY8aKFv1lbk+x8brQ1sL3G7G8DwfE+qYdrftOqKmfX7t/Q04XAY70L+elv1etPF2ZTMWGYwkjTtfGI6mDm+PKESU1M13RkzyoJGau13aih3r9XrUknYmkMjPSPM05MjMhbeNiXSCZyG32npmYrlGOjEcS6VgyMbPfIFo5lhyc0NblF4ymy+fNm4hMVyRTgyoHad50RSQei6RnAtNVyfGMWimd3dzecFBRxuVIPC5nNAjpmSunq7J0B7fMXDmyMDDdkFHGxuORjCKnkxOpqKISmK+WZCblWGIwFlXSMxs0aCGVbdCgO6EWlGsFMxPSB1Qmo6Pl2a32I6WjCfVfTaNJ9c88VqlBzXkNEXXUoxn1T1WjhqEHk1E5ExnOvzaKlbgypmhbM03FDbKs05U1Bcqn5F8ro0fUv6R5o5PqX4HRi3RIo1Pq31eOHtX+VKUdvST78lL1T1Wq0TdoFdW/L9P+lj5oFuUt6r8sEY9eSbzRS64mSgwgJcUD+ZBdIFczQN7GAiktHsiHCwJhcUR0rmXFc/1IQa46i/LiWdxnU8M851xoOKesbcuT1d/MFDRDRfFoP2rXH97P+MMHWCCVxQP5mE1/IHEY/lBVPNePc0MMawZpWqp0ItjAo8n9XNR5ZtJ9UrUlWB3U/PFJOZocVOSBeDJ6cIZSKADaA2Zoj3DMOF1v7LpUQ+1YhuYPiG8P2uRfp+8ctWQPiGqfsMm+KjIQi2vHsJwLbQ/ZZF0TSUVHYvqWczNzQND7pF3mQylFyXoezRwQwx62ydzYSmrmCwhZn7LJt1ZfUJUPRVI0d0Do+jQ3CJD8kJoDLhJFLeJEwXTtUCyeUVJyciKjJnALpqtxxmhIEomqWVvaIso1RNLp2HAiGzH1kyem1/oE0OjLWcEWjL5S7kgc/IxZBf9lDWB0Xi+pD2bmenlZBd2pVVTQv4TnXJ+1CZPchGaFtoRBOwv8gKD2ObtqXswwnzVMQAD8PL9BEG6Lri2RFosahDHPaiEH3p/otCN/wQy9sYKn4bXWGs5vuXTadb8IBZbfR+q0U36Ja209zKMvlkhLhOla7qSBFWz99KHVm1qLtAnuAF82S3MOV8/bOU2svcLJUeJXuMolOnD08xJpaSENZ88dWekRHyyyfJueGJCz5+rN/Yg72v+qWdwAV/vnc7Qf5pT3OWqVr/HT/tzQAy0qlZYJ8v7cGXczWHja/4gZ2iCrQcN+xNUClhgA6vk6Vz3UaAedWiotFygpf++A01p6lIvQNBxB55VKKwvlbMbJuNk0nvxJNqtKOQTjEe1ooKmesahkVaveqBXLKGPpOcn5HjPrcIrXVotVkkAPAoEAbvsNrlOYx8jo66XSsSKvIE87ui8xwITfLNgMslDQi6XScSKBswu0VpJyX9Ro4g/KKWWIEnSpLBOs9fnfLXQz0A9z2k0X4Hp63KynD3G7pfs43c/HOOX3M/n4g452VE/MHfCHOL982IVx0LfmQiz4OOhJKEyxexSpd8Dk0rfdFQg+if6U8wBnrV/APNZ3nISvgCe2nrYLxxU/rS4e+HedAW4AqSkeyPeKBzJrfdUWD/P7BWGyKI0kvK54rj8Q5FtkMovOKZNeJ0o/luVzhmwFPWk4lZNcaT9xcMT6Q7MQDZUc1S2tZFQH6Nd/VDBxy4qJRsuk44XjF14aNucp1o/NEq3m6bHRUT0+w9UjsTiD3l4mrRbm+4NKNJmKZJIpZuSlX67jmLf9xIx3C6slI56cXknFk+n5eYHkQcLc8Bzzp8VjWkBiisZpUIAM8WcFQekvtrLuBEj4fm6T6zaWKyAr+4VNrp0sV0Cq9Utu06Gtip4ok04QRiGtgmxaCDUaFneViz8t3BBLjCgpNfwNyhpZukXWjyljA0rK8ZnLX5nVsZfbCvrpVjB6gCm5sNK67x9gWpA7MyG/ngthBiuZTAvQ4H8zF5ATTDl8kPjb4oHbdhMrXQMCzu/mAjJX14CY9XvngVtoFjAAfNZ5gFw9AgaGf+DGfirLQCeUS2tEoX+xtv1GziSzsVqOjkS0q3TmJGD/UZz66d0R6i6XThQsUBCXvDm9RPEnM74Pc3p18jJIp9dxnrMJIX9NniUAQFD/8ywAZC+mtAQACM7Pc52EzPnR3eVSk8BLlsgy/rU8Hp9Iy6c5uNPvL1yQTC6EHiuXNorao3ZYyiqrWqkOsc209FH26XRrVWUci0UtW7J2msrpYeNfzbJ/mxswn+aExx8wgfRHvIAJaEl/swlTsOdl9HtM8idStiUheJr1d7v6/h1H339g9P0nF5Kqf3CbBF57Q94KqbnI/UfuzIH8k4u6KpKYzM7SoH0VUouoQ2IndOAB5l9mXOVVnDBcne04LXgDWs4L/G4ai4reWCGdKtBKXXpcicYicYf18m8ztiU8vZD3tjvdR//HJgYrj4V30P/lWsekcvSFCmmraJ9H7n4op5OoF834mnjaMd9S5bSN/mcTRf6+KafN9JJNAPgmLacTqZftqiB3pZklAMCY9RW7AHK3tFkCKH7sieaVcNuKPkuMzquUtgkaSbX2K9PcLbh9oBIKVJCnlhqDOTFJC24XqJSvEoIfOlgpnVtod2P2SnvLXaLOTyHWZrE5PB5FZZQyDrCmMFKrSJV1ahWtolMrhfPLYfqX7swjovI5lClWxUzEFB8xUcUcIk8z5eAEGFWC8dv2HSvNFx+oUdUcIudqHhDnq13Db6Hn4qcaUY1rOLlaLX7GEdXyuwrcL6IHKiWPeLYxO7OXlLNVrIbN7sT2Oj56kiF6plJqF+HP3R1k1WktkWVMSp+cOYMSTu9UTQctDbohK7pwuespuT/O9bEHOb70MNNmP83zLkA/NR+Mk4sK0ActKJQe6buRV1RJnSKn4ec52pVMljmTcmQ8pSZN2qUUzjWCBkqcJ4oYqgJsvNAue/GJbIA9F/HtmT+FjOQqaVdxe03qDBpW2zsAZltMof4dR2+jfyJewM21pDDbghrBH9CxPDGB9eXk1hO01C7y0f9wgsmLbEcPSAWXOaBJoa4Ayd5yu85VU+3g3hW0gt8SzZKiJ6skf6EDQMZnI3inQbXPUcxuZJqf7aW676GJRNRsAYOSG2fx0EpKSUureX68otraj1dxyo+tpjv11zElq+kSl4aoq15NKafrlUPaOf1oPDKRpjY/ja6pdnJAe8yras2tTMnJDDV4pDvWNRlt+KeVvQCR8bhXVRaudQBB93VzKBHrbxbWAQyej39VZeFaBzDAXm1bIkejupVdij/4gU54laTgWqT4syNozZzIYqulFH+0BDW+SlJwLVL8gRV0IliWIltEffGYT5oTzFxtzy8e+VoXkNvy9gXFY143J5i52m4oHvl6/pDINLGATquWkK051uzOTqs51jkexzRRkt3HtcnHZ5Wff4L1HMA4ZANf/wsjA+lMKhLNyPlZoslqKfCaH5aaPnJuuYvKjUsN0EZKk1/h2vsRTht8lFP+DaYlPj4rj/k2h+53eO0Z4E+bXNMCI/Pot5iSWUsKGNmePIeS/gQuKWB822xbUoAHO2FNwLh385zI6IAdASPhFrCMrlgNMB4+xQWJHLARYDy8RTBFbArx6CfVUrDoy9esltpwNe8en3XP2aB/2jt7SMXUU8O7z1MpwVfX8EzZWGNtjpNqaMOtY34J7+BOcx6n+Cq80aYaJuEDdFunu6DnM3l6BnQ6Z4Bxstbn6hPQcWx1ASc81J8JRsXalKs9QAA/ywWc8CB8tmAHBB51oLU1Urd424z+ERmrSLowT0cej6QizN15uQ/QzHEUbqUkl7n2GODYY5CJDkMuROFzwDhZVHr5iKPRts0FnPDYuq0wKlYZ4L3waHthtuDAt0Mwn8E0OTRYI50vasGrZJmupG9x20pPRmRfmi54hzfGcylZruaZ6VrWTIC25RFEPywmur5GCol0hz/nZvckm1GPCWt6+dzuGmunlHALt+Hezmm47+aUv4cNMABjddjFSXwXr1i0esndnF/e42jg7LSt//vh+geEUq9tnK5oGBCNuxxFDk9ZdwpGvqa7GNDTNVK42O3Ky2SZJKZH8zPnaF/yLkrEp7gq/y5H5T90IZfyCZZgDF3pO35fqpF6ivj+EWdjK1yd51HAf8NV5++ZITe7uOFcTJYAuJjvAsFDqR8Ax+JbQfCYiQCAqkciafNRAngkDEAUxH7PCB4Kg4UB6S/+wCZ+gMF4t122f2XZAkbb59tl+2+WLWDPTsgu21dYtoDtNWG7bCtrGbaA/TA9dtnOZ9kCtq708vsW3JJRtFbqBSwrE1+wmt3KcoMGQf9u1Zx9swrtplSypZYXbU6vtU4CtnLKW2vpTLKN+SW8d+uD4s9uA9hlfcvr6FmMDLOQCtBJ7gFbRYJbBdCn7rWNn+c9IM0Det8LwMhngRPQKe+zjZPnCSANA/r1fjDyWeAEJAL7+Z0FE6nRR2ql3aI+o0BsF3zSZqGW7g7KWn1qOw08+B+gRLyINYX+4jK2GwbEbFkwK8pIi56tlfqKur37tTF1dyEl7DTX3d/OuPV1RAm8q4wIsp+8qtDqOmlPkfeBuaPAAUE7pJeeUGudtFeEvi7k7ekNBeRdvoD1ngJ3ZIgKZpMGJmLxTCxhXLUZrZP2ia6/6dnbLav/d/xjYGiQgvgQJxZMV2kQPAF6dwA8LCh2EWSV0B4M0nPH8MPJQ7OC0OnjXTcKSJ2GZ2WHsJeDAJACjdhFUJN1xt5uP8cbAelNbFaG8PuY72bC5x9GZ6WGLn/Qw8EAyEEOzsoZ2JgGn5eIz0oL7Xt7vPRICj5JMWYXQ222SQg+5wiYskjwQzi5Yx9F66XhYpcDFqQzkYzC+2i1W+sASUqy/3EzlFc4CXlZnfMD+3G+vmk1obfVSyOCTnOFLJtr6LcPn+XgFXKvF6xS53nPoHvrpVEBUPGlGwB4KQreyjpOC6o7HIkfzC2xOJfxpwvzzyVoRkpncT+PYAIM0OVnZgMNfxTVNjRAKjBhH9qgElcyyiyhAXKEQ7ah1UQzqfgsgQESh8P2daYOx5VZmxOQUByxDa02FYmlZ2tNQJoxaTc81ByOZT9HygYHQIpxkV3utYdHYnHFkj0gu7jYLvvqoaR1YARkFVO2mWdSk5bMAcshR+0yr4oNWfIGnMi9xH5j4B4OEDQGwInbS+0jm4wp8UFZw2cfGeBc7RvsI9OnGrNJh21kgHOzl9lHNhxPDlB3kBdEtrB4ZG+0jaw+kUyoaddssS0qHtub7La/Bn1WNJo5Yp0ZLi4ew+W2YwC9FcTgvaR43m+23e2w+z4M7kuL5/4W2zmx8TFJqwi4rHj+V9ju9sYimah1r7u8ePZvtcveyvcN9iuKZ3+lYFaX9nZU0SC9yfFZXeONK3vBruJLl+9L0VkN0uXCmXapT/Z1OSCP0YiUON2NwwW9mhL0CV54Hf02M0egl3+HqKGXfJcu0aDT6TB8gmHaZejwoenbBJMK2JjoUIP05oI3w/tf6550DSXsc1xz/IVjjr8x5vjH3HjS212GDveka4WelNMI+mSD9JbCnhTmbGxyJZJeJ1q0zA2J0PcapCuEk64qcM6BVoGf1ylHosq45VyshR8ZWeRQLBGJxyedbh7voPSwop7nY8fUW/vYcfW0jx3PlJxQz3gdoF1cPyeYG1nMgJYy4zJm+KzgDS4gPMGOVgHThTe6jBk+b3iTCwgtdAiYPnynowjhk4Y38yOzKXCilQultwoWPZbKMvFzfWnmbAfXPt4lWLgzGGev9NqyULqy0LZf754Ob/dshxgV2Qu4Z3nu0J3e9BZKF4NcHxrm+FCM8fKko33GrYKdMqauFR1cKF0lvCNe24ftC3j8fvv9PlzDtwnylfz8Mbp2oTQtPK0qvLNdy2a6gvTHdo8WmPnT3LAnWITvtnP0x+UkHDlw0m+Aym+nVH4F16mv4jj1NKf8GsbZr+X88h3ML2c4v7yR+eU7HW1Ad9jWxmtHar3kXY4mcu/+f6gHeHJ4p12pASFG+MFdbc7K/u7Q4uMFIBl9j23P+DLHil/llD/CWPdRzi+/wfzycUfT2btsy+i2LHrJtxxNhe9+zUgHT6PfK0hPifVutH2R9PZCKUPfLh+zF7OYxgfvk+8RTDjhPQQotki6tvg8SHinXL0msRxJW83euCPz+yiZX+F6Zfl8a1+rnE/7WvV8J3OD9wuSa5O60O2LpOtEhlkuy2QF/eKCLafQt/cZv3FQyfdSIiybzyhZf3EM8QK+ge0DggWdnJDoq4ukdwhHJMUMEd05kPBBSp61PDU2OarGDwmCHbHnCT23SLq+UFwIeXy8mWjhdZJdoSDnI7muaPrDlMhnspo2okIrJyq0ORoDPlIYDw8O/HzFfYI5I3I7Hlq3WJopNBnjCYe9oVlPxvBP2rlj/49SIp/PtX8Px/67HbX/xwQ9M96qifoXSzeIvlWvnYGXfI5/qx59nII3xHHPbAhoD3k9kuPnkO63C0G72r0jGOjxBXo5J2AATeUBQVMhd/uity6WbizUVDq9fm+P/WAJ9/oHBejJbdToA4ulmwqhD3m7g7No6HD0nxCix/vT0TcXS+8sjF7bmzKH6B+i0F/Hi/AzvAgPaDyfFKiOPFuAnl8s3SwIMAsG1WwgMRwZtt7vC1DPwxTCO3nNuz6lHIqlY9YbvwAq+pRdALV89oDA8mm77Otiw4lkylr/gCmqzwg8hOSIzlgivatQ4/LtDARDs80C3blJ5bOC3JYwJOpfIt1SKLfd7Qvz7jyPJUaUVCyjDMrapkj6ol6+0K5MvX+OkvlRbnLzTU5y8wQz5H2SLnHpm5efB2NnkI4+xaZqgJb6BRcQ/pj5JXzS+YuCaQVTDEXvWSLdWmjNLuTle/8cu/eXKMGe5xrgbxwD/GOOnPnLYKT/ctR1vwLG87ILjvpVvqPS+Qb60RLpNpGr1mtptS/sDez07LTugNzpZr4m6GaIsxXof0uk24W9505/sN3jl4P0GM54rd2qYp47hWN/RBAoTKcv0HFLpTuEO74DwYA/2DHH+L8u0D2xGo48S6U7C2UugivilsoypqZviNmyhe7oLc4ewQV8lBJwywJesz19Aec2uAV0wBMMcgAB7zHbSBlEo2ctcDLUfQOA5FwWCSC8fdMuEuES7qyvTeJ7ImCR9nHbWg0xWu1hSnZbe6vINwGLr084hB2+UPotRzyiMjIxLCfH7UcgwHLok7Z1N8boLjmb2AM4sPxt4Y7CPENUukx6r6gbKB+PjVNfRyzu0I94X74rk0xPUTq4lLWTlZDw2ZPv2GVcF4+MDQxGzA4Knz55WjB9QXJEkWXSvUV/Ea3QB3m4H90xWqzo06au+MN3KbXcym23d3AyhzuZ9vxezi/fx8ZIgEN9D4z8LghygCt+H4x8FjgBeckP+E1Gjw7oQ8ukD842UlZ3+7q9cldfp3X+r9WQByKO7vD4ISXIV3ixx4I7PPL9SLByh/mhHy+TPiIcOinxQ7G02tEr7Ha7rErbpbnU6Y8pqb7PjedWuOFafUYQz0mO6Pjl0seEc1cDscxhbQtDkr4Notrr3+0L80aqlnIVodcbAl+bl/2PEvAnlIB/4CnYSgC4fn8qSJYIhmhwufSA0G1zPz7C6LeivU/mbYe3kAnusz+jZHqJ67NWoOE6/bnAZ0mO6J7l0kO2lBpJDNIphKrUPRytWooFV+svKLEWNhRSKwkbrtZf2lCrxhH9abn0KeHJ/fRIbIi5vk9VqCdgHVktBYIr9FeUQCfyFEoBhqvy13xVGrzQuhXSZ4X5cTw5HItG4rQaQ+Fdvi7r5QFKDLgCf0OJsZVVYAG0/tmiBSj9t4XRcsDCh0W/E2yQzHFDiRXSF0UmLwsErVXFAIab9vcU4DDftNHkmDoIsxqpc+IjDy7Ats9C4WpDQl744eEF+MMfCuPlwIXvMPijwBdz3NDTK6SvCdO5SCqWGRlTMrEorcno2Dg7HcbIAXfRP1FyHOHp0AorPIY/J1rtwAxR/UrpUeHgLaOkxujGg3yBXs6GZwth4Lr8MyXM1dz2YwW3vNs/e7QA1T9fGK0VWHgY/4tgqJ5lhSIrpceFV20MRaIZJkUvQ0Hr0GMWAG7nv1ICvJ9rZw7QTt9u+0ABJv4bEGhNlz8YDMmzggtwjL8D4Qq/92qNFtAD/AOKttPboSqXM2K3RAtY6/pnYbTWYOH37P+L395zzNBzK6WnBTs1K8aThxUGE6AJv0Bh+hXfeOqQipcy0rqCt9h/28Yl6N04sAAt8z+2YfF7MQ4qQAv8r2AAqDsMOmeV9EPhADCaTCSUKD2OFn/Jm/JGeIfyIiVI+UJ+ImuGC8/A/idMZHVuKLZKekbQPOuMhV2rZTiAWl6ioK1g1dIkAGAkT4YQltm0WZnw5vuyE4jnD8bSswYNaNyvCKakSJToqVXSzwVesJD4seW6BMAV5pWaMZ5ejGK1Xc/hbk+f9ZolHz7cL0qcgF/rkYXLUQUFAPhIaSnXR1i2aO8x0q8FjlI5kRh31j3KKHjnc/XLV5Khf0PJ3AUqGjzcOcr5us0xQ/ceI/1OoNEy8jppuDorKESDXHWKU27ndVU5S2S8LpyDDNBCqvhWzFoH/fYY6Y+i77IcjsRTE7kPODpozGoK2FGuykSrBxx4cIvW8PVG8URLj5X+LEzmBtNyNBKn58dr+jz+UG9Y5uwtFEsGUHwtJdk13KyOxg3P6ur4Ws1zQ/uOlf4q8Ejr7Xpwh6ynsN3Jb8PC/s4aH9wj59vGV6hHFiIExJoF9jUoTHmE+AADs4ZZ4fP0eThHcYT4AJMhCwU9rrEPFf3lWOkFQeOo0ZcI2aACbx+LKHSP8eJGjV+MAdAGFtvGoE+PcDEAvHzJbDDsCYa4GACevNQuhurs/hAuBICzLpuNGtTum4sBMIW33C6GShTkAwBsMl9hG0CnbzcXAGDP+Eq7AOrzc+ZcGIBt4avsG6LXzwUA+JLVMbYBhHvbuQAAX7M61jYATyffFQFftDrOdntEnh6RFQBftnqdXQx1uVEQFwXgK1bHC7pRY/0aPX8cqiwRzQVoZxHCdHoC70RXU9jWLOJtS8oCcLwDPcEuf00BAeY6S3jvuWZWCuDwB/ScjXb5lwY4F9sA+swT7TIv28lcWQPvLU+yzd3P4w7oKtfaVvxO5z8mvc42c7/z35Feb5u5l6N2QMfYxA+G5mEMSrwOLbIOiTbOyVUFev1+OUjfSGVUHIrFM0pK1rYJObk+tYGS7UJWscYhkCjxRi9RFlkfi6zX51ussQIC70YXsNYpg8OK2p2ZvtoHH8ZvcgNqLDGoHJHT8ViU2SYGiOYnA6AOEyXwsXszAEmSRQII85sBSA6zSAAhvwWA5FIWCSD+n2IXSfFBrroz2MNfnqmKJCatmimgW9liW7u3Mdq9g9NMqzQhONOGo3exJgF0TKe6AL+s03pHjBV0wFjvNAD0O62hWyEEDAZPByD8oH2EgKHiGQCED9hHCBhGbi2M0OjbciHDYq0E8MnjM+3yL9f404wBXzQ+i58ymkRFZx6PlhWdMVb6uz0hL+ecdvbgt9X15ZUhq1rwVPJsSuZnuO74M8Ydf8Fxx98w5fA0slVgGzLFQgePR8uFtqnyh8/v9cz6AsGKjqA/ONuvXBRVqSpkCRBu63MoHf6Na+t/ciz7AuMD/+H88kXmly9xflmy2HlvaXtVJeVKBBibbJtDiXiWesW+pIChzfbXgKRcuQADpR1zKBcXP2B4dS4YPzxWzMIDAcM3z2tAUq5cgMFg+xzKxcUPGPh1uIbfAX8DjAg751wurhSAwaHXNSm4aAEDxa7CaPVsrDr7rZtD7MFpwBhwJz+Z1cc06Knj0SrRMp3lDCh8lW4XDWwxb4scPa0DX6HzFead2xcpGkFx02rhCAqQmZ1nF/foUcaPDcwWt+rpNS5zIb+S7Nq4QXNFOZqMx5VohtQnfD3QbxdDdiCtjoczSoptgYBkBvFbIGkNdN5qtFo4mtQ2zO31ef2c2c+5//ZQgJLsFm4zEkN35wrXYIFVubyp0fWrUaMoAtYPTMTimZh+HZ6DIbCbQvhRnmuWa5Piju9TON82+/ZgkMMeEMxCdtnXjU2o2k9nUrHEMK19QHAK2+Vf0eUPejhL1oDA1GOXf1mwg8MdEJV6bXNv5+0QAQx7dtvmvsu7x/GdCn22ufsCzm9V2MOPS0w3iKQT0Mmi0FQ7GItmqIV0eGDaS0F8lqegmrTC4Q6ISxfY5j6s0JsI4GFpn13utdls3ZI9ICr122VfnbW8xWABEJL222VepdndgjcgIB2wbfXMxHhcseIOCEiybbXzxmiAeHShYMGB7PtQ4xp0higaLJNl4vfG1f6nOhgYIoKzRUM5lB1r0FZhIlvbFe4Jydr2VM5nWDRS2sXEGfpe4upsTS9zUA2eyw4IsnQCDjq4Bp0pMsFSWcY/N75be5qDFohSOE9dwjgqOAAP8nWB3R99eA06q/jVr5rsZ20tVh9dW5JSKKl2sJozBs/tS6wnh7qYcvgoZYivayLQoafWoLOFyhZOVOiE5nCpd5iSKsTVdS9H13td0PWIIHrlOjT0whrUWkDT7SFPxyy9ujJkVQmu6JjAfTAWtLIRnSMUigt8zj9oO0pJlGJdR38xSbyAJ50HBbMFBw/LhC49jahNvCPD9Hvb6qwyqjmoyzgl1OU8XV7tqC7HBO0sJyQaa0TbxN0HPe+rF3O/E+OKNyYE7Qt/AgpNN6LtQmGWyHL+50ZWcDp9Vl37waDVBkYA/iSF/y6eB7zfUQ8YF2RTRGeEHmxE54pTxWK+tF1MMLNutHADvJ7SxP28nrA4UYWwAQZMuQvbwkLw1ZG0W5jhCyGZwtBE9oSP7CcEKX1+IgEdPhF1FZ37LJblHCUjwp1Bp/YHD6njohh9G6JbudEhSubfcpPQZzlJ6HNEDb3keRfS0sNgnFxUgNZ0RNSJG3ZEHzwR7Sw+fs9mvyLcHSYFfRIxlYeePBHtcmNXZ10skWAOaB11d8x7kSB9wZOnqOwk5Ct+dFmMxG4NPC8WCIznqtFpJ6Hzig50RQrsTpCbEng1sTaAoichqWiJOYH7VRD3qHBvNkaDrjsJ+QuupnvCewMd1peEaavpnOv3RTvuLU9U6684l00R9ex/lw+uyEsoRUpLeZ1OYKl1p9PNKQ8tpTvNHs4vdxO/hHejl9qWyFnkeskezi8vYGUEdMpveJVkhGfAlwniFHESBf3mJBRwfKbKrcHdGymhLmbNYSOtB/j8m+wCsNAafKn0ctFKNv7CtG7Y7WtRSGhYpopt85Ifx3bOuG+mpJvh6Hb0lqVOTp28RTBSi6SiI/oHzDNrUY9wX0ByYFS7RNjZPZtXUNju4blbrdrXHVQ7Y2e3bb7VLvvq7JZVC+YAZ7/SNvNEctCSOSB6XmWbefaLrRbMAXMHVws8Ms8O/WAtukA8bOrZ2+3lffPAlcnPaQr4I9ze8jHrPpCz8w+eq7xNoNK8+6CKdWifWKWBYOfcqvQaAfB8o0Nr1qF+MXBv5865Bf52Qf5BBCu0bR3aL84/+jx+ycv9eIcr4K8VgCcCPdq/Dh0Qgw+2n+ft6JlT8NeJXCYxMaZDP7oOyQVcJtCL5hT4O0RntAdi8VhGX59CN69DF4pnwTztPr+vZ++cwr+eD39ZNpFIpuScGMb1RJ9ZhwaEgnAqUtMCpHKck2eGkufYZbxofvwyaoxDZE7OxfAbCuPRX5ywjMkPAXnIjXbZrmfZAjKQm/jetFizt5xJylklG65Uth5F4a7EtRvAj95JSXImT4FtrAIB7nKzSIGalJoCNUUaCjxzPRp8zbbFd1HC7OTp0O+oDm+xocNsl5K7bm09Uhxwwnwv5ZwCb6Uk6eMpsN9RBd4m6NLIY37orvVoWDS+1JO9SGLSwdHl7RS4YY5OpmuyzIdS7I0sANXcYZd7VZZ7Jung2PLdgrW2HDf02/XoYIEsIxQK9skhuXuLc3eHLCHuFYykLDcRYr6nOj7ffyelmSlup3/pMutpzMvoZGD0CuaX8GTgPYVxGt5jKMvx41R3iXYC5tsL2tGEEna8yP8qeZHfDS+6m9LNu7hedBvHi+5gvOi9LnjRewvjNHmR84fy7ik0vtdCPrq1Cb3+texEroSi91Gq+STXiT7NcaLPMk70ZRec6P2FcRp9uK6sdp/jXnSvYL6C+Lwd+ncTyggP3uZ+bNXXA0z5AQrf93gqyqNlu3uAhT7IVw/1AUC0YQM6LGxp3G/aiy6uBajuQzZMq2Urvg1oUgi8rsONdEW095rg6Hx0+DCll79wo8PfOdHhn0x0eNGF6PCRwjiN6NDhVqZyn2CrvanBo7s3oClbTuRsR2PHiVzJUz5KaWbBcp4TLVpu7URLltNOtIr5JdyJPlYYp9mJnE9UPi5wItNV6KhsI7q06M1tvNMGNnIRt7a43S+614K8WB1t3YjeULTk4s87ipqIW4I/wBfc0hwothG9UXwqo7AVBdsO6NqxjMJ8th0g7oOUuOdxGtno+cudnCL6hH0tZwVGH92ILhcvOrGrG4ajGF+KoXJ4V/a7PSTIW8YimeiInM6MqT7zy43oLQX3DSJPT8eu2d4JJdhfuVSWMQbj2PbWOdpR+Um+YhbqoKKRtCIPxJPax2gbN6ErxMt0qno6PGFrOevGIxnVgRJyWnk9bANkwT58QToTUd2T2UwEV9jDlMIu4nbSRzmd9KVMJ/1mzi+vIH4J77Y/JZj9JS2DUpvQleLdRdoB92wFB0dln6bg3cDLKmojaR57gHY+I1pkx/Kimzehq4RNQG3N+PfGUZgz6R3/NH64X36Wwn83r7+419H+4nMCtRF2Qp/bhK4WzxlZOBWODR76O136q/KABzkfEz8vmI/PC/TLTegaUSNpMO4Xc6GlfIHC90VeS1mUjiWG40ommXChwXzRLoqGaGQ8M6EmDBwMgGHAl+xiWKgGtgklEeWCAKyNf9m2IsYi4+PZm1msMQA26X3FLob50bg6SuAhAFzg81XBbmC6KaCDJ6MbRI2Hf/MWoNl8jUL4e56ORDe+ARrMI3b5i268AzSWr/MtZBEo0DtPRjeKbCS4lRBgpEcpkC/xlCS4lRBgo8cEXkyHMfTwyegmsYbY3gmuoW8IMnYmyqEnT0Y3F3+ccXH2ZKR+ssq6cz5GlmmmRs5z1lydcvwmpZBlK3gZ+coV1nn2MSvojPx45pfw/PtxuziFEzMFTTJ6HC2NaxcSP2Fb85s4mm9mNH8KT/OAHvpbglZN98no9c3o1uJPwWcPXYoazCptsG9iabSXs+doxP8kpYxtXKOdyzFaO2O0Lheay7fBOLmoAC7/lGAPmkXLRF9qRrcJr1e3mhOBdxLfoWDu5cYa8USvYIAFMO3TAiVaNCD0j2Z0u/jwGG+wdbTQRJGl/uGN7LuUhKMF9N8d7JtD/X9PsAJtHh+gbZvRu4Wqt0JYuBdrOHg4H/7mcA3h+5Tgl3Jjyhs5MeVyTvlbXYiAP7CLtkgj1AssIFj4gNgOEHl/aNt2N3BsdBOn/GamP7vDhSTkR4KFO5M60cOb0V3iK+aKM5xLse7HlGAfZg2jv3hghZMzj88IkjraQ9Gzm9Hd4h5E7NSiy6x461u8xWOXzPATSh+f57aPrzH+/nVOy3hshZMLED+lEL6tnDdbp8T1tZvDscyIPJiMOpgZ/cwuiCoDhINTpj8vzLuJfaOXfJ81BSCY/gKA5CcsEkBY/CWF5MEKXifH+/SwO+fnfmUXl+mNXvI8pzn91dHm9GsK4eJKnubqYmPjyVTGvEVBENjg2vuNXWymN3rJy0x4mrfS+eTqtxTCb3C1V93p7QhyT/xaXwcE1+Dv7OIzvdFL5jP60ssbVjrpf7+nt9FyNSi8MskdB3zWLjjTG73kuJV0yfEuOOAfKIQPVfHUV5M9gZbdoDInuvujXWSmN3rJJkZ3zS7o7k8UwmtquLrTbxc6FKGvKHNJd8/ZRWZ6o5e0Mrprc0F3f6YQfp9FaPQaY8rYgJIyOx48AXu+MP8m9o1e4nM0gP2F7qTqeCcO87uJHNTDXwtzb2Lf6CW9jurhbxSSA/W8nTfKkagynpEHHb1W6O+F2Texb/SSiKOK+AeFZOV8Xlipyu5+jdAfKHEpqPzTLi7TG71kjAkqSReCyr8ohFsXFJMLsCNmuO5esIvM9EYvmWJ0d4kLuvs3hXA173bo/Dd2nGt7/7HLuzLcE/IFdjq+4P7fwgCa2Dd6ydVs4wcMiV8EILmO5xaAgfH/KDxn8Eyjf0+p2+dlFgvh/vGSXRA1WRDt3jB9oSrcRV4ujAF0ba9woRXgUK/YxW16o5fc5YJDzSsrHs+9PDyAPWslADz3cUa4H2Mi9v085IC9bqUU8nu4HsmdHHYpUyizi8z0Ri95nNHdt1zo7cophH/k6o5z7bRLmquwi8v0Ri95htHcT13QXCWFMMXd7Moc3HAuYagqDKKJfWMoztFkvZpC8j4eEna3veFI7X0yc8c33JFq7OIyvdFLXmAc6T8uOFIthfA47rqyYNlLtA8NrsQ6uxDZ3W6jlaus+4bqVU66Xz2FsLMoJQq2i8GVON8uRNMbvWQZR4krnFTixOb/A2aiem0='
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
