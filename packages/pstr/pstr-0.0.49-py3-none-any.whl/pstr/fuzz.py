# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_fuzz.ipynb.

# %% auto 0
__all__ = ['fuzzfind', 'strmatch', 'keymatch']

# %% ../nbs/07_fuzz.ipynb 4
import difflib
from typing import Callable, Iterable

from atyp import StrQ, Strs, IterStr
from ispec.utils import funkws

from .sens import sens

# %% ../nbs/07_fuzz.ipynb 6
def fuzzfind(string: str, strseq: IterStr, prep: bool = True, prepfunc: Callable = sens, **kwargs) -> Strs:
    '''Find the closest matches (same-ish) in the provided sequence using fuzzy matching.

    Parameters
    ----------
    string : str
        The string to find matches for.
    strseq : Iterable[str]
        The sequence of strings to find matches in.
    prep : bool, default: True
        Whether to call `prepfunc` on the provided string and the provided sequence, by default True
    prepfunc : Callable, default: sensify
        The function to call on the provided string and the provided sequence, by default sens
    
    Other Parameters
    ----------------
    n : int, default: 1
        The maximum number of matches to return.
    cutoff : float, default: 1
        The minimum score for a match to be returned.

    Notes
    -----
    `fuzzfind` is very similar to `difflib.get_close_matches`. However, it will call `prep` on the 
        provided string and the provided sequence.

    See Also
    --------
    sprep.sensify : The default `prepfunc` for `findsame`.
    difflib.get_close_matches : The function that `fuzzfind` is based on.
    '''
    
    pkws = funkws(prepfunc, **kwargs)
    doprep = lambda s: prepfunc(s, **pkws)

    string = doprep(string) if prep else string
    nmatch = kwargs.get('n', kwargs.get('nmatch', 1))
    cutoff = kwargs.get('cutoff', 1)
    
    strseq = strseq if isinstance(strseq, Iterable) else (strseq, )
    if prep: strseq = list(map(doprep, strseq))
 
    matches = difflib.get_close_matches(word=string, possibilities=strseq, n=nmatch, cutoff=cutoff)
    return matches
            

# %% ../nbs/07_fuzz.ipynb 7
def strmatch(
    a: str, b: str, 
    n: int = 1, cutoff: float = 0.8,
    icase: bool = True, ispace: bool = False, iunder: bool = False,
) -> StrQ:
    '''
    Match string `a` against candidate `b` after normalizing both strings.

    The matching is done using difflib's get_close_matches to find close matches to the string `a` 
    in a sequence containing only the string `b`. String normalization can be controlled via 
    boolean flags which remove spaces, underscores, and set characters to lowercase.

    Parameters
    ----------
    a : str
        The string to match against.
    b : str
        The candidate string to match with.
    n : int, optional
        The maximum number of close matches to return; here, it is either 0 or 1, by default 1.
    cutoff : float, optional
        The similarity ratio (0 <= ratio <= 1) below which matches are not considered, by default 0.8.
    icase : bool, optional
        If True, ignores case during comparison, by default True.
    ispace : bool, optional
        If True, ignores spaces during comparison, by default False.
    iunder : bool, optional
        If True, ignores underscores during comparison, by default False.

    Returns
    -------
    str or None
        The candidate `b` if it is considered a match; otherwise, None.
    '''
    a = sens(a, icase, ispace, iunder)
    c = sens(b[:], icase, ispace, iunder)
    same = difflib.get_close_matches(a, (c, ), n, cutoff)
    if same: return b
    return None

# %% ../nbs/07_fuzz.ipynb 8
def keymatch(
    s, key, val: str = None,
    n: int = 1, cutoff: float = 0.8,
    icase: bool = True, ispace: bool = False, iunder: bool = False,
) -> StrQ:
    '''
    Match a string `s` against a `key` and optionally a secondary string `val` after normalization.

    Attempts to match the string `s` with `key` first; if that fails and `val` is provided,
    it attempts to match with `val`. Matching uses `strmatch` internally, applying the same
    normalization and similarity checking.

    Parameters
    ----------
    s : str
        The string to be matched.
    key : str
        The primary key to match against.
    val : str, optional
        An additional value to attempt to match `s` against if the match with `key` fails, by default None.
    n : int, optional
        The maximum number of close matches to return; here, it is either 0 or 1, by default 1.
    cutoff : float, optional
        The similarity ratio (0 <= ratio <= 1) below which matches are not considered, by default 0.8.
    icase : bool, optional
        If True, comparison ignores case, by default True.
    ispace : bool, optional
        If True, comparison ignores spaces, by default False.
    iunder : bool, optional
        If True, comparison ignores underscores, by default False.

    Returns
    -------
    str or None
        The `key` if a match with `s` is found; otherwise, None.

    '''
    kwds = dict(n=n, cutoff=cutoff, icase=icase, ispace=ispace, iunder=iunder)
    same = strmatch(s, key, **kwds)
    if same is None and val is not None:
        same = strmatch(s, val, **kwds)
    if same: return key
    return None
