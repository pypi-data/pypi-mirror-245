import numpy
import pandas

from .column_metadata import ColumnMetadata


class TableGenerator:
    """
    Class representing a table generator. It is composed of multiple child generators
    (multiple columns and to one sequence).

    Attributes:
        id (str): ID of the generator.
        name (str): Name of the generator.
        seed (int): Seed of the generator.
        visible (bool): Visibility of the generator.
        random_generator (numpy.random.Generator): Random generator used for generating
            values.
        child_column_generators (list[ColumnGenerator]): List of child column
            generators.
        child_internal_column_generators (list[ColumnGenerator]): List of child internal
            column generators. These are intermediate generators which are hidden and
            used only during the generation process (mostly related to generation from
            templates).
        child_sequence_generator (SequenceGenerator): Child sequence generator.
        table (pandas.DataFrame): Dataframe generated by the generator.
        strong_dependencies (list[str]): List of strong dependencies of the generator.
            Related to generation from templates.
        weak_dependencies (list[str]): List of weak dependencies of the generator.
            Related to generation from templates.
        dependencies (list[str]): List of dependencies of the generator.
            Related to generation from templates.
        size (int): Size of the table generated by the generator.
        metadata (dict[str, ColumnMetadata]): Metadata of the column generators.
        propagate_templates (bool): Whether to propagate data to child generators.
            Related to generation from templates and multi-levels tables (contains
            a child sequence). Setting to True means that if a column generator is
            linked to a template (e.g. country), the value of the column will be
            propagated to the child sequences.
    """

    generator_type = "TABLE"

    def __init__(self, id: str, name: str, seed: int, propagate_templates: bool = True):
        """
        Constructor of the TableGenerator class.

        Args:
            id (str): ID of the generator.
            name (str): Name of the generator.
            seed (int): Seed of the generator.
            propagate_templates (bool): Whether to propagate data to child generators.
                Related to generation from templates and multi-levels tables (contains
                a child sequence). Setting to True means that if a column generator is
                linked to a template (e.g. country), the value of the column will be
                propagated to the child sequences.
        """
        self.id = id
        self.name = name
        self.seed = seed
        self.visible = False
        self.random_generator = numpy.random.default_rng(seed=self.seed)
        self.child_column_generators = []
        self.child_internal_column_generators = []
        self.child_sequence_generator = None
        self.table = None
        self.strong_dependencies = None
        self.weak_dependencies = None
        self.dependencies = None
        self.size = None
        self.metadata = {}
        self.propagate_templates = propagate_templates

    def _generate_next_batch(self, max_size: int, size: int, preview: bool = True):
        """
        Generates the next batch of values. The result dataframe is saved to the table
        attribute.

        Args:
            max_size (int): Maximum size of the batch. This is needed when there is
                a child sequence generator. The size of the batch is multiplied by
                the size of the child sequence generator and therefore needs to be
                limited by the max_size.
            size (int): Size of the batch, or how many values are produced by the child
                column generators. When there is a child sequence generator, number
                of values multiplies by the size of the child sequence generator and
                therefore needs to be limited by the max_size.
            preview (bool): Whether to generate preview or not.
        """
        column_vectors = {}
        column_names = {}
        column_ids = []
        column_visibility = {}

        table = pandas.DataFrame()

        generators = self.get_generator_columns()
        for generator in generators:
            generator.generate_next_batch(size, preview)
            values = generator.generated_values

            # TODO - cleanup unused code
            column_vectors[generator.id] = values
            column_names[generator.id] = generator.name
            column_ids.append(generator.id)
            column_visibility[generator.id] = generator.visible

            table[generator.id] = values

            self.metadata[generator.id] = ColumnMetadata(
                generator.id,
                generator.name,
                generator.seed,
                generator.get_generator_type(),
                generator.visible,
                generator.template_filters,
            )

        # Generating the subsequence.
        # This is basically left join of two tables - the current one and the child
        # sequence.
        if self.child_sequence_generator:
            tables = []
            current_size = 0
            for i in range(len(table)):
                row = table.take([i])
                self.child_sequence_generator.generate_next_batch(
                    max_size, row, self.metadata
                )
                subtable = self.child_sequence_generator.table
                t = pandas.merge(
                    row, subtable, how="cross", copy=False, suffixes=("", "_delme")
                )
                t = t[[c for c in t.columns if not c.endswith("_delme")]]
                self.metadata = self.metadata | self.child_sequence_generator.metadata
                tables.append(t)
                current_size = current_size + len(t)
                if current_size >= max_size:
                    break
            table = pandas.concat(tables)

        self.table = table

    def generate_next_batch(
        self, size: int, strict_size: bool = False, preview: bool = False
    ):
        """
        Generates the next batch of values.

        Args:
            size (int): Size of the batch.
            strict_size (bool): Whether to generate exactly the given size or not.
                If False, the size of the batch can be higher than the given size.
            preview (bool): Whether to generate preview or not.
        """
        self._generate_next_batch(size, size, preview)
        if strict_size:
            self.table = self.table.head(size)

    def get_generator_columns(self):
        """
        Returns list of all child column generators, including the internal ones.

        Returns:
            list[ColumnGenerator]: List of all child column generators.
        """
        return self.child_internal_column_generators + self.child_column_generators

    def get_generator_by_type(self, generator_type, seed):
        """
        Searches for a generator by its type and seed. Searches for exact match
        of the generator type as well as for a substring in the generator type.
        Returns the first match.

        Args:
            generator_type (str): Type of the generator.
            seed (int): Seed of the generator.

        Returns:
            ColumnGenerator: Generator of the given type and seed, None if not found.
        """
        generators = self.get_generator_columns()
        return next(
            (
                g
                for g in generators
                if (
                    g.get_generator_type() == generator_type
                    or generator_type in g.get_generator_type()
                )
                and g.seed == seed
            ),
            None,
        )

    def contains_generator_type(self, generator_type, seed):
        """
        Checks whether the generator contains a generator of the given type and seed.
        Searches for exact match of the generator type as well as for a substring in
        the generator type.

        Args:
            generator_type (str): Type of the generator.
            seed (int): Seed of the generator.

        Returns:
            bool: True if the generator contains a generator of the given type and seed,
                False otherwise.
        """
        generators = self.get_generator_columns()
        return any(
            g
            for g in generators
            if (
                g.get_generator_type() == generator_type
                or generator_type in g.get_generator_type()
            )
            and g.seed == seed
        )

    def add_internal_child_column_generator(self, generator):
        """
        Adds a column generator to the list of child internal column generators.
        Performs a check whether the generator is already in the list.

        Args:
            generator (ColumnGenerator): Column generator to add.
        """
        # TODO - cleanup unused code (dependent_generators_count)
        if not self.contains_generator_type(
            generator.get_generator_type(), generator.seed
        ):
            self.child_internal_column_generators.append(generator)
            generator.dependent_generators_count = 1
        else:
            existing_generator = self.get_generator_by_type(
                generator.get_generator_type(), generator.seed
            )
            existing_generator.dependent_generators_count = (
                existing_generator.dependent_generators_count + 1
            )

    def add_child_column_generator(self, generator):
        """
        Adds a column generator to the list of child column generators.
        """
        self.child_column_generators.append(generator)

    def get_generator_by_name(self, name):
        """
        Searches for a generator by its name and returns the first match.

        Args:
            name (str): Name of the generator.

        Returns:
            ColumnGenerator: Generator of the given name, None if not found.
        """
        generators = self.get_generator_columns()
        return next((g for g in generators if g.name == name), None)

    def sort_child_generators(self):
        """
        Sorts the child internal column generators. The sorting is based on
        the dependencies of the generators. The generators are sorted in such order that
        the dependencies are generated first. This is a depth-first traversal
        of the graph from left to right.
        """
        generators_dict = {
            f"{g.get_generator_type()}.{g.seed}": g
            for g in self.child_internal_column_generators
        }

        sorted_objects = []
        visited = set()

        def visit(generator, generator_type_seed):
            if generator_type_seed not in visited:
                visited.add(generator_type_seed)
                for dependency in generator.dependencies:
                    if f"{dependency}.{generator.seed}" in generators_dict:
                        visit(
                            generators_dict[f"{dependency}.{generator.seed}"],
                            f"{dependency}.{generator.seed}",
                        )
                    elif f"{dependency}.0" in generators_dict:  # common dependency key
                        visit(generators_dict[f"{dependency}.0"], f"{dependency}.0")
                sorted_objects.append(generator)

        for generator_type_seed, generator in generators_dict.items():
            visit(generator, generator_type_seed)

        self.child_internal_column_generators = sorted_objects

    def get_batch_dataframe(self, column_naming="NAME", show_hidden=False):
        """
        Returns the generated batch as a dataframe.

        Args:
            column_naming (str): Naming of the columns. Can be either ID or NAME.
            show_hidden (bool): Whether to show hidden columns or not.

        Returns:
            pandas.DataFrame: Generated batch as a dataframe.
        """
        batch = self.table

        if not show_hidden:
            visible_cols = [
                id for id in self.table.columns if self.metadata[id].visible
            ]
            batch = batch[visible_cols]

        if column_naming == "ID":
            batch.columns = batch.columns
        elif column_naming == "NAME":
            batch.columns = [self.metadata[id].name for id in batch.columns]
        elif column_naming == "SEED":
            batch.columns = [str(self.metadata[id].seed) for id in batch.columns]
        else:
            raise Exception("column_naming has to be either ID or NAME")

        return batch
