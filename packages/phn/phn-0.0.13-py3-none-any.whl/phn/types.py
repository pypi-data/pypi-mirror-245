# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_types.ipynb.

# %% auto 0
__all__ = ['Genes', 'Cells', 'tostr', 'PhnSet', 'Gene', 'Cell', 'populate_genes', 'populate_cells', 'Lineage']

# %% ../nbs/03_types.ipynb 4
import re, io, string, pkg_resources, resource
from itertools import repeat
import numpy as np, pandas as pd

from typing import Union, Optional

from atyp import AnnData, Series, DataFrame, NPArray

from nchr import U1, DOT, NIL, SPACE
from nlit import X_, PHATE_HVG
from chck import notnone, isdf, isstr, isiternotstr
from chck import isiter, islist, istuple, isset, isnone

from ensc import EnsemblClient, GeneInfo

from pstr import safeattr, keymatch, shiftchars, axeschars, splitjoin

# %% ../nbs/03_types.ipynb 5
from .read import read_csv, save_csv
from .meta import Collection, Registry

# %% ../nbs/03_types.ipynb 8
def tostr(s: str) -> str:
    '''Convert a string to a human-readable "display" name.'''
    # Replace underscores with spaces
    s = str(s).replace('_', ' ')
    # Add space before opening bracket if preceded by a word character
    s = re.sub(r'(?<=\w)(?=\()', ' ', s)
    # Add space after closing bracket if followed by a word character
    s = re.sub(r'(?<=\))(?=\w)', ' ', s)
    # Add space before capital letters in camel case, except the first letter if it's uppercase
    s = re.sub(r'(?<=\w)(?=[A-Z])', ' ', s)
    # Capitalize the first letter of each word
    return ' '.join(s.split()).title()

# %% ../nbs/03_types.ipynb 10
class PhnSet:
    _setattr = 'genes'
    
    def _getset(self, obj = None) -> set:
        oset = self if isnone(obj) else obj
        if isset(oset): return oset
        return getattr(oset, type(self)._setattr, set([oset] if not isiternotstr(oset) else oset))
    
    def _setset(self, obj):
        oset = type(self)._getset(obj) if not isset(obj) else obj
        setattr(obj, type(self)._setattr, oset)
        return self

    @property
    def _set(self) -> set: return self._getset(self)
    def __len__(self): return len(self._set)
    def __contains__(self, item): return item in self._set
    def __and__(self, o): return self._set & self._getset(o)
    def __ge__(self, o): return self._set >= self._getset(o)
    def __gt__(self, o): return self._set > self._getset(o)
    def __iand__(self, o): return self._setset(self._getset(self) & self._getset(o))
    def __ior__(self, o): return self._setset(self._getset(self) | self._getset(o))
    def __isub__(self, o): return self._setset(self._getset(self) - self._getset(o))
    def __ixor__(self, o): return self._setset(self._getset(self) ^ self._getset(o))
    def __le__(self, o): return self._set <= self._getset(o)
    def __lt__(self, o): return self._set < self._getset(o)
    def __or__(self, o): return self._set | self._getset(o)
    def __rand__(self, o): return self._set & self._getset(o)
    def __ror__(self, o): return self._set | self._getset(o)
    def __xor__(self, o): return self._set ^ self._getset(o)
    def __sub__(self, o): return self._set - self._getset(o)
    def __rsub__(self, o): return self._getset(o) - self._set
    def __rxor__(self, o): return self._getset(o) ^ self._set
    def difference(self, *os): return self._set.difference(*list(map(self._getset, os)))
    def intersection(self, *os): return self._set.intersection(*list(map(self._getset, os)))
    def isdisjoint(self, o): return self._set.isdisjoint(self._getset(o))
    def issubset(self, o): return self._set.issubset(self._getset(o))
    def issuperset(self, o): return self._set.issuperset(self._getset(o))
    def symmetric_difference(self, o): return self._set.symmetric_difference(self._getset(o))
    def union(self, *os): return self._set.union(*list(map(self._getset, os)))

# %% ../nbs/03_types.ipynb 12
class Gene(PhnSet, metaclass=Registry):
    '''
    A class representing a gene with associated information and functionality.

    Attributes
    ----------
    name : str
        The common name of the gene.
    ensg : str
        The unique Ensembl gene identifier.
    desc : str
        A description of the gene.
    cells : set
        A set of `Cell` objects that mark the presence of the gene.

    Methods
    -------
    id()
        Property that returns the Ensembl gene identifier.
    marks(cell)
        Associate a cell type with the gene, adding the cell to the `cells` set.
    __repr__()
        Compute the "official" string representation of the gene.
    __hash__()
        Return the hash value of the gene based on its name.
    __eq__(other)
        Check for equality between two `Gene` objects or a `Gene` and a string.

    '''
    ensc = EnsemblClient()
    _setattr = 'cells'
    def __init__(self, name: str, ensg: str, desc: str):
        self.name = name
        self.ensg = ensg
        self.desc = desc
        self.cells = set()

    @property
    def id(self): return self.ensg

    def marks(self, cell):
        if isinstance(cell, str):
            cell = Cell.lookup(cell) or Cell(cell)
            
        if cell not in self.cells:
            self.cells.add(cell)
            cell.add(self)
    
    @classmethod
    def search(cls, gene: str, species: str = 'human'): 
        return cls.ensc.lookup(gene, species)
    
    def fetch(self, species: str = 'human'):
        return self.search(self.name, species)
    
    def __str__(self): 
        return f'{self.name}'

    def __repr__(self): 
        return f'{self.name}'
    
    def __hash__(self): 
        return hash(self.name)

    def __eq__(self, other):
        if isinstance(other, Gene):
            return self.name == other.name and self.ensg == other.ensg
        elif isinstance(other, str):
            return bool(same := keymatch(other, self.name, self.ensg))
        return NotImplemented
    
    def __getitem__(self, it):        
        for cell in self.cells:
            if cell == it:
                return cell
            
        if isinstance(it, int): 
            return list(self.cells)[it]
        raise KeyError(f'No cell named {it} in {self.cells}')
    
    def celllist(self):
        return list(map(str, self.cells))

# %% ../nbs/03_types.ipynb 14
class Cell(PhnSet, metaclass=Registry):
    '''
    A class representing a cell type with associated information and functionality.

    Attributes
    ----------
    name : str
        The common name of the cell type.
    
    genes : set
        A set of `Gene` objects that are markers for the cell type.

    type : str, optional
        The type of cell.

    subtype : str
        The subtype of cell.

    species : str, optional
        The species of the cell.
    
    abrv : str, optional
        An abbreviation for the cell type.
        
    desc : str, optional
        A description of the cell type.
    

    Methods
    -------
    add(gene)
        Add a gene as a marker for the cell type.
    __repr__()
        Compute the "official" string representation of the cell type.
    __hash__()
        Return the hash value of the cell type based on its name.
    __eq__(other)
        Check for equality between two `Cell` objects or a `Cell` and a string.

    '''

    _setattr = 'genes'
    def __init__(
        self, name, *genes, 
        type = None, subtype = None, abrv = None, species = None, desc = None, 
        **kwargs
    ):
        self.name = name
        self.type = type
        self.subtype = subtype
        self.abrv = abrv
        self.species = species
        self.desc = desc
        self.genes = set(genes)

    def add(self, gene):
        '''Add a gene to the cell type.'''        
        if isinstance(gene, str):
            gene = Gene.lookup(gene, cutoff=1) or Gene(gene, None, None)

        if gene not in self.genes:
            self.genes.add(gene)
            gene.marks(self)

    def __str__(self): 
        s = ''
        if isstr(self.type): s += f'{self.type}'
        if isstr(self.subtype): s += f'({self.subtype})'
        if s == '': s = self.name
        return tostr(s)
    
    def __repr__(self): 
        return f'{self} ({len(self.genes)} marker genes)'
    
    def __hash__(self): 
        return hash(self.name)
    
    def __eq__(self, other):
        if isinstance(other, Cell):
            return self.name == other.name
        elif isinstance(other, str):
            return bool(same := keymatch(other, self.name, self.abrv, cutoff=1))
        return NotImplemented
    
    def __getitem__(self, it):
        if isinstance(it, str):
            for gene in self.genes:
                if gene == it: 
                    return gene
                
        if isinstance(it, int): 
            return list(self.genes)[it]
        
        raise KeyError(f'No gene named {it} in {self.name}')
    
    def __iter__(self): 
        return iter(self.genes)
    
    def genelist(self):
        return list(map(str, self.genes))

# %% ../nbs/03_types.ipynb 16
# Utilize the registry directly
Genes = Gene._registry
Cells = Cell._registry

# %% ../nbs/03_types.ipynb 18
def populate_genes(df_gene):    
    for _, row in df_gene.iterrows():
        Gene(row['gene'], row['id'], row['desc'])    

def populate_cells(df_cell):
    for _, row in df_cell.iterrows():
        drow = dict(row)
        gene = drow.pop('gene')        
        cell = Cell(**drow)
        cell.add(gene)

# %% ../nbs/03_types.ipynb 19
# Populate genes and cells
populate_genes(read_csv('genes'))
populate_cells(read_csv('cells'))

# %% ../nbs/03_types.ipynb 37
class Lineage:
    def __init__(
        self, 
        name: str, 
        zsc_suffix: str = '_zscore', 
        obs_suffix: str = '_cells', 
        **kwargs
    ):
        self.name = name
        self.zsc_suffix = zsc_suffix or ''
        self.obs_suffix = obs_suffix or ''

    def __str__(self): return self.name
    def __hash__(self): return hash(self.name)
    def __eq__(self, other):
        if isinstance(other, str): return self.name == other 
        return super().__eq__(other)

    @property
    def score(self) -> str: return f'{self.name}{self.zsc_suffix}'
    @property
    def cells(self) -> str: return f'{self.name}{self.obs_suffix}'
    @property
    def strs(self) -> tuple: return (self.name, self.score, self.cells)
    @classmethod
    def from_str(cls, name: str): return cls(name)
    def idx(self, adata: AnnData) -> Series:
        '''Where the lineage is present in the data.
        
        Examples
        --------
        Note that the following:
        >>> Lineage('esc').idx(adata)
        
        is equivalent to:
        >>> adata.obs['esc_cells'] == 'esc'
        '''
        return adata.obs[self.cells] == self.name

    def subset(self, adata: AnnData) -> AnnData:        
        bools = self.idx(adata)
        return adata[bools]

    def scores(self, adata: AnnData) -> Series:
        return adata.obs[self.score]
    
    @classmethod
    def extract(cls, a: str, *lins: 'Lineage') -> list:
        '''Extract the attribute `a` from each lineage in `lins`.'''
        return list(getattr(l, a) for l in lins)

    @classmethod
    def obscols(cls, adata: AnnData, *lins: 'Lineage') -> DataFrame:
        names, cells = cls.extract('name'), cls.extract('cells')
        return adata.obs[cells].isin(names)

    @classmethod
    def make_df(cls, adata: AnnData, *lins: 'Lineage') -> DataFrame:
        '''Make a dataframe of lineages from an AnnData object.'''
        df_lineages = cls.obscols(adata, *lins)
        boolean_idx = np.any(df_lineages.values, axis=1)
        return df_lineages[boolean_idx]
    
    @classmethod
    def plot_lineages(cls, adata: AnnData, *lins, **kwargs):
        try:
            import scanpy as sc   
            scores, cells = cls.extract('score'), cls.extract('cells')
            if len(lins) > 1: kwargs.setdefault('ncols', len(lins))
            sc.pl.embedding(adata, color=[*scores, *cells], ncols=len(lins), **kwargs)
        except ImportError: return

    def plot(self, adata: AnnData, **kwargs):
        type(self).plot_lineages(adata, self, **kwargs)
