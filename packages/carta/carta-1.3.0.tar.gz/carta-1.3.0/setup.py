# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['carta']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'carta',
    'version': '1.3.0',
    'description': 'Python library for making GUI applications on the ReMarkable tablet wrapped around the "simple" application',
    'long_description': '# Carta\nPython library for making GUI applications on the reMarkable tablet wrapped around the ["simple"](https://rmkit.dev/apps/sas) application\n\n# Simulating the ReMarkable device\nIt can be a pain having to transfer the script & run the script from the RM each time. Especially if you want to use the device for something else at the time. To help with this, I\'ve made the option to manually set the command to a `simple` x64 binary that can be run on linux which will write to `fb.pnm` - This is the framebuffer file that you\'ll need to read from. \n\nIn the `misc` folder I\'ve provided the binary and a basic script as an example. To use this, just initialize the ReMarkable object like so:\n\n```python\nrm = ReMarkable(simple="path/to/simple/binay") \n```\n\nFinally, checkout [remarkable-sim](https://github.com/Evidlo/remarkable_sim/) for events (like button clicking) support\n\n# Using Carta\nCarta\'s purpose is to function as a Python wrapper around [*sas*](https://rmkit.dev/apps/sas) - the simple app script for making apps on the reMarkable without need to compiling code.\nIt\'s written in python and is designed to be as user-friendly and easy to use as possible.\n\nTo use it, you\'ll need to install a few things onto your reMarkable, in an SSH session:\n- [`toltec`](https://toltec-dev.org/) - an unofficial reMarkable-specific package manager\n  See instructions on toltec\'s website.\n- `simple`\n  `opkg install simple`\n- rM2 users need `display`\n  `opkg install display`\n- `pip` - the package manager for python\n  ```\n  wget https://bootstrap.pypa.io/get-pip.py\n  python get-pip.py\n  ```\n- `carta` - this library\n  `pip install carta`\n\nAfter having installed all the prerequisites, you are ready to start developing.\nMake a python script on the rM and run `chmod +x` on the script to make it executable.\nYou\'ll also need to add a `shebang` to the script (`#!/opt/bin/python` at the top) so that it knows what to run it with.\n\nHere\'s an example script that you can copy:\n\n```python\n#!/opt/bin/python \nfrom carta import ReMarkable, Widget \nrm = ReMarkable() \n\nmy_button = Widget(id="but1", typ="button", value="Hello!", x="50%", y="50%")\n\nrm.add(my_button)\nrm.display()\n```\n\nLet\'s walk through it line by line, \n\n```python\nfrom carta import ReMarkable, Widget \nrm = ReMarkable() \n```\n\nThis imports the necessary "parts" for the library to function. The `ReMarkable` class is the main "driver" code and handles everything from interacting with `simple` to display your app to managing the widgets themselves. The `widget` dataclass are the actual contents themselves and there are 6 **core types**;\n* Label\n* Paragraph\n* Button\n* TextInput\n* Text Area\n* Image\n\nPlease refer to [the `simple` spec](https://rmkit.dev/apps/sas/spec) for more detailed information. \n\n```python\nmy_button = Widget(id="but1", typ="button", value="Hello!", x="50%", y="50%")\n```\n\nHere we are making a new `Widget` which we have assigned to `my_button`.\nThe following is a table outlining information about supported arguments which can be given. \n\n| Argument | Required                      | Use                                                               | Supported inputs                                                                          | Notes                                                                                                               |\n| -------- | ----------------------------- | ----------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |\n| id       | Yes                           | Used to uniquely identify a widget when being interacted with     | Any string that hasn\'t been used before                                                   | Spaces will be converted to `_`                                                                                     |\n| typ     | Yes                           | Gives a widget specific properties so it knows what to be used as | Any from the following: `label`, `paragraph`, `burtton`, `textinput`, `textarea`, `image` | Range is a WIP                                                                                                      |\n| value    | Yes                           | What will be displayed on the widget                              | Any string (Image path for the `image` widget type)                                       | Be careful about using new lines                                                                                    |\n| x        | Yes                           | Used to calculate the rendering position of the widget            | A percentage, keyword or an integer                                                       | Supported keywords are `same` (same value as previous item) and `step` (previous item\'s cord + previous items size) |\n| y        | Yes                           | Used to calculate the rendering position of the widget            | A percentage, keyword or an integer                                                       | Supported keywords are `same` (same value as previous item) and `step` (previous item\'s cord + previous items size) |\n| width    | No (Automatically calculated) | The width of the widget                                           | Any integer                                                                               | You might have some trouble with getting the right value for this                                                   |\n| height   | No (Automatically calculated) | The height of the widget                                          | Any integer                                                                               | You might have some trouble with getting the right value for this                                                   |\n| justify         | No (Optional for buttons) | Where the text sits in a button                                | Any string from the following: `center`, `right`, `left`                                                                                          |                                                                                                                     |\n\nFinally, we want to add the widget to the actual screen. \n\n```python\nrm.add(my_button)\nrm.display()\n```\n\nI\'ve made the decision to have widgets be manually added like this to make it easier to manage when making apps).\nWe can do this easily with `add(args*)`, where `args*` are any `Widget` types - For example,\n\n```python\nrm.add(my_button, label1, logo)\n```\n\nAnd then display it to the rM! The `display()` function will take all the currently active `Widgets` and convert them into something that simple can understand and render. The active widgets are all stored in the `screen` list (in this case `rm.screen`) and you can easily access and modify any of the widgets in there at any time via the `lookup` function which will return the `Widget` object that has the corresponding ID \n\n```python\nprint(rm.lookup("<id>"))\n```\n\nTo remove a `Widget` you can use the `remove()` function and either supply it an `ID` or `Widget` object like so\n\n```python\nrm.remove("<id>")\n\nrm.remove(my_button)\n```\n\nIn case you want to fully clear the screen, you can use the `eclear()` function - however this does require the modified updated simple binary which `okeh` can provide for you! \n\n```python\nrm.eclear()\n```\n\nFinally, there are two other options that the `ReMarkable` class has that we can modify. \n* Fontsize - Changes the fontsize of the text on the screen\n* Timeout - The time after `simple` quits if no input is given\n\t* In this case, carrying on the program after `rm.display()`  has been run and no input has been given after a set time\n\nFor example, if we wanted to make the `fontsize` 24 and timeout the program after `30` seconds we would do\n\n```python\nrm.timeout = 32\nrm.fontsize = 24\n```\n\nWhen you run the `display` function, carta will wait on any input being given **OR** the timeout being reached. When it\'s done this, it will return a `dict` object with the input given.\n\n```python\nclicked = rm.display()\n\nprint(clicked) # {"<id>": True}\n```\n\nIf it\'s a `button` that has been pressed it will return `True` as the value, if anything else has been given it will use that specific input (for example, from the keyboard) as the value.\n\n\nHope this guide was helpful, feel free to ask if you need some help (`jake.sh` on discord)\n',
    'author': 'JaySec',
    'author_email': None,
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
