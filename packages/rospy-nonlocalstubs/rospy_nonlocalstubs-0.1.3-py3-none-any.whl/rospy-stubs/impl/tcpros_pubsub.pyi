import rospy.impl.transport
from _typeshed import Incomplete
from rospy.core import logdebug as logdebug, logerr as logerr, logwarn as logwarn, rospyerr as rospyerr
from rospy.impl.tcpros_base import DEFAULT_BUFF_SIZE as DEFAULT_BUFF_SIZE, TCPROS as TCPROS, TCPROSTransport as TCPROSTransport, TCPROSTransportProtocol as TCPROSTransportProtocol, get_tcpros_server_address as get_tcpros_server_address, start_tcpros_server as start_tcpros_server

class TCPROSSub(TCPROSTransportProtocol):
    direction: Incomplete
    tcp_nodelay: Incomplete
    def __init__(self, resolved_name, recv_data_class, queue_size: Incomplete | None = ..., buff_size=..., tcp_nodelay: bool = ...) -> None: ...
    def get_header_fields(self): ...

class TCPROSPub(TCPROSTransportProtocol):
    pub_data_class: Incomplete
    direction: Incomplete
    is_latch: Incomplete
    headers: Incomplete
    def __init__(self, resolved_name, pub_data_class, is_latch: bool = ..., headers: Incomplete | None = ...) -> None: ...
    def get_header_fields(self): ...

def robust_connect_subscriber(conn, dest_addr, dest_port, pub_uri, receive_cb, resolved_topic_name) -> None: ...
def check_if_still_publisher(resolved_topic_name, pub_uri): ...

class TCPROSHandler(rospy.impl.transport.ProtocolHandler):
    tcp_nodelay_map: Incomplete
    def __init__(self) -> None: ...
    def set_tcp_nodelay(self, resolved_name, tcp_nodelay) -> None: ...
    def shutdown(self) -> None: ...
    def create_transport(self, resolved_name, pub_uri, protocol_params): ...
    def supports(self, protocol): ...
    def get_supported(self): ...
    def init_publisher(self, resolved_name, protocol): ...
    def topic_connection_handler(self, sock, client_addr, header): ...

class QueuedConnection:
    def __init__(self, connection, queue_size) -> None: ...
    def __getattr__(self, name): ...
    def write_data(self, data): ...
